{"version":3,"file":"static/chunks/pages/_app-0bfb02e345a44492.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@sentry/hub/esm/exports.js","webpack://_N_E/./node_modules/@sentry/hub/esm/hub.js","webpack://_N_E/./node_modules/@sentry/hub/esm/scope.js","webpack://_N_E/./node_modules/@sentry/hub/esm/session.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/errors.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/hubextensions.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/idletransaction.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/span.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/transaction.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/utils.js","webpack://_N_E/./node_modules/@sentry/utils/esm/browser.js","webpack://_N_E/./node_modules/@sentry/utils/esm/buildPolyfills/_nullishCoalesce.js","webpack://_N_E/./node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.js","webpack://_N_E/./node_modules/@sentry/utils/esm/global.js","webpack://_N_E/./node_modules/@sentry/utils/esm/instrument.js","webpack://_N_E/./node_modules/@sentry/utils/esm/is.js","webpack://_N_E/./node_modules/@sentry/utils/esm/logger.js","webpack://_N_E/./node_modules/@sentry/utils/esm/misc.js","webpack://_N_E/./node_modules/@sentry/utils/esm/env.js","webpack://_N_E/./node_modules/@sentry/utils/esm/node.js","webpack://_N_E/./node_modules/@sentry/utils/esm/memo.js","webpack://_N_E/./node_modules/@sentry/utils/esm/normalize.js","webpack://_N_E/./node_modules/@sentry/utils/esm/object.js","webpack://_N_E/./node_modules/@sentry/utils/esm/stacktrace.js","webpack://_N_E/./node_modules/@sentry/utils/esm/string.js","webpack://_N_E/./node_modules/@sentry/utils/esm/supports.js","webpack://_N_E/./node_modules/@sentry/utils/esm/syncpromise.js","webpack://_N_E/./node_modules/@sentry/utils/esm/time.js","webpack://_N_E/./node_modules/@sentry/utils/esm/url.js","webpack://_N_E/./node_modules/@sentry/webpack-plugin/src/sentry-webpack.module.js","webpack://_N_E/./node_modules/next/dist/build/polyfills/process.js","webpack://_N_E/","webpack://_N_E/./node_modules/@sentry/core/esm/version.js","webpack://_N_E/./node_modules/@sentry/core/esm/integrations/inboundfilters.js","webpack://_N_E/./node_modules/@sentry/core/esm/integrations/functiontostring.js","webpack://_N_E/./node_modules/@sentry/core/esm/integration.js","webpack://_N_E/./node_modules/@sentry/core/esm/sdk.js","webpack://_N_E/./node_modules/@sentry/utils/esm/error.js","webpack://_N_E/./node_modules/@sentry/utils/esm/dsn.js","webpack://_N_E/./node_modules/@sentry/utils/esm/envelope.js","webpack://_N_E/./node_modules/@sentry/core/esm/api.js","webpack://_N_E/./node_modules/@sentry/core/esm/envelope.js","webpack://_N_E/./node_modules/@sentry/core/esm/baseclient.js","webpack://_N_E/./node_modules/@sentry/utils/esm/clientreport.js","webpack://_N_E/./node_modules/@sentry/browser/esm/eventbuilder.js","webpack://_N_E/./node_modules/@sentry/utils/esm/severity.js","webpack://_N_E/./node_modules/@sentry/browser/esm/integrations/breadcrumbs.js","webpack://_N_E/./node_modules/@sentry/browser/esm/transports/utils.js","webpack://_N_E/./node_modules/@sentry/browser/esm/client.js","webpack://_N_E/./node_modules/@sentry/browser/esm/stack-parsers.js","webpack://_N_E/./node_modules/@sentry/browser/esm/helpers.js","webpack://_N_E/./node_modules/@sentry/browser/esm/integrations/trycatch.js","webpack://_N_E/./node_modules/@sentry/browser/esm/integrations/globalhandlers.js","webpack://_N_E/./node_modules/@sentry/browser/esm/integrations/linkederrors.js","webpack://_N_E/./node_modules/@sentry/browser/esm/integrations/dedupe.js","webpack://_N_E/./node_modules/@sentry/browser/esm/integrations/httpcontext.js","webpack://_N_E/./node_modules/@sentry/utils/esm/promisebuffer.js","webpack://_N_E/./node_modules/@sentry/utils/esm/ratelimit.js","webpack://_N_E/./node_modules/@sentry/core/esm/transports/base.js","webpack://_N_E/./node_modules/@sentry/browser/esm/transports/fetch.js","webpack://_N_E/./node_modules/@sentry/browser/esm/transports/xhr.js","webpack://_N_E/./node_modules/@sentry/browser/esm/sdk.js","webpack://_N_E/./node_modules/@sentry/react/esm/sdk.js","webpack://_N_E/./node_modules/@sentry/utils/esm/tracing.js","webpack://_N_E/./node_modules/@sentry/utils/esm/baggage.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/backgroundtab.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/bindReporter.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/generateUniqueID.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/initMetric.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/observe.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/onHidden.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/web-vitals/getCLS.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/getVisibilityWatcher.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/web-vitals/getFID.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/web-vitals/getLCP.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/metrics/utils.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/metrics/index.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/request.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/router.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/browsertracing.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/index.js","webpack://_N_E/./node_modules/@sentry/nextjs/esm/performance/client.js","webpack://_N_E/./node_modules/@sentry/nextjs/esm/utils/metadata.js","webpack://_N_E/./node_modules/@sentry/nextjs/esm/utils/userIntegrations.js","webpack://_N_E/./node_modules/@sentry/nextjs/esm/index.client.js","webpack://_N_E/./sentry.client.config.js","webpack://_N_E/./node_modules/next/dist/compiled/process/browser.js","webpack://_N_E/./node_modules/next/router.js","webpack://_N_E/<anon>"],"sourcesContent":["import { getCurrentHub } from './hub.js';\n\n// Note: All functions in this file are typed with a return value of `ReturnType<Hub[HUB_FUNCTION]>`,\n// where HUB_FUNCTION is some method on the Hub class.\n//\n// This is done to make sure the top level SDK methods stay in sync with the hub methods.\n// Although every method here has an explicit return type, some of them (that map to void returns) do not\n// contain `return` keywords. This is done to save on bundle size, as `return` is not minifiable.\n\n/**\n * Captures an exception event and sends it to Sentry.\n *\n * @param exception An exception-like object.\n * @param captureContext Additional scope data to apply to exception event.\n * @returns The generated eventId.\n */\nfunction captureException(exception, captureContext) {\n  return getCurrentHub().captureException(exception, { captureContext });\n}\n\n/**\n * Captures a message event and sends it to Sentry.\n *\n * @param message The message to send to Sentry.\n * @param Severity Define the level of the message.\n * @returns The generated eventId.\n */\nfunction captureMessage(\n  message,\n    captureContext,\n) {\n  // This is necessary to provide explicit scopes upgrade, without changing the original\n  // arity of the `captureMessage(message, level)` method.\n  var level = typeof captureContext === 'string' ? captureContext : undefined;\n  var context = typeof captureContext !== 'string' ? { captureContext } : undefined;\n  return getCurrentHub().captureMessage(message, level, context);\n}\n\n/**\n * Captures a manually created event and sends it to Sentry.\n *\n * @param event The event to send to Sentry.\n * @returns The generated eventId.\n */\nfunction captureEvent(event, hint) {\n  return getCurrentHub().captureEvent(event, hint);\n}\n\n/**\n * Callback to set context information onto the scope.\n * @param callback Callback function that receives Scope.\n */\nfunction configureScope(callback) {\n  getCurrentHub().configureScope(callback);\n}\n\n/**\n * Records a new breadcrumb which will be attached to future events.\n *\n * Breadcrumbs will be added to subsequent events to provide more context on\n * user's actions prior to an error or crash.\n *\n * @param breadcrumb The breadcrumb to record.\n */\nfunction addBreadcrumb(breadcrumb) {\n  getCurrentHub().addBreadcrumb(breadcrumb);\n}\n\n/**\n * Sets context data with the given name.\n * @param name of the context\n * @param context Any kind of data. This data will be normalized.\n */\nfunction setContext(name, context) {\n  getCurrentHub().setContext(name, context);\n}\n\n/**\n * Set an object that will be merged sent as extra data with the event.\n * @param extras Extras object to merge into current context.\n */\nfunction setExtras(extras) {\n  getCurrentHub().setExtras(extras);\n}\n\n/**\n * Set key:value that will be sent as extra data with the event.\n * @param key String of extra\n * @param extra Any kind of data. This data will be normalized.\n */\nfunction setExtra(key, extra) {\n  getCurrentHub().setExtra(key, extra);\n}\n\n/**\n * Set an object that will be merged sent as tags data with the event.\n * @param tags Tags context object to merge into current context.\n */\nfunction setTags(tags) {\n  getCurrentHub().setTags(tags);\n}\n\n/**\n * Set key:value that will be sent as tags data with the event.\n *\n * Can also be used to unset a tag, by passing `undefined`.\n *\n * @param key String key of tag\n * @param value Value of tag\n */\nfunction setTag(key, value) {\n  getCurrentHub().setTag(key, value);\n}\n\n/**\n * Updates user context information for future events.\n *\n * @param user User context object to be set in the current context. Pass `null` to unset the user.\n */\nfunction setUser(user) {\n  getCurrentHub().setUser(user);\n}\n\n/**\n * Creates a new scope with and executes the given operation within.\n * The scope is automatically removed once the operation\n * finishes or throws.\n *\n * This is essentially a convenience function for:\n *\n *     pushScope();\n *     callback();\n *     popScope();\n *\n * @param callback that will be enclosed into push/popScope.\n */\nfunction withScope(callback) {\n  getCurrentHub().withScope(callback);\n}\n\n/**\n * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.\n *\n * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a\n * new child span within the transaction or any span, call the respective `.startChild()` method.\n *\n * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.\n *\n * The transaction must be finished with a call to its `.finish()` method, at which point the transaction with all its\n * finished child spans will be sent to Sentry.\n *\n * NOTE: This function should only be used for *manual* instrumentation. Auto-instrumentation should call\n * `startTransaction` directly on the hub.\n *\n * @param context Properties of the new `Transaction`.\n * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent\n * default values). See {@link Options.tracesSampler}.\n *\n * @returns The transaction which was just started\n */\nfunction startTransaction(\n  context,\n  customSamplingContext,\n) {\n  return getCurrentHub().startTransaction({ ...context }, customSamplingContext);\n}\n\nexport { addBreadcrumb, captureEvent, captureException, captureMessage, configureScope, setContext, setExtra, setExtras, setTag, setTags, setUser, startTransaction, withScope };\n//# sourceMappingURL=exports.js.map\n","import { uuid4, dateTimestampInSeconds, consoleSandbox, logger, getGlobalObject, getGlobalSingleton, isNodeEnv } from '@sentry/utils';\nimport { Scope } from './scope.js';\nimport { closeSession, makeSession, updateSession } from './session.js';\n\n/**\n * API compatibility version of this hub.\n *\n * WARNING: This number should only be increased when the global interface\n * changes and new methods are introduced.\n *\n * @hidden\n */\nvar API_VERSION = 4;\n\n/**\n * Default maximum number of breadcrumbs added to an event. Can be overwritten\n * with {@link Options.maxBreadcrumbs}.\n */\nvar DEFAULT_BREADCRUMBS = 100;\n\n/**\n * A layer in the process stack.\n * @hidden\n */\n\n/**\n * @inheritDoc\n */\nclass Hub  {\n  /** Is a {@link Layer}[] containing the client and scope */\n    __init() {this._stack = [{}];}\n\n  /** Contains the last event id of a captured event.  */\n  \n\n  /**\n   * Creates a new instance of the hub, will push one {@link Layer} into the\n   * internal stack on creation.\n   *\n   * @param client bound to the hub.\n   * @param scope bound to the hub.\n   * @param version number, higher number means higher priority.\n   */\n   constructor(client, scope = new Scope(),   _version = API_VERSION) {;this._version = _version;Hub.prototype.__init.call(this);\n    this.getStackTop().scope = scope;\n    if (client) {\n      this.bindClient(client);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   isOlderThan(version) {\n    return this._version < version;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   bindClient(client) {\n    var top = this.getStackTop();\n    top.client = client;\n    if (client && client.setupIntegrations) {\n      client.setupIntegrations();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   pushScope() {\n    // We want to clone the content of prev scope\n    var scope = Scope.clone(this.getScope());\n    this.getStack().push({\n      client: this.getClient(),\n      scope,\n    });\n    return scope;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   popScope() {\n    if (this.getStack().length <= 1) return false;\n    return !!this.getStack().pop();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   withScope(callback) {\n    var scope = this.pushScope();\n    try {\n      callback(scope);\n    } finally {\n      this.popScope();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getClient() {\n    return this.getStackTop().client ;\n  }\n\n  /** Returns the scope of the top stack. */\n   getScope() {\n    return this.getStackTop().scope;\n  }\n\n  /** Returns the scope stack for domains or the process. */\n   getStack() {\n    return this._stack;\n  }\n\n  /** Returns the topmost scope layer in the order domain > local > process. */\n   getStackTop() {\n    return this._stack[this._stack.length - 1];\n  }\n\n  /**\n   * @inheritDoc\n   */\n     captureException(exception, hint) {\n    var eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4());\n    var syntheticException = new Error('Sentry syntheticException');\n    this._withClient((client, scope) => {\n      client.captureException(\n        exception,\n        {\n          originalException: exception,\n          syntheticException,\n          ...hint,\n          event_id: eventId,\n        },\n        scope,\n      );\n    });\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureMessage(\n    message,\n        level,\n    hint,\n  ) {\n    var eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4());\n    var syntheticException = new Error(message);\n    this._withClient((client, scope) => {\n      client.captureMessage(\n        message,\n        level,\n        {\n          originalException: message,\n          syntheticException,\n          ...hint,\n          event_id: eventId,\n        },\n        scope,\n      );\n    });\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureEvent(event, hint) {\n    var eventId = hint && hint.event_id ? hint.event_id : uuid4();\n    if (event.type !== 'transaction') {\n      this._lastEventId = eventId;\n    }\n\n    this._withClient((client, scope) => {\n      client.captureEvent(event, { ...hint, event_id: eventId }, scope);\n    });\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   lastEventId() {\n    return this._lastEventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addBreadcrumb(breadcrumb, hint) {\n    const { scope, client } = this.getStackTop();\n\n    if (!scope || !client) return;\n\n        const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } =\n      (client.getOptions && client.getOptions()) || {};\n\n    if (maxBreadcrumbs <= 0) return;\n\n    var timestamp = dateTimestampInSeconds();\n    var mergedBreadcrumb = { timestamp, ...breadcrumb };\n    var finalBreadcrumb = beforeBreadcrumb\n      ? (consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint)) )\n      : mergedBreadcrumb;\n\n    if (finalBreadcrumb === null) return;\n\n    scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setUser(user) {\n    var scope = this.getScope();\n    if (scope) scope.setUser(user);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTags(tags) {\n    var scope = this.getScope();\n    if (scope) scope.setTags(tags);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setExtras(extras) {\n    var scope = this.getScope();\n    if (scope) scope.setExtras(extras);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTag(key, value) {\n    var scope = this.getScope();\n    if (scope) scope.setTag(key, value);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setExtra(key, extra) {\n    var scope = this.getScope();\n    if (scope) scope.setExtra(key, extra);\n  }\n\n  /**\n   * @inheritDoc\n   */\n     setContext(name, context) {\n    var scope = this.getScope();\n    if (scope) scope.setContext(name, context);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   configureScope(callback) {\n    const { scope, client } = this.getStackTop();\n    if (scope && client) {\n      callback(scope);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   run(callback) {\n    var oldHub = makeMain(this);\n    try {\n      callback(this);\n    } finally {\n      makeMain(oldHub);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getIntegration(integration) {\n    var client = this.getClient();\n    if (!client) return null;\n    try {\n      return client.getIntegration(integration);\n    } catch (_oO) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(`Cannot retrieve integration ${integration.id} from the current Hub`);\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   startTransaction(context, customSamplingContext) {\n    return this._callExtensionMethod('startTransaction', context, customSamplingContext);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   traceHeaders() {\n    return this._callExtensionMethod('traceHeaders');\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureSession(endSession = false) {\n    // both send the update and pull the session from the scope\n    if (endSession) {\n      return this.endSession();\n    }\n\n    // only send the update\n    this._sendSessionUpdate();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   endSession() {\n    var layer = this.getStackTop();\n    var scope = layer && layer.scope;\n    var session = scope && scope.getSession();\n    if (session) {\n      closeSession(session);\n    }\n    this._sendSessionUpdate();\n\n    // the session is over; take it off of the scope\n    if (scope) {\n      scope.setSession();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   startSession(context) {\n    const { scope, client } = this.getStackTop();\n    const { release, environment } = (client && client.getOptions()) || {};\n\n    // Will fetch userAgent if called from browser sdk\n    var global = getGlobalObject();\n    const { userAgent } = global.navigator || {};\n\n    var session = makeSession({\n      release,\n      environment,\n      ...(scope && { user: scope.getUser() }),\n      ...(userAgent && { userAgent }),\n      ...context,\n    });\n\n    if (scope) {\n      // End existing session if there's one\n      var currentSession = scope.getSession && scope.getSession();\n      if (currentSession && currentSession.status === 'ok') {\n        updateSession(currentSession, { status: 'exited' });\n      }\n      this.endSession();\n\n      // Afterwards we set the new session on the scope\n      scope.setSession(session);\n    }\n\n    return session;\n  }\n\n  /**\n   * Returns if default PII should be sent to Sentry and propagated in ourgoing requests\n   * when Tracing is used.\n   */\n   shouldSendDefaultPii() {\n    var client = this.getClient();\n    var options = client && client.getOptions();\n    return Boolean(options && options.sendDefaultPii);\n  }\n\n  /**\n   * Sends the current Session on the scope\n   */\n   _sendSessionUpdate() {\n    const { scope, client } = this.getStackTop();\n    if (!scope) return;\n\n    var session = scope.getSession();\n    if (session) {\n      if (client && client.captureSession) {\n        client.captureSession(session);\n      }\n    }\n  }\n\n  /**\n   * Internal helper function to call a method on the top client if it exists.\n   *\n   * @param method The method to call on the client.\n   * @param args Arguments to pass to the client function.\n   */\n   _withClient(callback) {\n    const { scope, client } = this.getStackTop();\n    if (client) {\n      callback(client, scope);\n    }\n  }\n\n  /**\n   * Calls global extension method and binding current instance to the function call\n   */\n  // @ts-ignore Function lacks ending return statement and return type does not include 'undefined'. ts(2366)\n     _callExtensionMethod(method, ...args) {\n    var carrier = getMainCarrier();\n    var sentry = carrier.__SENTRY__;\n    if (sentry && sentry.extensions && typeof sentry.extensions[method] === 'function') {\n      return sentry.extensions[method].apply(this, args);\n    }\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(`Extension method ${method} couldn't be found, doing nothing.`);\n  }\n}\n\n/**\n * Returns the global shim registry.\n *\n * FIXME: This function is problematic, because despite always returning a valid Carrier,\n * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check\n * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.\n **/\nfunction getMainCarrier() {\n  var carrier = getGlobalObject();\n  carrier.__SENTRY__ = carrier.__SENTRY__ || {\n    extensions: {},\n    hub: undefined,\n  };\n  return carrier;\n}\n\n/**\n * Replaces the current main hub with the passed one on the global object\n *\n * @returns The old replaced hub\n */\nfunction makeMain(hub) {\n  var registry = getMainCarrier();\n  var oldHub = getHubFromCarrier(registry);\n  setHubOnCarrier(registry, hub);\n  return oldHub;\n}\n\n/**\n * Returns the default hub instance.\n *\n * If a hub is already registered in the global carrier but this module\n * contains a more recent version, it replaces the registered version.\n * Otherwise, the currently registered hub will be returned.\n */\nfunction getCurrentHub() {\n  // Get main carrier (global for every environment)\n  var registry = getMainCarrier();\n\n  // If there's no hub, or its an old API, assign a new one\n  if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(API_VERSION)) {\n    setHubOnCarrier(registry, new Hub());\n  }\n\n  // Prefer domains over global if they are there (applicable only to Node environment)\n  if (isNodeEnv()) {\n    return getHubFromActiveDomain(registry);\n  }\n  // Return hub that lives on a global object\n  return getHubFromCarrier(registry);\n}\n\n/**\n * Try to read the hub from an active domain, and fallback to the registry if one doesn't exist\n * @returns discovered hub\n */\nfunction getHubFromActiveDomain(registry) {\n  try {\n    var sentry = getMainCarrier().__SENTRY__;\n    var activeDomain = sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;\n\n    // If there's no active domain, just return global hub\n    if (!activeDomain) {\n      return getHubFromCarrier(registry);\n    }\n\n    // If there's no hub on current domain, or it's an old API, assign a new one\n    if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(API_VERSION)) {\n      var registryHubTopStack = getHubFromCarrier(registry).getStackTop();\n      setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, Scope.clone(registryHubTopStack.scope)));\n    }\n\n    // Return hub that lives on a domain\n    return getHubFromCarrier(activeDomain);\n  } catch (_Oo) {\n    // Return hub that lives on a global object\n    return getHubFromCarrier(registry);\n  }\n}\n\n/**\n * This will tell whether a carrier has a hub on it or not\n * @param carrier object\n */\nfunction hasHubOnCarrier(carrier) {\n  return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);\n}\n\n/**\n * This will create a new {@link Hub} and add to the passed object on\n * __SENTRY__.hub.\n * @param carrier object\n * @hidden\n */\nfunction getHubFromCarrier(carrier) {\n  return getGlobalSingleton('hub', () => new Hub(), carrier);\n}\n\n/**\n * This will set passed {@link Hub} on the passed object's __SENTRY__.hub attribute\n * @param carrier object\n * @param hub Hub\n * @returns A boolean indicating success or failure\n */\nfunction setHubOnCarrier(carrier, hub) {\n  if (!carrier) return false;\n  var __SENTRY__ = (carrier.__SENTRY__ = carrier.__SENTRY__ || {});\n  __SENTRY__.hub = hub;\n  return true;\n}\n\nexport { API_VERSION, Hub, getCurrentHub, getHubFromCarrier, getMainCarrier, makeMain, setHubOnCarrier };\n//# sourceMappingURL=hub.js.map\n","import { isPlainObject, dateTimestampInSeconds, getGlobalSingleton, SyncPromise, logger, isThenable, arrayify } from '@sentry/utils';\nimport { updateSession } from './session.js';\n\n/**\n * Absolute maximum number of breadcrumbs added to an event.\n * The `maxBreadcrumbs` option cannot be higher than this value.\n */\nvar MAX_BREADCRUMBS = 100;\n\n/**\n * Holds additional event information. {@link Scope.applyToEvent} will be\n * called by the client before an event will be sent.\n */\nclass Scope  {\n  /** Flag if notifying is happening. */\n  \n\n  /** Callback for client to receive scope changes. */\n  \n\n  /** Callback list that will be called after {@link applyToEvent}. */\n  \n\n  /** Array of breadcrumbs. */\n  \n\n  /** User */\n  \n\n  /** Tags */\n  \n\n  /** Extra */\n  \n\n  /** Contexts */\n  \n\n  /** Attachments */\n  \n\n  /**\n   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get\n   * sent to Sentry\n   */\n  \n\n  /** Fingerprint */\n  \n\n  /** Severity */\n    \n\n  /** Transaction Name */\n  \n\n  /** Span */\n  \n\n  /** Session */\n  \n\n  /** Request Mode Session Status */\n  \n\n   constructor() {\n    this._notifyingListeners = false;\n    this._scopeListeners = [];\n    this._eventProcessors = [];\n    this._breadcrumbs = [];\n    this._attachments = [];\n    this._user = {};\n    this._tags = {};\n    this._extra = {};\n    this._contexts = {};\n    this._sdkProcessingMetadata = {};\n  }\n\n  /**\n   * Inherit values from the parent scope.\n   * @param scope to clone.\n   */\n   static clone(scope) {\n    var newScope = new Scope();\n    if (scope) {\n      newScope._breadcrumbs = [...scope._breadcrumbs];\n      newScope._tags = { ...scope._tags };\n      newScope._extra = { ...scope._extra };\n      newScope._contexts = { ...scope._contexts };\n      newScope._user = scope._user;\n      newScope._level = scope._level;\n      newScope._span = scope._span;\n      newScope._session = scope._session;\n      newScope._transactionName = scope._transactionName;\n      newScope._fingerprint = scope._fingerprint;\n      newScope._eventProcessors = [...scope._eventProcessors];\n      newScope._requestSession = scope._requestSession;\n      newScope._attachments = [...scope._attachments];\n    }\n    return newScope;\n  }\n\n  /**\n   * Add internal on change listener. Used for sub SDKs that need to store the scope.\n   * @hidden\n   */\n   addScopeListener(callback) {\n    this._scopeListeners.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addEventProcessor(callback) {\n    this._eventProcessors.push(callback);\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setUser(user) {\n    this._user = user || {};\n    if (this._session) {\n      updateSession(this._session, { user });\n    }\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getUser() {\n    return this._user;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getRequestSession() {\n    return this._requestSession;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setRequestSession(requestSession) {\n    this._requestSession = requestSession;\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTags(tags) {\n    this._tags = {\n      ...this._tags,\n      ...tags,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTag(key, value) {\n    this._tags = { ...this._tags, [key]: value };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setExtras(extras) {\n    this._extra = {\n      ...this._extra,\n      ...extras,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setExtra(key, extra) {\n    this._extra = { ...this._extra, [key]: extra };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setFingerprint(fingerprint) {\n    this._fingerprint = fingerprint;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setLevel(\n        level,\n  ) {\n    this._level = level;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTransactionName(name) {\n    this._transactionName = name;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setContext(key, context) {\n    if (context === null) {\n            delete this._contexts[key];\n    } else {\n      this._contexts = { ...this._contexts, [key]: context };\n    }\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setSpan(span) {\n    this._span = span;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getSpan() {\n    return this._span;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getTransaction() {\n    // Often, this span (if it exists at all) will be a transaction, but it's not guaranteed to be. Regardless, it will\n    // have a pointer to the currently-active transaction.\n    var span = this.getSpan();\n    return span && span.transaction;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setSession(session) {\n    if (!session) {\n      delete this._session;\n    } else {\n      this._session = session;\n    }\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getSession() {\n    return this._session;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   update(captureContext) {\n    if (!captureContext) {\n      return this;\n    }\n\n    if (typeof captureContext === 'function') {\n      var updatedScope = (captureContext )(this);\n      return updatedScope instanceof Scope ? updatedScope : this;\n    }\n\n    if (captureContext instanceof Scope) {\n      this._tags = { ...this._tags, ...captureContext._tags };\n      this._extra = { ...this._extra, ...captureContext._extra };\n      this._contexts = { ...this._contexts, ...captureContext._contexts };\n      if (captureContext._user && Object.keys(captureContext._user).length) {\n        this._user = captureContext._user;\n      }\n      if (captureContext._level) {\n        this._level = captureContext._level;\n      }\n      if (captureContext._fingerprint) {\n        this._fingerprint = captureContext._fingerprint;\n      }\n      if (captureContext._requestSession) {\n        this._requestSession = captureContext._requestSession;\n      }\n    } else if (isPlainObject(captureContext)) {\n            captureContext = captureContext ;\n      this._tags = { ...this._tags, ...captureContext.tags };\n      this._extra = { ...this._extra, ...captureContext.extra };\n      this._contexts = { ...this._contexts, ...captureContext.contexts };\n      if (captureContext.user) {\n        this._user = captureContext.user;\n      }\n      if (captureContext.level) {\n        this._level = captureContext.level;\n      }\n      if (captureContext.fingerprint) {\n        this._fingerprint = captureContext.fingerprint;\n      }\n      if (captureContext.requestSession) {\n        this._requestSession = captureContext.requestSession;\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   clear() {\n    this._breadcrumbs = [];\n    this._tags = {};\n    this._extra = {};\n    this._user = {};\n    this._contexts = {};\n    this._level = undefined;\n    this._transactionName = undefined;\n    this._fingerprint = undefined;\n    this._requestSession = undefined;\n    this._span = undefined;\n    this._session = undefined;\n    this._notifyScopeListeners();\n    this._attachments = [];\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addBreadcrumb(breadcrumb, maxBreadcrumbs) {\n    var maxCrumbs = typeof maxBreadcrumbs === 'number' ? Math.min(maxBreadcrumbs, MAX_BREADCRUMBS) : MAX_BREADCRUMBS;\n\n    // No data has been changed, so don't notify scope listeners\n    if (maxCrumbs <= 0) {\n      return this;\n    }\n\n    var mergedBreadcrumb = {\n      timestamp: dateTimestampInSeconds(),\n      ...breadcrumb,\n    };\n    this._breadcrumbs = [...this._breadcrumbs, mergedBreadcrumb].slice(-maxCrumbs);\n    this._notifyScopeListeners();\n\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   clearBreadcrumbs() {\n    this._breadcrumbs = [];\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addAttachment(attachment) {\n    this._attachments.push(attachment);\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getAttachments() {\n    return this._attachments;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   clearAttachments() {\n    this._attachments = [];\n    return this;\n  }\n\n  /**\n   * Applies data from the scope to the event and runs all event processors on it.\n   *\n   * @param event Event\n   * @param hint Object containing additional information about the original exception, for use by the event processors.\n   * @hidden\n   */\n   applyToEvent(event, hint = {}) {\n    if (this._extra && Object.keys(this._extra).length) {\n      event.extra = { ...this._extra, ...event.extra };\n    }\n    if (this._tags && Object.keys(this._tags).length) {\n      event.tags = { ...this._tags, ...event.tags };\n    }\n    if (this._user && Object.keys(this._user).length) {\n      event.user = { ...this._user, ...event.user };\n    }\n    if (this._contexts && Object.keys(this._contexts).length) {\n      event.contexts = { ...this._contexts, ...event.contexts };\n    }\n    if (this._level) {\n      event.level = this._level;\n    }\n    if (this._transactionName) {\n      event.transaction = this._transactionName;\n    }\n\n    // We want to set the trace context for normal events only if there isn't already\n    // a trace context on the event. There is a product feature in place where we link\n    // errors with transaction and it relies on that.\n    if (this._span) {\n      event.contexts = { trace: this._span.getTraceContext(), ...event.contexts };\n      var transactionName = this._span.transaction && this._span.transaction.name;\n      if (transactionName) {\n        event.tags = { transaction: transactionName, ...event.tags };\n      }\n    }\n\n    this._applyFingerprint(event);\n\n    event.breadcrumbs = [...(event.breadcrumbs || []), ...this._breadcrumbs];\n    event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : undefined;\n\n    event.sdkProcessingMetadata = { ...event.sdkProcessingMetadata, ...this._sdkProcessingMetadata };\n\n    return this._notifyEventProcessors([...getGlobalEventProcessors(), ...this._eventProcessors], event, hint);\n  }\n\n  /**\n   * Add data which will be accessible during event processing but won't get sent to Sentry\n   */\n   setSDKProcessingMetadata(newData) {\n    this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...newData };\n\n    return this;\n  }\n\n  /**\n   * This will be called after {@link applyToEvent} is finished.\n   */\n   _notifyEventProcessors(\n    processors,\n    event,\n    hint,\n    index = 0,\n  ) {\n    return new SyncPromise((resolve, reject) => {\n      var processor = processors[index];\n      if (event === null || typeof processor !== 'function') {\n        resolve(event);\n      } else {\n        var result = processor({ ...event }, hint) ;\n\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n          processor.id &&\n          result === null &&\n          logger.log(`Event processor \"${processor.id}\" dropped event`);\n\n        if (isThenable(result)) {\n          void result\n            .then(final => this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve))\n            .then(null, reject);\n        } else {\n          void this._notifyEventProcessors(processors, result, hint, index + 1)\n            .then(resolve)\n            .then(null, reject);\n        }\n      }\n    });\n  }\n\n  /**\n   * This will be called on every set call.\n   */\n   _notifyScopeListeners() {\n    // We need this check for this._notifyingListeners to be able to work on scope during updates\n    // If this check is not here we'll produce endless recursion when something is done with the scope\n    // during the callback.\n    if (!this._notifyingListeners) {\n      this._notifyingListeners = true;\n      this._scopeListeners.forEach(callback => {\n        callback(this);\n      });\n      this._notifyingListeners = false;\n    }\n  }\n\n  /**\n   * Applies fingerprint from the scope to the event if there's one,\n   * uses message if there's one instead or get rid of empty fingerprint\n   */\n   _applyFingerprint(event) {\n    // Make sure it's an array first and we actually have something in place\n    event.fingerprint = event.fingerprint ? arrayify(event.fingerprint) : [];\n\n    // If we have something on the scope, then merge it with event\n    if (this._fingerprint) {\n      event.fingerprint = event.fingerprint.concat(this._fingerprint);\n    }\n\n    // If we have no data at all, remove empty array default\n    if (event.fingerprint && !event.fingerprint.length) {\n      delete event.fingerprint;\n    }\n  }\n}\n\n/**\n * Returns the global event processors.\n */\nfunction getGlobalEventProcessors() {\n  return getGlobalSingleton('globalEventProcessors', () => []);\n}\n\n/**\n * Add a EventProcessor to be kept globally.\n * @param callback EventProcessor to add\n */\nfunction addGlobalEventProcessor(callback) {\n  getGlobalEventProcessors().push(callback);\n}\n\nexport { Scope, addGlobalEventProcessor };\n//# sourceMappingURL=scope.js.map\n","import { timestampInSeconds, uuid4, dropUndefinedKeys } from '@sentry/utils';\n\n/**\n * Creates a new `Session` object by setting certain default parameters. If optional @param context\n * is passed, the passed properties are applied to the session object.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns a new `Session` object\n */\nfunction makeSession(context) {\n  // Both timestamp and started are in seconds since the UNIX epoch.\n  var startingTime = timestampInSeconds();\n\n  var session = {\n    sid: uuid4(),\n    init: true,\n    timestamp: startingTime,\n    started: startingTime,\n    duration: 0,\n    status: 'ok',\n    errors: 0,\n    ignoreDuration: false,\n    toJSON: () => sessionToJSON(session),\n  };\n\n  if (context) {\n    updateSession(session, context);\n  }\n\n  return session;\n}\n\n/**\n * Updates a session object with the properties passed in the context.\n *\n * Note that this function mutates the passed object and returns void.\n * (Had to do this instead of returning a new and updated session because closing and sending a session\n * makes an update to the session after it was passed to the sending logic.\n * @see BaseClient.captureSession )\n *\n * @param session the `Session` to update\n * @param context the `SessionContext` holding the properties that should be updated in @param session\n */\nfunction updateSession(session, context = {}) {\n  if (context.user) {\n    if (!session.ipAddress && context.user.ip_address) {\n      session.ipAddress = context.user.ip_address;\n    }\n\n    if (!session.did && !context.did) {\n      session.did = context.user.id || context.user.email || context.user.username;\n    }\n  }\n\n  session.timestamp = context.timestamp || timestampInSeconds();\n\n  if (context.ignoreDuration) {\n    session.ignoreDuration = context.ignoreDuration;\n  }\n  if (context.sid) {\n    // Good enough uuid validation.  Kamil\n    session.sid = context.sid.length === 32 ? context.sid : uuid4();\n  }\n  if (context.init !== undefined) {\n    session.init = context.init;\n  }\n  if (!session.did && context.did) {\n    session.did = `${context.did}`;\n  }\n  if (typeof context.started === 'number') {\n    session.started = context.started;\n  }\n  if (session.ignoreDuration) {\n    session.duration = undefined;\n  } else if (typeof context.duration === 'number') {\n    session.duration = context.duration;\n  } else {\n    var duration = session.timestamp - session.started;\n    session.duration = duration >= 0 ? duration : 0;\n  }\n  if (context.release) {\n    session.release = context.release;\n  }\n  if (context.environment) {\n    session.environment = context.environment;\n  }\n  if (!session.ipAddress && context.ipAddress) {\n    session.ipAddress = context.ipAddress;\n  }\n  if (!session.userAgent && context.userAgent) {\n    session.userAgent = context.userAgent;\n  }\n  if (typeof context.errors === 'number') {\n    session.errors = context.errors;\n  }\n  if (context.status) {\n    session.status = context.status;\n  }\n}\n\n/**\n * Closes a session by setting its status and updating the session object with it.\n * Internally calls `updateSession` to update the passed session object.\n *\n * Note that this function mutates the passed session (@see updateSession for explanation).\n *\n * @param session the `Session` object to be closed\n * @param status the `SessionStatus` with which the session was closed. If you don't pass a status,\n *               this function will keep the previously set status, unless it was `'ok'` in which case\n *               it is changed to `'exited'`.\n */\nfunction closeSession(session, status) {\n  let context = {};\n  if (status) {\n    context = { status };\n  } else if (session.status === 'ok') {\n    context = { status: 'exited' };\n  }\n\n  updateSession(session, context);\n}\n\n/**\n * Serializes a passed session object to a JSON object with a slightly different structure.\n * This is necessary because the Sentry backend requires a slightly different schema of a session\n * than the one the JS SDKs use internally.\n *\n * @param session the session to be converted\n *\n * @returns a JSON object of the passed session\n */\nfunction sessionToJSON(session) {\n  return dropUndefinedKeys({\n    sid: `${session.sid}`,\n    init: session.init,\n    // Make sure that sec is converted to ms for date constructor\n    started: new Date(session.started * 1000).toISOString(),\n    timestamp: new Date(session.timestamp * 1000).toISOString(),\n    status: session.status,\n    errors: session.errors,\n    did: typeof session.did === 'number' || typeof session.did === 'string' ? `${session.did}` : undefined,\n    duration: session.duration,\n    attrs: {\n      release: session.release,\n      environment: session.environment,\n      ip_address: session.ipAddress,\n      user_agent: session.userAgent,\n    },\n  });\n}\n\nexport { closeSession, makeSession, updateSession };\n//# sourceMappingURL=session.js.map\n","import { addInstrumentationHandler, logger } from '@sentry/utils';\nimport { getActiveTransaction } from './utils.js';\n\n/**\n * Configures global error listeners\n */\nfunction registerErrorInstrumentation() {\n  addInstrumentationHandler('error', errorCallback);\n  addInstrumentationHandler('unhandledrejection', errorCallback);\n}\n\n/**\n * If an error or unhandled promise occurs, we mark the active transaction as failed\n */\nfunction errorCallback() {\n  var activeTransaction = getActiveTransaction();\n  if (activeTransaction) {\n    var status = 'internal_error';\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] Transaction: ${status} -> Global error occured`);\n    activeTransaction.setStatus(status);\n  }\n}\n\nexport { registerErrorInstrumentation };\n//# sourceMappingURL=errors.js.map\n","import { getMainCarrier } from '@sentry/hub';\nimport { logger, isNaN, dynamicRequire, loadModule, isNodeEnv } from '@sentry/utils';\nimport { registerErrorInstrumentation } from './errors.js';\nimport { IdleTransaction } from './idletransaction.js';\nimport { Transaction } from './transaction.js';\nimport { hasTracingEnabled } from './utils.js';\n\n/** Returns all trace headers that are currently on the top scope. */\nfunction traceHeaders() {\n  var scope = this.getScope();\n  if (scope) {\n    var span = scope.getSpan();\n    if (span) {\n      return {\n        'sentry-trace': span.toTraceparent(),\n      };\n    }\n  }\n  return {};\n}\n\n/**\n * Makes a sampling decision for the given transaction and stores it on the transaction.\n *\n * Called every time a transaction is created. Only transactions which emerge with a `sampled` value of `true` will be\n * sent to Sentry.\n *\n * @param transaction: The transaction needing a sampling decision\n * @param options: The current client's options, so we can access `tracesSampleRate` and/or `tracesSampler`\n * @param samplingContext: Default and user-provided data which may be used to help make the decision\n *\n * @returns The given transaction with its `sampled` value set\n */\nfunction sample(\n  transaction,\n  options,\n  samplingContext,\n) {\n  // nothing to do if tracing is not enabled\n  if (!hasTracingEnabled(options)) {\n    transaction.sampled = false;\n    return transaction;\n  }\n\n  // if the user has forced a sampling decision by passing a `sampled` value in their transaction context, go with that\n  if (transaction.sampled !== undefined) {\n    transaction.setMetadata({\n      transactionSampling: {\n        method: 'explicitly_set',\n        rate: Number(transaction.sampled),\n      },\n    });\n    return transaction;\n  }\n\n  // we would have bailed already if neither `tracesSampler` nor `tracesSampleRate` were defined, so one of these should\n  // work; prefer the hook if so\n  let sampleRate;\n  if (typeof options.tracesSampler === 'function') {\n    sampleRate = options.tracesSampler(samplingContext);\n    transaction.setMetadata({\n      transactionSampling: {\n        method: 'client_sampler',\n        // cast to number in case it's a boolean\n        rate: Number(sampleRate),\n      },\n    });\n  } else if (samplingContext.parentSampled !== undefined) {\n    sampleRate = samplingContext.parentSampled;\n    transaction.setMetadata({\n      transactionSampling: { method: 'inheritance' },\n    });\n  } else {\n    sampleRate = options.tracesSampleRate;\n    transaction.setMetadata({\n      transactionSampling: {\n        method: 'client_rate',\n        // cast to number in case it's a boolean\n        rate: Number(sampleRate),\n      },\n    });\n  }\n\n  // Since this is coming from the user (or from a function provided by the user), who knows what we might get. (The\n  // only valid values are booleans or numbers between 0 and 1.)\n  if (!isValidSampleRate(sampleRate)) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('[Tracing] Discarding transaction because of invalid sample rate.');\n    transaction.sampled = false;\n    return transaction;\n  }\n\n  // if the function returned 0 (or false), or if `tracesSampleRate` is 0, it's a sign the transaction should be dropped\n  if (!sampleRate) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.log(\n        `[Tracing] Discarding transaction because ${\n          typeof options.tracesSampler === 'function'\n            ? 'tracesSampler returned 0 or false'\n            : 'a negative sampling decision was inherited or tracesSampleRate is set to 0'\n        }`,\n      );\n    transaction.sampled = false;\n    return transaction;\n  }\n\n  // Now we roll the dice. Math.random is inclusive of 0, but not of 1, so strict < is safe here. In case sampleRate is\n  // a boolean, the < comparison will cause it to be automatically cast to 1 if it's true and 0 if it's false.\n  transaction.sampled = Math.random() < (sampleRate );\n\n  // if we're not going to keep it, we're done\n  if (!transaction.sampled) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.log(\n        `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(\n          sampleRate,\n        )})`,\n      );\n    return transaction;\n  }\n\n  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] starting ${transaction.op} transaction - ${transaction.name}`);\n  return transaction;\n}\n\n/**\n * Checks the given sample rate to make sure it is valid type and value (a boolean, or a number between 0 and 1).\n */\nfunction isValidSampleRate(rate) {\n  // we need to check NaN explicitly because it's of type 'number' and therefore wouldn't get caught by this typecheck\n    if (isNaN(rate) || !(typeof rate === 'number' || typeof rate === 'boolean')) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.warn(\n        `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(\n          rate,\n        )} of type ${JSON.stringify(typeof rate)}.`,\n      );\n    return false;\n  }\n\n  // in case sampleRate is a boolean, it will get automatically cast to 1 if it's true and 0 if it's false\n  if (rate < 0 || rate > 1) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.warn(`[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got ${rate}.`);\n    return false;\n  }\n  return true;\n}\n\n/**\n * Creates a new transaction and adds a sampling decision if it doesn't yet have one.\n *\n * The Hub.startTransaction method delegates to this method to do its work, passing the Hub instance in as `this`, as if\n * it had been called on the hub directly. Exists as a separate function so that it can be injected into the class as an\n * \"extension method.\"\n *\n * @param this: The Hub starting the transaction\n * @param transactionContext: Data used to configure the transaction\n * @param CustomSamplingContext: Optional data to be provided to the `tracesSampler` function (if any)\n *\n * @returns The new transaction\n *\n * @see {@link Hub.startTransaction}\n */\nfunction _startTransaction(\n  \n  transactionContext,\n  customSamplingContext,\n) {\n  var client = this.getClient();\n  var options = (client && client.getOptions()) || {};\n\n  let transaction = new Transaction(transactionContext, this);\n  transaction = sample(transaction, options, {\n    parentSampled: transactionContext.parentSampled,\n    transactionContext,\n    ...customSamplingContext,\n  });\n  if (transaction.sampled) {\n    transaction.initSpanRecorder(options._experiments && (options._experiments.maxSpans ));\n  }\n  return transaction;\n}\n\n/**\n * Create new idle transaction.\n */\nfunction startIdleTransaction(\n  hub,\n  transactionContext,\n  idleTimeout,\n  finalTimeout,\n  onScope,\n  customSamplingContext,\n) {\n  var client = hub.getClient();\n  var options = (client && client.getOptions()) || {};\n\n  let transaction = new IdleTransaction(transactionContext, hub, idleTimeout, finalTimeout, onScope);\n  transaction = sample(transaction, options, {\n    parentSampled: transactionContext.parentSampled,\n    transactionContext,\n    ...customSamplingContext,\n  });\n  if (transaction.sampled) {\n    transaction.initSpanRecorder(options._experiments && (options._experiments.maxSpans ));\n  }\n  return transaction;\n}\n\n/**\n * @private\n */\nfunction _addTracingExtensions() {\n  var carrier = getMainCarrier();\n  if (!carrier.__SENTRY__) {\n    return;\n  }\n  carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};\n  if (!carrier.__SENTRY__.extensions.startTransaction) {\n    carrier.__SENTRY__.extensions.startTransaction = _startTransaction;\n  }\n  if (!carrier.__SENTRY__.extensions.traceHeaders) {\n    carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;\n  }\n}\n\n/**\n * @private\n */\nfunction _autoloadDatabaseIntegrations() {\n  var carrier = getMainCarrier();\n  if (!carrier.__SENTRY__) {\n    return;\n  }\n\n  var packageToIntegrationMapping = {\n    mongodb() {\n      var integration = dynamicRequire(module, './integrations/node/mongo') \n\n;\n      return new integration.Mongo();\n    },\n    mongoose() {\n      var integration = dynamicRequire(module, './integrations/node/mongo') \n\n;\n      return new integration.Mongo({ mongoose: true });\n    },\n    mysql() {\n      var integration = dynamicRequire(module, './integrations/node/mysql') \n\n;\n      return new integration.Mysql();\n    },\n    pg() {\n      var integration = dynamicRequire(module, './integrations/node/postgres') \n\n;\n      return new integration.Postgres();\n    },\n  };\n\n  var mappedPackages = Object.keys(packageToIntegrationMapping)\n    .filter(moduleName => !!loadModule(moduleName))\n    .map(pkg => {\n      try {\n        return packageToIntegrationMapping[pkg]();\n      } catch (e) {\n        return undefined;\n      }\n    })\n    .filter(p => p) ;\n\n  if (mappedPackages.length > 0) {\n    carrier.__SENTRY__.integrations = [...(carrier.__SENTRY__.integrations || []), ...mappedPackages];\n  }\n}\n\n/**\n * This patches the global object and injects the Tracing extensions methods\n */\nfunction addExtensionMethods() {\n  _addTracingExtensions();\n\n  // Detect and automatically load specified integrations.\n  if (isNodeEnv()) {\n    _autoloadDatabaseIntegrations();\n  }\n\n  // If an error happens globally, we should make sure transaction status is set to error.\n  registerErrorInstrumentation();\n}\n\nexport { _addTracingExtensions, addExtensionMethods, startIdleTransaction };\n//# sourceMappingURL=hubextensions.js.map\n","import { timestampWithMs, logger } from '@sentry/utils';\nimport { SpanRecorder } from './span.js';\nimport { Transaction } from './transaction.js';\n\nvar DEFAULT_IDLE_TIMEOUT = 1000;\nvar DEFAULT_FINAL_TIMEOUT = 30000;\nvar HEARTBEAT_INTERVAL = 5000;\n\n/**\n * @inheritDoc\n */\nclass IdleTransactionSpanRecorder extends SpanRecorder {\n   constructor(\n      _pushActivity,\n      _popActivity,\n     transactionSpanId,\n    maxlen,\n  ) {\n    super(maxlen);this._pushActivity = _pushActivity;this._popActivity = _popActivity;this.transactionSpanId = transactionSpanId;;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   add(span) {\n    // We should make sure we do not push and pop activities for\n    // the transaction that this span recorder belongs to.\n    if (span.spanId !== this.transactionSpanId) {\n      // We patch span.finish() to pop an activity after setting an endTimestamp.\n      span.finish = (endTimestamp) => {\n        span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampWithMs();\n        this._popActivity(span.spanId);\n      };\n\n      // We should only push new activities if the span does not have an end timestamp.\n      if (span.endTimestamp === undefined) {\n        this._pushActivity(span.spanId);\n      }\n    }\n\n    super.add(span);\n  }\n}\n\n/**\n * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.\n * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will\n * put itself on the scope on creation.\n */\nclass IdleTransaction extends Transaction {\n  // Activities store a list of active spans\n   __init() {this.activities = {};}\n\n  // Track state of activities in previous heartbeat\n  \n\n  // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.\n   __init2() {this._heartbeatCounter = 0;}\n\n  // We should not use heartbeat if we finished a transaction\n   __init3() {this._finished = false;}\n\n    __init4() {this._beforeFinishCallbacks = [];}\n\n  /**\n   * Timer that tracks Transaction idleTimeout\n   */\n  \n\n   constructor(\n    transactionContext,\n      _idleHub,\n    /**\n     * The time to wait in ms until the idle transaction will be finished. This timer is started each time\n     * there are no active spans on this transaction.\n     */\n      _idleTimeout = DEFAULT_IDLE_TIMEOUT,\n    /**\n     * The final value in ms that a transaction cannot exceed\n     */\n      _finalTimeout = DEFAULT_FINAL_TIMEOUT,\n    // Whether or not the transaction should put itself on the scope when it starts and pop itself off when it ends\n      _onScope = false,\n  ) {\n    super(transactionContext, _idleHub);this._idleHub = _idleHub;this._idleTimeout = _idleTimeout;this._finalTimeout = _finalTimeout;this._onScope = _onScope;IdleTransaction.prototype.__init.call(this);IdleTransaction.prototype.__init2.call(this);IdleTransaction.prototype.__init3.call(this);IdleTransaction.prototype.__init4.call(this);;\n\n    if (_onScope) {\n      // There should only be one active transaction on the scope\n      clearActiveTransaction(_idleHub);\n\n      // We set the transaction here on the scope so error events pick up the trace\n      // context and attach it to the error.\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`Setting idle transaction on scope. Span ID: ${this.spanId}`);\n      _idleHub.configureScope(scope => scope.setSpan(this));\n    }\n\n    this._startIdleTimeout();\n    setTimeout(() => {\n      if (!this._finished) {\n        this.setStatus('deadline_exceeded');\n        this.finish();\n      }\n    }, this._finalTimeout);\n  }\n\n  /** {@inheritDoc} */\n   finish(endTimestamp = timestampWithMs()) {\n    this._finished = true;\n    this.activities = {};\n\n    if (this.spanRecorder) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);\n\n      for (var callback of this._beforeFinishCallbacks) {\n        callback(this, endTimestamp);\n      }\n\n      this.spanRecorder.spans = this.spanRecorder.spans.filter((span) => {\n        // If we are dealing with the transaction itself, we just return it\n        if (span.spanId === this.spanId) {\n          return true;\n        }\n\n        // We cancel all pending spans with status \"cancelled\" to indicate the idle transaction was finished early\n        if (!span.endTimestamp) {\n          span.endTimestamp = endTimestamp;\n          span.setStatus('cancelled');\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n            logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));\n        }\n\n        var keepSpan = span.startTimestamp < endTimestamp;\n        if (!keepSpan) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n            logger.log(\n              '[Tracing] discarding Span since it happened after Transaction was finished',\n              JSON.stringify(span, undefined, 2),\n            );\n        }\n        return keepSpan;\n      });\n\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] flushing IdleTransaction');\n    } else {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] No active IdleTransaction');\n    }\n\n    // if `this._onScope` is `true`, the transaction put itself on the scope when it started\n    if (this._onScope) {\n      clearActiveTransaction(this._idleHub);\n    }\n\n    return super.finish(endTimestamp);\n  }\n\n  /**\n   * Register a callback function that gets excecuted before the transaction finishes.\n   * Useful for cleanup or if you want to add any additional spans based on current context.\n   *\n   * This is exposed because users have no other way of running something before an idle transaction\n   * finishes.\n   */\n   registerBeforeFinishCallback(callback) {\n    this._beforeFinishCallbacks.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   initSpanRecorder(maxlen) {\n    if (!this.spanRecorder) {\n      var pushActivity = (id) => {\n        if (this._finished) {\n          return;\n        }\n        this._pushActivity(id);\n      };\n      var popActivity = (id) => {\n        if (this._finished) {\n          return;\n        }\n        this._popActivity(id);\n      };\n\n      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);\n\n      // Start heartbeat so that transactions do not run forever.\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('Starting heartbeat');\n      this._pingHeartbeat();\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * Cancels the existing idletimeout, if there is one\n   */\n   _cancelIdleTimeout() {\n    if (this._idleTimeoutID) {\n      clearTimeout(this._idleTimeoutID);\n      this._idleTimeoutID = undefined;\n    }\n  }\n\n  /**\n   * Creates an idletimeout\n   */\n   _startIdleTimeout(endTimestamp) {\n    this._cancelIdleTimeout();\n    this._idleTimeoutID = setTimeout(() => {\n      if (!this._finished && Object.keys(this.activities).length === 0) {\n        this.finish(endTimestamp);\n      }\n    }, this._idleTimeout);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n   _pushActivity(spanId) {\n    this._cancelIdleTimeout();\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] pushActivity: ${spanId}`);\n    this.activities[spanId] = true;\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n   _popActivity(spanId) {\n    if (this.activities[spanId]) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] popActivity ${spanId}`);\n            delete this.activities[spanId];\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n    }\n\n    if (Object.keys(this.activities).length === 0) {\n      // We need to add the timeout here to have the real endtimestamp of the transaction\n      // Remember timestampWithMs is in seconds, timeout is in ms\n      var endTimestamp = timestampWithMs() + this._idleTimeout / 1000;\n      this._startIdleTimeout(endTimestamp);\n    }\n  }\n\n  /**\n   * Checks when entries of this.activities are not changing for 3 beats.\n   * If this occurs we finish the transaction.\n   */\n   _beat() {\n    // We should not be running heartbeat if the idle transaction is finished.\n    if (this._finished) {\n      return;\n    }\n\n    var heartbeatString = Object.keys(this.activities).join('');\n\n    if (heartbeatString === this._prevHeartbeatString) {\n      this._heartbeatCounter += 1;\n    } else {\n      this._heartbeatCounter = 1;\n    }\n\n    this._prevHeartbeatString = heartbeatString;\n\n    if (this._heartbeatCounter >= 3) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] Transaction finished because of no change for 3 heart beats');\n      this.setStatus('deadline_exceeded');\n      this.finish();\n    } else {\n      this._pingHeartbeat();\n    }\n  }\n\n  /**\n   * Pings the heartbeat\n   */\n   _pingHeartbeat() {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);\n    setTimeout(() => {\n      this._beat();\n    }, HEARTBEAT_INTERVAL);\n  }\n}\n\n/**\n * Reset transaction on scope to `undefined`\n */\nfunction clearActiveTransaction(hub) {\n  var scope = hub.getScope();\n  if (scope) {\n    var transaction = scope.getTransaction();\n    if (transaction) {\n      scope.setSpan(undefined);\n    }\n  }\n}\n\nexport { DEFAULT_FINAL_TIMEOUT, DEFAULT_IDLE_TIMEOUT, HEARTBEAT_INTERVAL, IdleTransaction, IdleTransactionSpanRecorder };\n//# sourceMappingURL=idletransaction.js.map\n","import { _nullishCoalesce } from '@sentry/utils/esm/buildPolyfills';\nimport { uuid4, timestampWithMs, logger, dropUndefinedKeys } from '@sentry/utils';\n\n/**\n * Keeps track of finished spans for a given transaction\n * @internal\n * @hideconstructor\n * @hidden\n */\nclass SpanRecorder {\n   __init() {this.spans = [];}\n\n   constructor(maxlen = 1000) {;SpanRecorder.prototype.__init.call(this);\n    this._maxlen = maxlen;\n  }\n\n  /**\n   * This is just so that we don't run out of memory while recording a lot\n   * of spans. At some point we just stop and flush out the start of the\n   * trace tree (i.e.the first n spans with the smallest\n   * start_timestamp).\n   */\n   add(span) {\n    if (this.spans.length > this._maxlen) {\n      span.spanRecorder = undefined;\n    } else {\n      this.spans.push(span);\n    }\n  }\n}\n\n/**\n * Span contains all data about a span\n */\nclass Span  {\n  /**\n   * @inheritDoc\n   */\n   __init2() {this.traceId = uuid4();}\n\n  /**\n   * @inheritDoc\n   */\n   __init3() {this.spanId = uuid4().substring(16);}\n\n  /**\n   * @inheritDoc\n   */\n  \n\n  /**\n   * Internal keeper of the status\n   */\n  \n\n  /**\n   * @inheritDoc\n   */\n  \n\n  /**\n   * Timestamp in seconds when the span was created.\n   */\n   __init4() {this.startTimestamp = timestampWithMs();}\n\n  /**\n   * Timestamp in seconds when the span ended.\n   */\n  \n\n  /**\n   * @inheritDoc\n   */\n  \n\n  /**\n   * @inheritDoc\n   */\n  \n\n  /**\n   * @inheritDoc\n   */\n   __init5() {this.tags = {};}\n\n  /**\n   * @inheritDoc\n   */\n     __init6() {this.data = {};}\n\n  /**\n   * List of spans that were finalized\n   */\n  \n\n  /**\n   * @inheritDoc\n   */\n  \n\n  /**\n   * You should never call the constructor manually, always use `Sentry.startTransaction()`\n   * or call `startChild()` on an existing span.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n   constructor(spanContext) {;Span.prototype.__init2.call(this);Span.prototype.__init3.call(this);Span.prototype.__init4.call(this);Span.prototype.__init5.call(this);Span.prototype.__init6.call(this);\n    if (!spanContext) {\n      return this;\n    }\n    if (spanContext.traceId) {\n      this.traceId = spanContext.traceId;\n    }\n    if (spanContext.spanId) {\n      this.spanId = spanContext.spanId;\n    }\n    if (spanContext.parentSpanId) {\n      this.parentSpanId = spanContext.parentSpanId;\n    }\n    // We want to include booleans as well here\n    if ('sampled' in spanContext) {\n      this.sampled = spanContext.sampled;\n    }\n    if (spanContext.op) {\n      this.op = spanContext.op;\n    }\n    if (spanContext.description) {\n      this.description = spanContext.description;\n    }\n    if (spanContext.data) {\n      this.data = spanContext.data;\n    }\n    if (spanContext.tags) {\n      this.tags = spanContext.tags;\n    }\n    if (spanContext.status) {\n      this.status = spanContext.status;\n    }\n    if (spanContext.startTimestamp) {\n      this.startTimestamp = spanContext.startTimestamp;\n    }\n    if (spanContext.endTimestamp) {\n      this.endTimestamp = spanContext.endTimestamp;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   startChild(\n    spanContext,\n  ) {\n    var childSpan = new Span({\n      ...spanContext,\n      parentSpanId: this.spanId,\n      sampled: this.sampled,\n      traceId: this.traceId,\n    });\n\n    childSpan.spanRecorder = this.spanRecorder;\n    if (childSpan.spanRecorder) {\n      childSpan.spanRecorder.add(childSpan);\n    }\n\n    childSpan.transaction = this.transaction;\n\n    if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && childSpan.transaction) {\n      var opStr = (spanContext && spanContext.op) || '< unknown op >';\n      var nameStr = childSpan.transaction.name || '< unknown name >';\n      var idStr = childSpan.transaction.spanId;\n\n      var logMessage = `[Tracing] Starting '${opStr}' span on transaction '${nameStr}' (${idStr}).`;\n      childSpan.transaction.metadata.spanMetadata[childSpan.spanId] = { logMessage };\n      logger.log(logMessage);\n    }\n\n    return childSpan;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTag(key, value) {\n    this.tags = { ...this.tags, [key]: value };\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n     setData(key, value) {\n    this.data = { ...this.data, [key]: value };\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setStatus(value) {\n    this.status = value;\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setHttpStatus(httpStatus) {\n    this.setTag('http.status_code', String(httpStatus));\n    var spanStatus = spanStatusfromHttpCode(httpStatus);\n    if (spanStatus !== 'unknown_error') {\n      this.setStatus(spanStatus);\n    }\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   isSuccess() {\n    return this.status === 'ok';\n  }\n\n  /**\n   * @inheritDoc\n   */\n   finish(endTimestamp) {\n    if (\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      // Don't call this for transactions\n      this.transaction &&\n      this.transaction.spanId !== this.spanId\n    ) {\n      const { logMessage } = this.transaction.metadata.spanMetadata[this.spanId];\n      if (logMessage) {\n        logger.log((logMessage ).replace('Starting', 'Finishing'));\n      }\n    }\n\n    this.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampWithMs();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   toTraceparent() {\n    let sampledString = '';\n    if (this.sampled !== undefined) {\n      sampledString = this.sampled ? '-1' : '-0';\n    }\n    return `${this.traceId}-${this.spanId}${sampledString}`;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   toContext() {\n    return dropUndefinedKeys({\n      data: this.data,\n      description: this.description,\n      endTimestamp: this.endTimestamp,\n      op: this.op,\n      parentSpanId: this.parentSpanId,\n      sampled: this.sampled,\n      spanId: this.spanId,\n      startTimestamp: this.startTimestamp,\n      status: this.status,\n      tags: this.tags,\n      traceId: this.traceId,\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n   updateWithContext(spanContext) {\n    this.data = _nullishCoalesce(spanContext.data, () => ( {}));\n    this.description = spanContext.description;\n    this.endTimestamp = spanContext.endTimestamp;\n    this.op = spanContext.op;\n    this.parentSpanId = spanContext.parentSpanId;\n    this.sampled = spanContext.sampled;\n    this.spanId = _nullishCoalesce(spanContext.spanId, () => ( this.spanId));\n    this.startTimestamp = _nullishCoalesce(spanContext.startTimestamp, () => ( this.startTimestamp));\n    this.status = spanContext.status;\n    this.tags = _nullishCoalesce(spanContext.tags, () => ( {}));\n    this.traceId = _nullishCoalesce(spanContext.traceId, () => ( this.traceId));\n\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getTraceContext()\n\n {\n    return dropUndefinedKeys({\n      data: Object.keys(this.data).length > 0 ? this.data : undefined,\n      description: this.description,\n      op: this.op,\n      parent_span_id: this.parentSpanId,\n      span_id: this.spanId,\n      status: this.status,\n      tags: Object.keys(this.tags).length > 0 ? this.tags : undefined,\n      trace_id: this.traceId,\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n   toJSON()\n\n {\n    return dropUndefinedKeys({\n      data: Object.keys(this.data).length > 0 ? this.data : undefined,\n      description: this.description,\n      op: this.op,\n      parent_span_id: this.parentSpanId,\n      span_id: this.spanId,\n      start_timestamp: this.startTimestamp,\n      status: this.status,\n      tags: Object.keys(this.tags).length > 0 ? this.tags : undefined,\n      timestamp: this.endTimestamp,\n      trace_id: this.traceId,\n    });\n  }\n}\n\n/**\n * Converts a HTTP status code into a {@link SpanStatusType}.\n *\n * @param httpStatus The HTTP response status code.\n * @returns The span status or unknown_error.\n */\nfunction spanStatusfromHttpCode(httpStatus) {\n  if (httpStatus < 400 && httpStatus >= 100) {\n    return 'ok';\n  }\n\n  if (httpStatus >= 400 && httpStatus < 500) {\n    switch (httpStatus) {\n      case 401:\n        return 'unauthenticated';\n      case 403:\n        return 'permission_denied';\n      case 404:\n        return 'not_found';\n      case 409:\n        return 'already_exists';\n      case 413:\n        return 'failed_precondition';\n      case 429:\n        return 'resource_exhausted';\n      default:\n        return 'invalid_argument';\n    }\n  }\n\n  if (httpStatus >= 500 && httpStatus < 600) {\n    switch (httpStatus) {\n      case 501:\n        return 'unimplemented';\n      case 503:\n        return 'unavailable';\n      case 504:\n        return 'deadline_exceeded';\n      default:\n        return 'internal_error';\n    }\n  }\n\n  return 'unknown_error';\n}\n\nexport { Span, SpanRecorder, spanStatusfromHttpCode };\n//# sourceMappingURL=span.js.map\n","import { _nullishCoalesce } from '@sentry/utils/esm/buildPolyfills';\nimport { getCurrentHub } from '@sentry/hub';\nimport { timestampInSeconds, logger, dropUndefinedKeys } from '@sentry/utils';\nimport { Span, SpanRecorder } from './span.js';\n\n/** JSDoc */\nclass Transaction extends Span  {\n  \n\n  /**\n   * The reference to the current hub.\n   */\n  \n\n   __init() {this._measurements = {};}\n\n   __init2() {this._frozenDynamicSamplingContext = undefined;}\n\n  /**\n   * This constructor should never be called manually. Those instrumenting tracing should use\n   * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n   constructor(transactionContext, hub) {\n    super(transactionContext);Transaction.prototype.__init.call(this);Transaction.prototype.__init2.call(this);;\n\n    this._hub = hub || getCurrentHub();\n\n    this._name = transactionContext.name || '';\n\n    this.metadata = {\n      source: 'custom',\n      ...transactionContext.metadata,\n      spanMetadata: {},\n      changes: [],\n      propagations: 0,\n    };\n\n    this._trimEnd = transactionContext.trimEnd;\n\n    // this is because transactions are also spans, and spans have a transaction pointer\n    this.transaction = this;\n\n    // If Dynamic Sampling Context is provided during the creation of the transaction, we freeze it as it usually means\n    // there is incoming Dynamic Sampling Context. (Either through an incoming request, a baggage meta-tag, or other means)\n    var incomingDynamicSamplingContext = this.metadata.dynamicSamplingContext;\n    if (incomingDynamicSamplingContext) {\n      // We shallow copy this in case anything writes to the original reference of the passed in `dynamicSamplingContext`\n      this._frozenDynamicSamplingContext = { ...incomingDynamicSamplingContext };\n    }\n  }\n\n  /** Getter for `name` property */\n   get name() {\n    return this._name;\n  }\n\n  /** Setter for `name` property, which also sets `source` as custom */\n   set name(newName) {\n    this.setName(newName);\n  }\n\n  /**\n   * JSDoc\n   */\n   setName(name, source = 'custom') {\n    // `source` could change without the name changing if we discover that an unparameterized route is actually\n    // parameterized by virtue of having no parameters in its path\n    if (name !== this.name || source !== this.metadata.source) {\n      this.metadata.changes.push({\n        // log previous source\n        source: this.metadata.source,\n        timestamp: timestampInSeconds(),\n        propagations: this.metadata.propagations,\n      });\n    }\n\n    this._name = name;\n    this.metadata.source = source;\n  }\n\n  /**\n   * Attaches SpanRecorder to the span itself\n   * @param maxlen maximum number of spans that can be recorded\n   */\n   initSpanRecorder(maxlen = 1000) {\n    if (!this.spanRecorder) {\n      this.spanRecorder = new SpanRecorder(maxlen);\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setMeasurement(name, value, unit = '') {\n    this._measurements[name] = { value, unit };\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setMetadata(newMetadata) {\n    this.metadata = { ...this.metadata, ...newMetadata };\n  }\n\n  /**\n   * @inheritDoc\n   */\n   finish(endTimestamp) {\n    // This transaction is already finished, so we should not flush it again.\n    if (this.endTimestamp !== undefined) {\n      return undefined;\n    }\n\n    if (!this.name) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');\n      this.name = '<unlabeled transaction>';\n    }\n\n    // just sets the end timestamp\n    super.finish(endTimestamp);\n\n    if (this.sampled !== true) {\n      // At this point if `sampled !== true` we want to discard the transaction.\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] Discarding transaction because its trace was not chosen to be sampled.');\n\n      var client = this._hub.getClient();\n      if (client) {\n        client.recordDroppedEvent('sample_rate', 'transaction');\n      }\n\n      return undefined;\n    }\n\n    var finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(s => s !== this && s.endTimestamp) : [];\n\n    if (this._trimEnd && finishedSpans.length > 0) {\n      this.endTimestamp = finishedSpans.reduce((prev, current) => {\n        if (prev.endTimestamp && current.endTimestamp) {\n          return prev.endTimestamp > current.endTimestamp ? prev : current;\n        }\n        return prev;\n      }).endTimestamp;\n    }\n\n    var metadata = this.metadata;\n\n    var transaction = {\n      contexts: {\n        trace: this.getTraceContext(),\n      },\n      spans: finishedSpans,\n      start_timestamp: this.startTimestamp,\n      tags: this.tags,\n      timestamp: this.endTimestamp,\n      transaction: this.name,\n      type: 'transaction',\n      sdkProcessingMetadata: {\n        ...metadata,\n        dynamicSamplingContext: this.getDynamicSamplingContext(),\n      },\n      ...(metadata.source && {\n        transaction_info: {\n          source: metadata.source,\n          changes: metadata.changes,\n          propagations: metadata.propagations,\n        },\n      }),\n    };\n\n    var hasMeasurements = Object.keys(this._measurements).length > 0;\n\n    if (hasMeasurements) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        logger.log(\n          '[Measurements] Adding measurements to transaction',\n          JSON.stringify(this._measurements, undefined, 2),\n        );\n      transaction.measurements = this._measurements;\n    }\n\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] Finishing ${this.op} transaction: ${this.name}.`);\n\n    return this._hub.captureEvent(transaction);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   toContext() {\n    var spanContext = super.toContext();\n\n    return dropUndefinedKeys({\n      ...spanContext,\n      name: this.name,\n      trimEnd: this._trimEnd,\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n   updateWithContext(transactionContext) {\n    super.updateWithContext(transactionContext);\n\n    this.name = _nullishCoalesce(transactionContext.name, () => ( ''));\n\n    this._trimEnd = transactionContext.trimEnd;\n\n    return this;\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @experimental\n   */\n   getDynamicSamplingContext() {\n    if (this._frozenDynamicSamplingContext) {\n      return this._frozenDynamicSamplingContext;\n    }\n\n    var hub = this._hub || getCurrentHub();\n    var client = hub && hub.getClient();\n\n    if (!client) return {};\n\n    const { environment, release } = client.getOptions() || {};\n    const { publicKey: public_key } = client.getDsn() || {};\n\n    var maybeSampleRate = (this.metadata.transactionSampling || {}).rate;\n    var sample_rate = maybeSampleRate !== undefined ? maybeSampleRate.toString() : undefined;\n\n    var scope = hub.getScope();\n    const { segment: user_segment } = (scope && scope.getUser()) || {};\n\n    var source = this.metadata.source;\n\n    // We don't want to have a transaction name in the DSC if the source is \"url\" because URLs might contain PII\n    var transaction = source && source !== 'url' ? this.name : undefined;\n\n    var dsc = dropUndefinedKeys({\n      environment,\n      release,\n      transaction,\n      user_segment,\n      public_key,\n      trace_id: this.traceId,\n      sample_rate,\n    });\n\n    // Uncomment if we want to make DSC immutable\n    // this._frozenDynamicSamplingContext = dsc;\n\n    return dsc;\n  }\n}\n\nexport { Transaction };\n//# sourceMappingURL=transaction.js.map\n","import { getCurrentHub } from '@sentry/hub';\nexport { TRACEPARENT_REGEXP, extractTraceparentData, stripUrlQueryAndFragment } from '@sentry/utils';\n\n/**\n * Determines if tracing is currently enabled.\n *\n * Tracing is enabled when at least one of `tracesSampleRate` and `tracesSampler` is defined in the SDK config.\n */\nfunction hasTracingEnabled(\n  maybeOptions,\n) {\n  var client = getCurrentHub().getClient();\n  var options = maybeOptions || (client && client.getOptions());\n  return !!options && ('tracesSampleRate' in options || 'tracesSampler' in options);\n}\n\n/** Grabs active transaction off scope, if any */\nfunction getActiveTransaction(maybeHub) {\n  var hub = maybeHub || getCurrentHub();\n  var scope = hub.getScope();\n  return scope && (scope.getTransaction() );\n}\n\n/**\n * Converts from milliseconds to seconds\n * @param time time in ms\n */\nfunction msToSec(time) {\n  return time / 1000;\n}\n\n/**\n * Converts from seconds to milliseconds\n * @param time time in seconds\n */\nfunction secToMs(time) {\n  return time * 1000;\n}\n\nexport { getActiveTransaction, hasTracingEnabled, msToSec, secToMs };\n//# sourceMappingURL=utils.js.map\n","import { getGlobalObject } from './global.js';\nimport { isString } from './is.js';\n\n/**\n * Given a child DOM element, returns a query-selector statement describing that\n * and its ancestors\n * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]\n * @returns generated DOM path\n */\nfunction htmlTreeAsString(elem, keyAttrs) {\n  \n\n  // try/catch both:\n  // - accessing event.target (see getsentry/raven-js#838, #768)\n  // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly\n  // - can throw an exception in some circumstances.\n  try {\n    let currentElem = elem ;\n    var MAX_TRAVERSE_HEIGHT = 5;\n    var MAX_OUTPUT_LEN = 80;\n    var out = [];\n    let height = 0;\n    let len = 0;\n    var separator = ' > ';\n    var sepLength = separator.length;\n    let nextStr;\n\n        while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {\n      nextStr = _htmlElementAsString(currentElem, keyAttrs);\n      // bail out if\n      // - nextStr is the 'html' element\n      // - the length of the string that would be created exceeds MAX_OUTPUT_LEN\n      //   (ignore this limit if we are on the first iteration)\n      if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)) {\n        break;\n      }\n\n      out.push(nextStr);\n\n      len += nextStr.length;\n      currentElem = currentElem.parentNode;\n    }\n\n    return out.reverse().join(separator);\n  } catch (_oO) {\n    return '<unknown>';\n  }\n}\n\n/**\n * Returns a simple, query-selector representation of a DOM element\n * e.g. [HTMLElement] => input#foo.btn[name=baz]\n * @returns generated DOM path\n */\nfunction _htmlElementAsString(el, keyAttrs) {\n  var elem = el \n\n;\n\n  var out = [];\n  let className;\n  let classes;\n  let key;\n  let attr;\n  let i;\n\n  if (!elem || !elem.tagName) {\n    return '';\n  }\n\n  out.push(elem.tagName.toLowerCase());\n\n  // Pairs of attribute keys defined in `serializeAttribute` and their values on element.\n  var keyAttrPairs =\n    keyAttrs && keyAttrs.length\n      ? keyAttrs.filter(keyAttr => elem.getAttribute(keyAttr)).map(keyAttr => [keyAttr, elem.getAttribute(keyAttr)])\n      : null;\n\n  if (keyAttrPairs && keyAttrPairs.length) {\n    keyAttrPairs.forEach(keyAttrPair => {\n      out.push(`[${keyAttrPair[0]}=\"${keyAttrPair[1]}\"]`);\n    });\n  } else {\n    if (elem.id) {\n      out.push(`#${elem.id}`);\n    }\n\n        className = elem.className;\n    if (className && isString(className)) {\n      classes = className.split(/\\s+/);\n      for (i = 0; i < classes.length; i++) {\n        out.push(`.${classes[i]}`);\n      }\n    }\n  }\n  var allowedAttrs = ['type', 'name', 'title', 'alt'];\n  for (i = 0; i < allowedAttrs.length; i++) {\n    key = allowedAttrs[i];\n    attr = elem.getAttribute(key);\n    if (attr) {\n      out.push(`[${key}=\"${attr}\"]`);\n    }\n  }\n  return out.join('');\n}\n\n/**\n * A safe form of location.href\n */\nfunction getLocationHref() {\n  var global = getGlobalObject();\n  try {\n    return global.document.location.href;\n  } catch (oO) {\n    return '';\n  }\n}\n\n/**\n * Gets a DOM element by using document.querySelector.\n *\n * This wrapper will first check for the existance of the function before\n * actually calling it so that we don't have to take care of this check,\n * every time we want to access the DOM.\n *\n * Reason: DOM/querySelector is not available in all environments.\n *\n * We have to cast to any because utils can be consumed by a variety of environments,\n * and we don't want to break TS users. If you know what element will be selected by\n * `document.querySelector`, specify it as part of the generic call. For example,\n * `var element = getDomElement<Element>('selector');`\n *\n * @param selector the selector string passed on to document.querySelector\n */\nfunction getDomElement(selector) {\n  var global = getGlobalObject();\n  if (global.document && global.document.querySelector) {\n    return global.document.querySelector(selector) ;\n  }\n  return null;\n}\n\nexport { getDomElement, getLocationHref, htmlTreeAsString };\n//# sourceMappingURL=browser.js.map\n","/**\n * Polyfill for the nullish coalescing operator (`??`).\n *\n * Note that the RHS is wrapped in a function so that if it's a computed value, that evaluation won't happen unless the\n * LHS evaluates to a nullish value, to mimic the operator's short-circuiting behavior.\n *\n * Adapted from Sucrase (https://github.com/alangpierce/sucrase)\n *\n * @param lhs The value of the expression to the left of the `??`\n * @param rhsFn A function returning the value of the expression to the right of the `??`\n * @returns The LHS value, unless it's `null` or `undefined`, in which case, the RHS value\n */\nfunction _nullishCoalesce(lhs, rhsFn) {\n  // by checking for loose equality to `null`, we catch both `null` and `undefined`\n  return lhs != null ? lhs : rhsFn();\n}\n\n// Sucrase version:\n// function _nullishCoalesce(lhs, rhsFn) {\n//   if (lhs != null) {\n//     return lhs;\n//   } else {\n//     return rhsFn();\n//   }\n// }\n\nexport { _nullishCoalesce };\n//# sourceMappingURL=_nullishCoalesce.js.map\n","/**\n * Polyfill for the optional chain operator, `?.`, given previous conversion of the expression into an array of values,\n * descriptors, and functions.\n *\n * Adapted from Sucrase (https://github.com/alangpierce/sucrase)\n * See https://github.com/alangpierce/sucrase/blob/265887868966917f3b924ce38dfad01fbab1329f/src/transformers/OptionalChainingNullishTransformer.ts#L15\n *\n * @param ops Array result of expression conversion\n * @returns The value of the expression\n */\nfunction _optionalChain(ops) {\n  let lastAccessLHS = undefined;\n  let value = ops[0];\n  let i = 1;\n  while (i < ops.length) {\n    var op = ops[i] ;\n    var fn = ops[i + 1] ;\n    i += 2;\n    // by checking for loose equality to `null`, we catch both `null` and `undefined`\n    if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n      // really we're meaning to return `undefined` as an actual value here, but it saves bytes not to write it\n      return;\n    }\n    if (op === 'access' || op === 'optionalAccess') {\n      lastAccessLHS = value;\n      value = fn(value);\n    } else if (op === 'call' || op === 'optionalCall') {\n      value = fn((...args) => (value ).call(lastAccessLHS, ...args));\n      lastAccessLHS = undefined;\n    }\n  }\n  return value;\n}\n\n// Sucrase version\n// function _optionalChain(ops) {\n//   let lastAccessLHS = undefined;\n//   let value = ops[0];\n//   let i = 1;\n//   while (i < ops.length) {\n//     var op = ops[i];\n//     var fn = ops[i + 1];\n//     i += 2;\n//     if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n//       return undefined;\n//     }\n//     if (op === 'access' || op === 'optionalAccess') {\n//       lastAccessLHS = value;\n//       value = fn(value);\n//     } else if (op === 'call' || op === 'optionalCall') {\n//       value = fn((...args) => value.call(lastAccessLHS, ...args));\n//       lastAccessLHS = undefined;\n//     }\n//   }\n//   return value;\n// }\n\nexport { _optionalChain };\n//# sourceMappingURL=_optionalChain.js.map\n","import { isNodeEnv } from './node.js';\n\n/** Internal */\n\nvar fallbackGlobalObject = {};\n\n/**\n * Safely get global scope object\n *\n * @returns Global scope object\n */\nfunction getGlobalObject() {\n  return (\n    isNodeEnv()\n      ? global\n      : typeof window !== 'undefined'       ? window       : typeof self !== 'undefined'\n      ? self\n      : fallbackGlobalObject\n  ) ;\n}\n\n/**\n * Returns a global singleton contained in the global `__SENTRY__` object.\n *\n * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory\n * function and added to the `__SENTRY__` object.\n *\n * @param name name of the global singleton on __SENTRY__\n * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`\n * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `getGlobalObject`'s return value\n * @returns the singleton\n */\nfunction getGlobalSingleton(name, creator, obj) {\n  var global = (obj || getGlobalObject()) ;\n  var __SENTRY__ = (global.__SENTRY__ = global.__SENTRY__ || {});\n  var singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());\n  return singleton;\n}\n\nexport { getGlobalObject, getGlobalSingleton };\n//# sourceMappingURL=global.js.map\n","import { getGlobalObject } from './global.js';\nimport { isInstanceOf, isString } from './is.js';\nimport { logger, CONSOLE_LEVELS } from './logger.js';\nimport { fill } from './object.js';\nimport { getFunctionName } from './stacktrace.js';\nimport { supportsNativeFetch, supportsHistory } from './supports.js';\n\nvar global = getGlobalObject();\n\n/**\n * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.\n *  - Console API\n *  - Fetch API\n *  - XHR API\n *  - History API\n *  - DOM API (click/typing)\n *  - Error API\n *  - UnhandledRejection API\n */\n\nvar handlers = {};\nvar instrumented = {};\n\n/** Instruments given API */\nfunction instrument(type) {\n  if (instrumented[type]) {\n    return;\n  }\n\n  instrumented[type] = true;\n\n  switch (type) {\n    case 'console':\n      instrumentConsole();\n      break;\n    case 'dom':\n      instrumentDOM();\n      break;\n    case 'xhr':\n      instrumentXHR();\n      break;\n    case 'fetch':\n      instrumentFetch();\n      break;\n    case 'history':\n      instrumentHistory();\n      break;\n    case 'error':\n      instrumentError();\n      break;\n    case 'unhandledrejection':\n      instrumentUnhandledRejection();\n      break;\n    default:\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('unknown instrumentation type:', type);\n      return;\n  }\n}\n\n/**\n * Add handler that will be called when given type of instrumentation triggers.\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addInstrumentationHandler(type, callback) {\n  handlers[type] = handlers[type] || [];\n  (handlers[type] ).push(callback);\n  instrument(type);\n}\n\n/** JSDoc */\nfunction triggerHandlers(type, data) {\n  if (!type || !handlers[type]) {\n    return;\n  }\n\n  for (var handler of handlers[type] || []) {\n    try {\n      handler(data);\n    } catch (e) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        logger.error(\n          `Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(handler)}\\nError:`,\n          e,\n        );\n    }\n  }\n}\n\n/** JSDoc */\nfunction instrumentConsole() {\n  if (!('console' in global)) {\n    return;\n  }\n\n  CONSOLE_LEVELS.forEach(function (level) {\n    if (!(level in global.console)) {\n      return;\n    }\n\n    fill(global.console, level, function (originalConsoleMethod) {\n      return function (...args) {\n        triggerHandlers('console', { args, level });\n\n        // this fails for some browsers. :(\n        if (originalConsoleMethod) {\n          originalConsoleMethod.apply(global.console, args);\n        }\n      };\n    });\n  });\n}\n\n/** JSDoc */\nfunction instrumentFetch() {\n  if (!supportsNativeFetch()) {\n    return;\n  }\n\n  fill(global, 'fetch', function (originalFetch) {\n    return function (...args) {\n      var handlerData = {\n        args,\n        fetchData: {\n          method: getFetchMethod(args),\n          url: getFetchUrl(args),\n        },\n        startTimestamp: Date.now(),\n      };\n\n      triggerHandlers('fetch', {\n        ...handlerData,\n      });\n\n            return originalFetch.apply(global, args).then(\n        (response) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            response,\n          });\n          return response;\n        },\n        (error) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            error,\n          });\n          // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n          //       it means the sentry.javascript SDK caught an error invoking your application code.\n          //       This is expected behavior and NOT indicative of a bug with sentry.javascript.\n          throw error;\n        },\n      );\n    };\n  });\n}\n\n/** Extract `method` from fetch call arguments */\nfunction getFetchMethod(fetchArgs = []) {\n  if ('Request' in global && isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {\n    return String(fetchArgs[0].method).toUpperCase();\n  }\n  if (fetchArgs[1] && fetchArgs[1].method) {\n    return String(fetchArgs[1].method).toUpperCase();\n  }\n  return 'GET';\n}\n\n/** Extract `url` from fetch call arguments */\nfunction getFetchUrl(fetchArgs = []) {\n  if (typeof fetchArgs[0] === 'string') {\n    return fetchArgs[0];\n  }\n  if ('Request' in global && isInstanceOf(fetchArgs[0], Request)) {\n    return fetchArgs[0].url;\n  }\n  return String(fetchArgs[0]);\n}\n\n/** JSDoc */\nfunction instrumentXHR() {\n  if (!('XMLHttpRequest' in global)) {\n    return;\n  }\n\n  var xhrproto = XMLHttpRequest.prototype;\n\n  fill(xhrproto, 'open', function (originalOpen) {\n    return function ( ...args) {\n            var xhr = this;\n      var url = args[1];\n      var xhrInfo = (xhr.__sentry_xhr__ = {\n                method: isString(args[0]) ? args[0].toUpperCase() : args[0],\n        url: args[1],\n      });\n\n      // if Sentry key appears in URL, don't capture it as a request\n            if (isString(url) && xhrInfo.method === 'POST' && url.match(/sentry_key/)) {\n        xhr.__sentry_own_request__ = true;\n      }\n\n      var onreadystatechangeHandler = function () {\n        if (xhr.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            xhrInfo.status_code = xhr.status;\n          } catch (e) {\n            /* do nothing */\n          }\n\n          triggerHandlers('xhr', {\n            args,\n            endTimestamp: Date.now(),\n            startTimestamp: Date.now(),\n            xhr,\n          });\n        }\n      };\n\n      if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {\n        fill(xhr, 'onreadystatechange', function (original) {\n          return function (...readyStateArgs) {\n            onreadystatechangeHandler();\n            return original.apply(xhr, readyStateArgs);\n          };\n        });\n      } else {\n        xhr.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      return originalOpen.apply(xhr, args);\n    };\n  });\n\n  fill(xhrproto, 'send', function (originalSend) {\n    return function ( ...args) {\n      if (this.__sentry_xhr__ && args[0] !== undefined) {\n        this.__sentry_xhr__.body = args[0];\n      }\n\n      triggerHandlers('xhr', {\n        args,\n        startTimestamp: Date.now(),\n        xhr: this,\n      });\n\n      return originalSend.apply(this, args);\n    };\n  });\n}\n\nlet lastHref;\n\n/** JSDoc */\nfunction instrumentHistory() {\n  if (!supportsHistory()) {\n    return;\n  }\n\n  var oldOnPopState = global.onpopstate;\n  global.onpopstate = function ( ...args) {\n    var to = global.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    var from = lastHref;\n    lastHref = to;\n    triggerHandlers('history', {\n      from,\n      to,\n    });\n    if (oldOnPopState) {\n      // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.\n      // https://github.com/getsentry/sentry-javascript/issues/3344\n      // https://github.com/bugsnag/bugsnag-js/issues/469\n      try {\n        return oldOnPopState.apply(this, args);\n      } catch (_oO) {\n        // no-empty\n      }\n    }\n  };\n\n  /** @hidden */\n  function historyReplacementFunction(originalHistoryFunction) {\n    return function ( ...args) {\n      var url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        var from = lastHref;\n        var to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        triggerHandlers('history', {\n          from,\n          to,\n        });\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n\n  fill(global.history, 'pushState', historyReplacementFunction);\n  fill(global.history, 'replaceState', historyReplacementFunction);\n}\n\nvar debounceDuration = 1000;\nlet debounceTimerID;\nlet lastCapturedEvent;\n\n/**\n * Decide whether the current event should finish the debounce of previously captured one.\n * @param previous previously captured event\n * @param current event to be captured\n */\nfunction shouldShortcircuitPreviousDebounce(previous, current) {\n  // If there was no previous event, it should always be swapped for the new one.\n  if (!previous) {\n    return true;\n  }\n\n  // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.\n  if (previous.type !== current.type) {\n    return true;\n  }\n\n  try {\n    // If both events have the same type, it's still possible that actions were performed on different targets.\n    // e.g. 2 clicks on different buttons.\n    if (previous.target !== current.target) {\n      return true;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_\n  // to which an event listener was attached), we treat them as the same action, as we want to capture\n  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.\n  return false;\n}\n\n/**\n * Decide whether an event should be captured.\n * @param event event to be captured\n */\nfunction shouldSkipDOMEvent(event) {\n  // We are only interested in filtering `keypress` events for now.\n  if (event.type !== 'keypress') {\n    return false;\n  }\n\n  try {\n    var target = event.target ;\n\n    if (!target || !target.tagName) {\n      return true;\n    }\n\n    // Only consider keypress events on actual input elements. This will disregard keypresses targeting body\n    // e.g.tabbing through elements, hotkeys, etc.\n    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n      return false;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  return true;\n}\n\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n * @param handler function that will be triggered\n * @param globalListener indicates whether event was captured by the global event listener\n * @returns wrapped breadcrumb events handler\n * @hidden\n */\nfunction makeDOMEventHandler(handler, globalListener = false) {\n  return (event) => {\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors).\n    // Ignore if we've already captured that event.\n    if (!event || lastCapturedEvent === event) {\n      return;\n    }\n\n    // We always want to skip _some_ events.\n    if (shouldSkipDOMEvent(event)) {\n      return;\n    }\n\n    var name = event.type === 'keypress' ? 'input' : event.type;\n\n    // If there is no debounce timer, it means that we can safely capture the new event and store it for future comparisons.\n    if (debounceTimerID === undefined) {\n      handler({\n        event: event,\n        name,\n        global: globalListener,\n      });\n      lastCapturedEvent = event;\n    }\n    // If there is a debounce awaiting, see if the new event is different enough to treat it as a unique one.\n    // If that's the case, emit the previous event and store locally the newly-captured DOM event.\n    else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {\n      handler({\n        event: event,\n        name,\n        global: globalListener,\n      });\n      lastCapturedEvent = event;\n    }\n\n    // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.\n    clearTimeout(debounceTimerID);\n    debounceTimerID = global.setTimeout(() => {\n      debounceTimerID = undefined;\n    }, debounceDuration);\n  };\n}\n\n/** JSDoc */\nfunction instrumentDOM() {\n  if (!('document' in global)) {\n    return;\n  }\n\n  // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom\n  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before\n  // we instrument `addEventListener` so that we don't end up attaching this handler twice.\n  var triggerDOMHandler = triggerHandlers.bind(null, 'dom');\n  var globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);\n  global.document.addEventListener('click', globalDOMEventHandler, false);\n  global.document.addEventListener('keypress', globalDOMEventHandler, false);\n\n  // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled\n  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That\n  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler\n  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still\n  // guaranteed to fire at least once.)\n  ['EventTarget', 'Node'].forEach((target) => {\n        var proto = (global )[target] && (global )[target].prototype;\n        if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n\n    fill(proto, 'addEventListener', function (originalAddEventListener) {\n      return function (\n        \n        type,\n        listener,\n        options,\n      ) {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            var el = this ;\n            var handlers = (el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {});\n            var handlerForType = (handlers[type] = handlers[type] || { refCount: 0 });\n\n            if (!handlerForType.handler) {\n              var handler = makeDOMEventHandler(triggerDOMHandler);\n              handlerForType.handler = handler;\n              originalAddEventListener.call(this, type, handler, options);\n            }\n\n            handlerForType.refCount += 1;\n          } catch (e) {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n          }\n        }\n\n        return originalAddEventListener.call(this, type, listener, options);\n      };\n    });\n\n    fill(\n      proto,\n      'removeEventListener',\n      function (originalRemoveEventListener) {\n        return function (\n          \n          type,\n          listener,\n          options,\n        ) {\n          if (type === 'click' || type == 'keypress') {\n            try {\n              var el = this ;\n              var handlers = el.__sentry_instrumentation_handlers__ || {};\n              var handlerForType = handlers[type];\n\n              if (handlerForType) {\n                handlerForType.refCount -= 1;\n                // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.\n                if (handlerForType.refCount <= 0) {\n                  originalRemoveEventListener.call(this, type, handlerForType.handler, options);\n                  handlerForType.handler = undefined;\n                  delete handlers[type];                 }\n\n                // If there are no longer any custom handlers of any type on this element, cleanup everything.\n                if (Object.keys(handlers).length === 0) {\n                  delete el.__sentry_instrumentation_handlers__;\n                }\n              }\n            } catch (e) {\n              // Accessing dom properties is always fragile.\n              // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n            }\n          }\n\n          return originalRemoveEventListener.call(this, type, listener, options);\n        };\n      },\n    );\n  });\n}\n\nlet _oldOnErrorHandler = null;\n/** JSDoc */\nfunction instrumentError() {\n  _oldOnErrorHandler = global.onerror;\n\n  global.onerror = function (msg, url, line, column, error) {\n    triggerHandlers('error', {\n      column,\n      error,\n      line,\n      msg,\n      url,\n    });\n\n    if (_oldOnErrorHandler) {\n            return _oldOnErrorHandler.apply(this, arguments);\n    }\n\n    return false;\n  };\n}\n\nlet _oldOnUnhandledRejectionHandler = null;\n/** JSDoc */\nfunction instrumentUnhandledRejection() {\n  _oldOnUnhandledRejectionHandler = global.onunhandledrejection;\n\n  global.onunhandledrejection = function (e) {\n    triggerHandlers('unhandledrejection', e);\n\n    if (_oldOnUnhandledRejectionHandler) {\n            return _oldOnUnhandledRejectionHandler.apply(this, arguments);\n    }\n\n    return true;\n  };\n}\n\nexport { addInstrumentationHandler };\n//# sourceMappingURL=instrument.js.map\n","var objectToString = Object.prototype.toString;\n\n/**\n * Checks whether given value's type is one of a few Error or Error-like\n * {@link isError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isError(wat) {\n  switch (objectToString.call(wat)) {\n    case '[object Error]':\n    case '[object Exception]':\n    case '[object DOMException]':\n      return true;\n    default:\n      return isInstanceOf(wat, Error);\n  }\n}\n/**\n * Checks whether given value is an instance of the given built-in class.\n *\n * @param wat The value to be checked\n * @param className\n * @returns A boolean representing the result.\n */\nfunction isBuiltin(wat, className) {\n  return objectToString.call(wat) === `[object ${className}]`;\n}\n\n/**\n * Checks whether given value's type is ErrorEvent\n * {@link isErrorEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isErrorEvent(wat) {\n  return isBuiltin(wat, 'ErrorEvent');\n}\n\n/**\n * Checks whether given value's type is DOMError\n * {@link isDOMError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isDOMError(wat) {\n  return isBuiltin(wat, 'DOMError');\n}\n\n/**\n * Checks whether given value's type is DOMException\n * {@link isDOMException}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isDOMException(wat) {\n  return isBuiltin(wat, 'DOMException');\n}\n\n/**\n * Checks whether given value's type is a string\n * {@link isString}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isString(wat) {\n  return isBuiltin(wat, 'String');\n}\n\n/**\n * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)\n * {@link isPrimitive}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isPrimitive(wat) {\n  return wat === null || (typeof wat !== 'object' && typeof wat !== 'function');\n}\n\n/**\n * Checks whether given value's type is an object literal\n * {@link isPlainObject}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isPlainObject(wat) {\n  return isBuiltin(wat, 'Object');\n}\n\n/**\n * Checks whether given value's type is an Event instance\n * {@link isEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isEvent(wat) {\n  return typeof Event !== 'undefined' && isInstanceOf(wat, Event);\n}\n\n/**\n * Checks whether given value's type is an Element instance\n * {@link isElement}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isElement(wat) {\n  return typeof Element !== 'undefined' && isInstanceOf(wat, Element);\n}\n\n/**\n * Checks whether given value's type is an regexp\n * {@link isRegExp}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isRegExp(wat) {\n  return isBuiltin(wat, 'RegExp');\n}\n\n/**\n * Checks whether given value has a then function.\n * @param wat A value to be checked.\n */\nfunction isThenable(wat) {\n    return Boolean(wat && wat.then && typeof wat.then === 'function');\n}\n\n/**\n * Checks whether given value's type is a SyntheticEvent\n * {@link isSyntheticEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isSyntheticEvent(wat) {\n  return isPlainObject(wat) && 'nativeEvent' in wat && 'preventDefault' in wat && 'stopPropagation' in wat;\n}\n\n/**\n * Checks whether given value is NaN\n * {@link isNaN}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isNaN(wat) {\n  return typeof wat === 'number' && wat !== wat;\n}\n\n/**\n * Checks whether given value's type is an instance of provided constructor.\n * {@link isInstanceOf}.\n *\n * @param wat A value to be checked.\n * @param base A constructor to be used in a check.\n * @returns A boolean representing the result.\n */\nfunction isInstanceOf(wat, base) {\n  try {\n    return wat instanceof base;\n  } catch (_e) {\n    return false;\n  }\n}\n\nexport { isDOMError, isDOMException, isElement, isError, isErrorEvent, isEvent, isInstanceOf, isNaN, isPlainObject, isPrimitive, isRegExp, isString, isSyntheticEvent, isThenable };\n//# sourceMappingURL=is.js.map\n","import { getGlobalObject, getGlobalSingleton } from './global.js';\n\n// TODO: Implement different loggers for different environments\nvar global = getGlobalObject();\n\n/** Prefix for logging strings */\nvar PREFIX = 'Sentry Logger ';\n\nvar CONSOLE_LEVELS = ['debug', 'info', 'warn', 'error', 'log', 'assert', 'trace'] ;\n\n/**\n * Temporarily disable sentry console instrumentations.\n *\n * @param callback The function to run against the original `console` messages\n * @returns The results of the callback\n */\nfunction consoleSandbox(callback) {\n  var global = getGlobalObject();\n\n  if (!('console' in global)) {\n    return callback();\n  }\n\n  var originalConsole = global.console ;\n  var wrappedLevels = {};\n\n  // Restore all wrapped console methods\n  CONSOLE_LEVELS.forEach(level => {\n    // TODO(v7): Remove this check as it's only needed for Node 6\n    var originalWrappedFunc =\n      originalConsole[level] && (originalConsole[level] ).__sentry_original__;\n    if (level in global.console && originalWrappedFunc) {\n      wrappedLevels[level] = originalConsole[level] ;\n      originalConsole[level] = originalWrappedFunc ;\n    }\n  });\n\n  try {\n    return callback();\n  } finally {\n    // Revert restoration to wrapped state\n    Object.keys(wrappedLevels).forEach(level => {\n      originalConsole[level] = wrappedLevels[level ];\n    });\n  }\n}\n\nfunction makeLogger() {\n  let enabled = false;\n  var logger = {\n    enable: () => {\n      enabled = true;\n    },\n    disable: () => {\n      enabled = false;\n    },\n  };\n\n  if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {\n    CONSOLE_LEVELS.forEach(name => {\n            logger[name] = (...args) => {\n        if (enabled) {\n          consoleSandbox(() => {\n            global.console[name](`${PREFIX}[${name}]:`, ...args);\n          });\n        }\n      };\n    });\n  } else {\n    CONSOLE_LEVELS.forEach(name => {\n      logger[name] = () => undefined;\n    });\n  }\n\n  return logger ;\n}\n\n// Ensure we only have a single logger instance, even if multiple versions of @sentry/utils are being used\nlet logger;\nif ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {\n  logger = getGlobalSingleton('logger', makeLogger);\n} else {\n  logger = makeLogger();\n}\n\nexport { CONSOLE_LEVELS, consoleSandbox, logger };\n//# sourceMappingURL=logger.js.map\n","import { getGlobalObject } from './global.js';\nimport { addNonEnumerableProperty } from './object.js';\nimport { snipLine } from './string.js';\n\n/**\n * Extended Window interface that allows for Crypto API usage in IE browsers\n */\n\n/**\n * UUID4 generator\n *\n * @returns string Generated UUID4.\n */\nfunction uuid4() {\n  var global = getGlobalObject() ;\n  var crypto = (global.crypto || global.msCrypto) ;\n\n  if (crypto && crypto.randomUUID) {\n    return crypto.randomUUID().replace(/-/g, '');\n  }\n\n  var getRandomByte =\n    crypto && crypto.getRandomValues ? () => crypto.getRandomValues(new Uint8Array(1))[0] : () => Math.random() * 16;\n\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n  // Concatenating the following numbers as strings results in '10000000100040008000100000000000'\n  return (([1e7] ) + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, c =>\n        ((c ) ^ ((getRandomByte() & 15) >> ((c ) / 4))).toString(16),\n  );\n}\n\nfunction getFirstException(event) {\n  return event.exception && event.exception.values ? event.exception.values[0] : undefined;\n}\n\n/**\n * Extracts either message or type+value from an event that can be used for user-facing logs\n * @returns event's description\n */\nfunction getEventDescription(event) {\n  const { message, event_id: eventId } = event;\n  if (message) {\n    return message;\n  }\n\n  var firstException = getFirstException(event);\n  if (firstException) {\n    if (firstException.type && firstException.value) {\n      return `${firstException.type}: ${firstException.value}`;\n    }\n    return firstException.type || firstException.value || eventId || '<unknown>';\n  }\n  return eventId || '<unknown>';\n}\n\n/**\n * Adds exception values, type and value to an synthetic Exception.\n * @param event The event to modify.\n * @param value Value of the exception.\n * @param type Type of the exception.\n * @hidden\n */\nfunction addExceptionTypeValue(event, value, type) {\n  var exception = (event.exception = event.exception || {});\n  var values = (exception.values = exception.values || []);\n  var firstException = (values[0] = values[0] || {});\n  if (!firstException.value) {\n    firstException.value = value || '';\n  }\n  if (!firstException.type) {\n    firstException.type = type || 'Error';\n  }\n}\n\n/**\n * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.\n *\n * @param event The event to modify.\n * @param newMechanism Mechanism data to add to the event.\n * @hidden\n */\nfunction addExceptionMechanism(event, newMechanism) {\n  var firstException = getFirstException(event);\n  if (!firstException) {\n    return;\n  }\n\n  var defaultMechanism = { type: 'generic', handled: true };\n  var currentMechanism = firstException.mechanism;\n  firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };\n\n  if (newMechanism && 'data' in newMechanism) {\n    var mergedData = { ...(currentMechanism && currentMechanism.data), ...newMechanism.data };\n    firstException.mechanism.data = mergedData;\n  }\n}\n\n// https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\nvar SEMVER_REGEXP =\n  /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$/;\n\n/**\n * Represents Semantic Versioning object\n */\n\n/**\n * Parses input into a SemVer interface\n * @param input string representation of a semver version\n */\nfunction parseSemver(input) {\n  var match = input.match(SEMVER_REGEXP) || [];\n  var major = parseInt(match[1], 10);\n  var minor = parseInt(match[2], 10);\n  var patch = parseInt(match[3], 10);\n  return {\n    buildmetadata: match[5],\n    major: isNaN(major) ? undefined : major,\n    minor: isNaN(minor) ? undefined : minor,\n    patch: isNaN(patch) ? undefined : patch,\n    prerelease: match[4],\n  };\n}\n\n/**\n * This function adds context (pre/post/line) lines to the provided frame\n *\n * @param lines string[] containing all lines\n * @param frame StackFrame that will be mutated\n * @param linesOfContext number of context lines we want to add pre/post\n */\nfunction addContextToFrame(lines, frame, linesOfContext = 5) {\n  var lineno = frame.lineno || 0;\n  var maxLines = lines.length;\n  var sourceLine = Math.max(Math.min(maxLines, lineno - 1), 0);\n\n  frame.pre_context = lines\n    .slice(Math.max(0, sourceLine - linesOfContext), sourceLine)\n    .map((line) => snipLine(line, 0));\n\n  frame.context_line = snipLine(lines[Math.min(maxLines - 1, sourceLine)], frame.colno || 0);\n\n  frame.post_context = lines\n    .slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext)\n    .map((line) => snipLine(line, 0));\n}\n\n/**\n * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object\n * in question), and marks it captured if not.\n *\n * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and\n * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so\n * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because\n * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not\n * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This\n * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we\n * see it.\n *\n * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on\n * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent\n * object wrapper forms so that this check will always work. However, because we need to flag the exact object which\n * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification\n * must be done before the exception captured.\n *\n * @param A thrown exception to check or flag as having been seen\n * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)\n */\nfunction checkOrSetAlreadyCaught(exception) {\n    if (exception && (exception ).__sentry_captured__) {\n    return true;\n  }\n\n  try {\n    // set it this way rather than by assignment so that it's not ennumerable and therefore isn't recorded by the\n    // `ExtraErrorData` integration\n    addNonEnumerableProperty(exception , '__sentry_captured__', true);\n  } catch (err) {\n    // `exception` is a primitive, so we can't mark it seen\n  }\n\n  return false;\n}\n\n/**\n * Checks whether the given input is already an array, and if it isn't, wraps it in one.\n *\n * @param maybeArray Input to turn into an array, if necessary\n * @returns The input, if already an array, or an array with the input as the only element, if not\n */\nfunction arrayify(maybeArray) {\n  return Array.isArray(maybeArray) ? maybeArray : [maybeArray];\n}\n\nexport { addContextToFrame, addExceptionMechanism, addExceptionTypeValue, arrayify, checkOrSetAlreadyCaught, getEventDescription, parseSemver, uuid4 };\n//# sourceMappingURL=misc.js.map\n","/*\n * This module exists for optimizations in the build process through rollup and terser.  We define some global\n * constants, which can be overridden during build. By guarding certain pieces of code with functions that return these\n * constants, we can control whether or not they appear in the final bundle. (Any code guarded by a false condition will\n * never run, and will hence be dropped during treeshaking.) The two primary uses for this are stripping out calls to\n * `logger` and preventing node-related code from appearing in browser bundles.\n *\n * Attention:\n * This file should not be used to define constants/flags that are intended to be used for tree-shaking conducted by\n * users. These fags should live in their respective packages, as we identified user tooling (specifically webpack)\n * having issues tree-shaking these constants across package boundaries.\n * An example for this is the __SENTRY_DEBUG__ constant. It is declared in each package individually because we want\n * users to be able to shake away expressions that it guards.\n */\n\n/**\n * Figures out if we're building a browser bundle.\n *\n * @returns true if this is a browser bundle build.\n */\nfunction isBrowserBundle() {\n  return typeof __SENTRY_BROWSER_BUNDLE__ !== 'undefined' && !!__SENTRY_BROWSER_BUNDLE__;\n}\n\nexport { isBrowserBundle };\n//# sourceMappingURL=env.js.map\n","import { isBrowserBundle } from './env.js';\n\n/**\n * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,\n * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.\n */\n\n/**\n * Checks whether we're in the Node.js or Browser environment\n *\n * @returns Answer to given question\n */\nfunction isNodeEnv() {\n  // explicitly check for browser bundles as those can be optimized statically\n  // by terser/rollup.\n  return (\n    !isBrowserBundle() &&\n    Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]'\n  );\n}\n\n/**\n * Requires a module which is protected against bundler minification.\n *\n * @param request The module path to resolve\n */\nfunction dynamicRequire(mod, request) {\n    return mod.require(request);\n}\n\n/**\n * Helper for dynamically loading module that should work with linked dependencies.\n * The problem is that we _should_ be using `require(require.resolve(moduleName, { paths: [cwd()] }))`\n * However it's _not possible_ to do that with Webpack, as it has to know all the dependencies during\n * build time. `require.resolve` is also not available in any other way, so we cannot create,\n * a fake helper like we do with `dynamicRequire`.\n *\n * We always prefer to use local package, thus the value is not returned early from each `try/catch` block.\n * That is to mimic the behavior of `require.resolve` exactly.\n *\n * @param moduleName module name to require\n * @returns possibly required module\n */\nfunction loadModule(moduleName) {\n  let mod;\n\n  try {\n    mod = dynamicRequire(module, moduleName);\n  } catch (e) {\n    // no-empty\n  }\n\n  try {\n    const { cwd } = dynamicRequire(module, 'process');\n    mod = dynamicRequire(module, `${cwd()}/node_modules/${moduleName}`) ;\n  } catch (e) {\n    // no-empty\n  }\n\n  return mod;\n}\n\nexport { dynamicRequire, isNodeEnv, loadModule };\n//# sourceMappingURL=node.js.map\n","/**\n * Helper to decycle json objects\n */\nfunction memoBuilder() {\n  var hasWeakSet = typeof WeakSet === 'function';\n  var inner = hasWeakSet ? new WeakSet() : [];\n  function memoize(obj) {\n    if (hasWeakSet) {\n      if (inner.has(obj)) {\n        return true;\n      }\n      inner.add(obj);\n      return false;\n    }\n        for (let i = 0; i < inner.length; i++) {\n      var value = inner[i];\n      if (value === obj) {\n        return true;\n      }\n    }\n    inner.push(obj);\n    return false;\n  }\n\n  function unmemoize(obj) {\n    if (hasWeakSet) {\n      inner.delete(obj);\n    } else {\n      for (let i = 0; i < inner.length; i++) {\n        if (inner[i] === obj) {\n          inner.splice(i, 1);\n          break;\n        }\n      }\n    }\n  }\n  return [memoize, unmemoize];\n}\n\nexport { memoBuilder };\n//# sourceMappingURL=memo.js.map\n","import { isNaN, isSyntheticEvent } from './is.js';\nimport { memoBuilder } from './memo.js';\nimport { convertToPlainObject } from './object.js';\nimport { getFunctionName } from './stacktrace.js';\n\n/**\n * Recursively normalizes the given object.\n *\n * - Creates a copy to prevent original input mutation\n * - Skips non-enumerable properties\n * - When stringifying, calls `toJSON` if implemented\n * - Removes circular references\n * - Translates non-serializable values (`undefined`/`NaN`/functions) to serializable format\n * - Translates known global objects/classes to a string representations\n * - Takes care of `Error` object serialization\n * - Optionally limits depth of final output\n * - Optionally limits number of properties/elements included in any single object/array\n *\n * @param input The object to be normalized.\n * @param depth The max depth to which to normalize the object. (Anything deeper stringified whole.)\n * @param maxProperties The max number of elements or properties to be included in any single array or\n * object in the normallized output.\n * @returns A normalized version of the object, or `\"**non-serializable**\"` if any errors are thrown during normalization.\n */\nfunction normalize(input, depth = +Infinity, maxProperties = +Infinity) {\n  try {\n    // since we're at the outermost level, we don't provide a key\n    return visit('', input, depth, maxProperties);\n  } catch (err) {\n    return { ERROR: `**non-serializable** (${err})` };\n  }\n}\n\n/** JSDoc */\nfunction normalizeToSize(\n    object,\n  // Default Node.js REPL depth\n  depth = 3,\n  // 100kB, as 200kB is max payload size, so half sounds reasonable\n  maxSize = 100 * 1024,\n) {\n  var normalized = normalize(object, depth);\n\n  if (jsonSize(normalized) > maxSize) {\n    return normalizeToSize(object, depth - 1, maxSize);\n  }\n\n  return normalized ;\n}\n\n/**\n * Visits a node to perform normalization on it\n *\n * @param key The key corresponding to the given node\n * @param value The node to be visited\n * @param depth Optional number indicating the maximum recursion depth\n * @param maxProperties Optional maximum number of properties/elements included in any single object/array\n * @param memo Optional Memo class handling decycling\n */\nfunction visit(\n  key,\n  value,\n  depth = +Infinity,\n  maxProperties = +Infinity,\n  memo = memoBuilder(),\n) {\n  const [memoize, unmemoize] = memo;\n\n  // Get the simple cases out of the way first\n  if (value === null || (['number', 'boolean', 'string'].includes(typeof value) && !isNaN(value))) {\n    return value ;\n  }\n\n  var stringified = stringifyValue(key, value);\n\n  // Anything we could potentially dig into more (objects or arrays) will have come back as `\"[object XXXX]\"`.\n  // Everything else will have already been serialized, so if we don't see that pattern, we're done.\n  if (!stringified.startsWith('[object ')) {\n    return stringified;\n  }\n\n  // From here on, we can assert that `value` is either an object or an array.\n\n  // Do not normalize objects that we know have already been normalized. As a general rule, the\n  // \"__sentry_skip_normalization__\" property should only be used sparingly and only should only be set on objects that\n  // have already been normalized.\n  if ((value )['__sentry_skip_normalization__']) {\n    return value ;\n  }\n\n  // We're also done if we've reached the max depth\n  if (depth === 0) {\n    // At this point we know `serialized` is a string of the form `\"[object XXXX]\"`. Clean it up so it's just `\"[XXXX]\"`.\n    return stringified.replace('object ', '');\n  }\n\n  // If we've already visited this branch, bail out, as it's circular reference. If not, note that we're seeing it now.\n  if (memoize(value)) {\n    return '[Circular ~]';\n  }\n\n  // If the value has a `toJSON` method, we call it to extract more information\n  var valueWithToJSON = value ;\n  if (valueWithToJSON && typeof valueWithToJSON.toJSON === 'function') {\n    try {\n      var jsonValue = valueWithToJSON.toJSON();\n      // We need to normalize the return value of `.toJSON()` in case it has circular references\n      return visit('', jsonValue, depth - 1, maxProperties, memo);\n    } catch (err) {\n      // pass (The built-in `toJSON` failed, but we can still try to do it ourselves)\n    }\n  }\n\n  // At this point we know we either have an object or an array, we haven't seen it before, and we're going to recurse\n  // because we haven't yet reached the max depth. Create an accumulator to hold the results of visiting each\n  // property/entry, and keep track of the number of items we add to it.\n  var normalized = (Array.isArray(value) ? [] : {}) ;\n  let numAdded = 0;\n\n  // Before we begin, convert`Error` and`Event` instances into plain objects, since some of each of their relevant\n  // properties are non-enumerable and otherwise would get missed.\n  var visitable = convertToPlainObject(value );\n\n  for (var visitKey in visitable) {\n    // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.\n    if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {\n      continue;\n    }\n\n    if (numAdded >= maxProperties) {\n      normalized[visitKey] = '[MaxProperties ~]';\n      break;\n    }\n\n    // Recursively visit all the child nodes\n    var visitValue = visitable[visitKey];\n    normalized[visitKey] = visit(visitKey, visitValue, depth - 1, maxProperties, memo);\n\n    numAdded += 1;\n  }\n\n  // Once we've visited all the branches, remove the parent from memo storage\n  unmemoize(value);\n\n  // Return accumulated values\n  return normalized;\n}\n\n/**\n * Stringify the given value. Handles various known special values and types.\n *\n * Not meant to be used on simple primitives which already have a string representation, as it will, for example, turn\n * the number 1231 into \"[Object Number]\", nor on `null`, as it will throw.\n *\n * @param value The value to stringify\n * @returns A stringified representation of the given value\n */\nfunction stringifyValue(\n  key,\n  // this type is a tiny bit of a cheat, since this function does handle NaN (which is technically a number), but for\n  // our internal use, it'll do\n  value,\n) {\n  try {\n    if (key === 'domain' && value && typeof value === 'object' && (value )._events) {\n      return '[Domain]';\n    }\n\n    if (key === 'domainEmitter') {\n      return '[DomainEmitter]';\n    }\n\n    // It's safe to use `global`, `window`, and `document` here in this manner, as we are asserting using `typeof` first\n    // which won't throw if they are not present.\n\n    if (typeof global !== 'undefined' && value === global) {\n      return '[Global]';\n    }\n\n        if (typeof window !== 'undefined' && value === window) {\n      return '[Window]';\n    }\n\n        if (typeof document !== 'undefined' && value === document) {\n      return '[Document]';\n    }\n\n    // React's SyntheticEvent thingy\n    if (isSyntheticEvent(value)) {\n      return '[SyntheticEvent]';\n    }\n\n    if (typeof value === 'number' && value !== value) {\n      return '[NaN]';\n    }\n\n    // this catches `undefined` (but not `null`, which is a primitive and can be serialized on its own)\n    if (value === void 0) {\n      return '[undefined]';\n    }\n\n    if (typeof value === 'function') {\n      return `[Function: ${getFunctionName(value)}]`;\n    }\n\n    if (typeof value === 'symbol') {\n      return `[${String(value)}]`;\n    }\n\n    // stringified BigInts are indistinguishable from regular numbers, so we need to label them to avoid confusion\n    if (typeof value === 'bigint') {\n      return `[BigInt: ${String(value)}]`;\n    }\n\n    // Now that we've knocked out all the special cases and the primitives, all we have left are objects. Simply casting\n    // them to strings means that instances of classes which haven't defined their `toStringTag` will just come out as\n    // `\"[object Object]\"`. If we instead look at the constructor's name (which is the same as the name of the class),\n    // we can make sure that only plain objects come out that way.\n    return `[object ${(Object.getPrototypeOf(value) ).constructor.name}]`;\n  } catch (err) {\n    return `**non-serializable** (${err})`;\n  }\n}\n\n/** Calculates bytes size of input string */\nfunction utf8Length(value) {\n    return ~-encodeURI(value).split(/%..|./).length;\n}\n\n/** Calculates bytes size of input object */\nfunction jsonSize(value) {\n  return utf8Length(JSON.stringify(value));\n}\n\nexport { normalize, normalizeToSize, visit as walk };\n//# sourceMappingURL=normalize.js.map\n","import { htmlTreeAsString } from './browser.js';\nimport { isError, isEvent, isInstanceOf, isElement, isPlainObject, isPrimitive } from './is.js';\nimport { truncate } from './string.js';\n\n/**\n * Replace a method in an object with a wrapped version of itself.\n *\n * @param source An object that contains a method to be wrapped.\n * @param name The name of the method to be wrapped.\n * @param replacementFactory A higher-order function that takes the original version of the given method and returns a\n * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to\n * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other\n * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.\n * @returns void\n */\nfunction fill(source, name, replacementFactory) {\n  if (!(name in source)) {\n    return;\n  }\n\n  var original = source[name] ;\n  var wrapped = replacementFactory(original) ;\n\n  // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n  // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n  if (typeof wrapped === 'function') {\n    try {\n      markFunctionWrapped(wrapped, original);\n    } catch (_Oo) {\n      // This can throw if multiple fill happens on a global object like XMLHttpRequest\n      // Fixes https://github.com/getsentry/sentry-javascript/issues/2043\n    }\n  }\n\n  source[name] = wrapped;\n}\n\n/**\n * Defines a non-enumerable property on the given object.\n *\n * @param obj The object on which to set the property\n * @param name The name of the property to be set\n * @param value The value to which to set the property\n */\nfunction addNonEnumerableProperty(obj, name, value) {\n  Object.defineProperty(obj, name, {\n    // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it\n    value: value,\n    writable: true,\n    configurable: true,\n  });\n}\n\n/**\n * Remembers the original function on the wrapped function and\n * patches up the prototype.\n *\n * @param wrapped the wrapper function\n * @param original the original function that gets wrapped\n */\nfunction markFunctionWrapped(wrapped, original) {\n  var proto = original.prototype || {};\n  wrapped.prototype = original.prototype = proto;\n  addNonEnumerableProperty(wrapped, '__sentry_original__', original);\n}\n\n/**\n * This extracts the original function if available.  See\n * `markFunctionWrapped` for more information.\n *\n * @param func the function to unwrap\n * @returns the unwrapped version of the function if available.\n */\nfunction getOriginalFunction(func) {\n  return func.__sentry_original__;\n}\n\n/**\n * Encodes given object into url-friendly format\n *\n * @param object An object that contains serializable values\n * @returns string Encoded\n */\nfunction urlEncode(object) {\n  return Object.keys(object)\n    .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(object[key])}`)\n    .join('&');\n}\n\n/**\n * Transforms any `Error` or `Event` into a plain object with all of their enumerable properties, and some of their\n * non-enumerable properties attached.\n *\n * @param value Initial source that we have to transform in order for it to be usable by the serializer\n * @returns An Event or Error turned into an object - or the value argurment itself, when value is neither an Event nor\n *  an Error.\n */\nfunction convertToPlainObject(\n  value,\n)\n\n {\n  if (isError(value)) {\n    return {\n      message: value.message,\n      name: value.name,\n      stack: value.stack,\n      ...getOwnProperties(value),\n    };\n  } else if (isEvent(value)) {\n    var newObj\n\n = {\n      type: value.type,\n      target: serializeEventTarget(value.target),\n      currentTarget: serializeEventTarget(value.currentTarget),\n      ...getOwnProperties(value),\n    };\n\n    if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {\n      newObj.detail = value.detail;\n    }\n\n    return newObj;\n  } else {\n    return value;\n  }\n}\n\n/** Creates a string representation of the target of an `Event` object */\nfunction serializeEventTarget(target) {\n  try {\n    return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);\n  } catch (_oO) {\n    return '<unknown>';\n  }\n}\n\n/** Filters out all but an object's own properties */\nfunction getOwnProperties(obj) {\n  if (typeof obj === 'object' && obj !== null) {\n    var extractedProps = {};\n    for (var property in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, property)) {\n        extractedProps[property] = (obj )[property];\n      }\n    }\n    return extractedProps;\n  } else {\n    return {};\n  }\n}\n\n/**\n * Given any captured exception, extract its keys and create a sorted\n * and truncated list that will be used inside the event message.\n * eg. `Non-error exception captured with keys: foo, bar, baz`\n */\nfunction extractExceptionKeysForMessage(exception, maxLength = 40) {\n  var keys = Object.keys(convertToPlainObject(exception));\n  keys.sort();\n\n  if (!keys.length) {\n    return '[object has no keys]';\n  }\n\n  if (keys[0].length >= maxLength) {\n    return truncate(keys[0], maxLength);\n  }\n\n  for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {\n    var serialized = keys.slice(0, includedKeys).join(', ');\n    if (serialized.length > maxLength) {\n      continue;\n    }\n    if (includedKeys === keys.length) {\n      return serialized;\n    }\n    return truncate(serialized, maxLength);\n  }\n\n  return '';\n}\n\n/**\n * Given any object, return a new object having removed all fields whose value was `undefined`.\n * Works recursively on objects and arrays.\n *\n * Attention: This function keeps circular references in the returned object.\n */\nfunction dropUndefinedKeys(inputValue) {\n  // This map keeps track of what already visited nodes map to.\n  // Our Set - based memoBuilder doesn't work here because we want to the output object to have the same circular\n  // references as the input object.\n  var memoizationMap = new Map();\n\n  // This function just proxies `_dropUndefinedKeys` to keep the `memoBuilder` out of this function's API\n  return _dropUndefinedKeys(inputValue, memoizationMap);\n}\n\nfunction _dropUndefinedKeys(inputValue, memoizationMap) {\n  if (isPlainObject(inputValue)) {\n    // If this node has already been visited due to a circular reference, return the object it was mapped to in the new object\n    var memoVal = memoizationMap.get(inputValue);\n    if (memoVal !== undefined) {\n      return memoVal ;\n    }\n\n    var returnValue = {};\n    // Store the mapping of this value in case we visit it again, in case of circular data\n    memoizationMap.set(inputValue, returnValue);\n\n    for (var key of Object.keys(inputValue)) {\n      if (typeof inputValue[key] !== 'undefined') {\n        returnValue[key] = _dropUndefinedKeys(inputValue[key], memoizationMap);\n      }\n    }\n\n    return returnValue ;\n  }\n\n  if (Array.isArray(inputValue)) {\n    // If this node has already been visited due to a circular reference, return the array it was mapped to in the new object\n    var memoVal = memoizationMap.get(inputValue);\n    if (memoVal !== undefined) {\n      return memoVal ;\n    }\n\n    var returnValue = [];\n    // Store the mapping of this value in case we visit it again, in case of circular data\n    memoizationMap.set(inputValue, returnValue);\n\n    inputValue.forEach((item) => {\n      returnValue.push(_dropUndefinedKeys(item, memoizationMap));\n    });\n\n    return returnValue ;\n  }\n\n  return inputValue;\n}\n\n/**\n * Ensure that something is an object.\n *\n * Turns `undefined` and `null` into `String`s and all other primitives into instances of their respective wrapper\n * classes (String, Boolean, Number, etc.). Acts as the identity function on non-primitives.\n *\n * @param wat The subject of the objectification\n * @returns A version of `wat` which can safely be used with `Object` class methods\n */\nfunction objectify(wat) {\n  let objectified;\n  switch (true) {\n    case wat === undefined || wat === null:\n      objectified = new String(wat);\n      break;\n\n    // Though symbols and bigints do have wrapper classes (`Symbol` and `BigInt`, respectively), for whatever reason\n    // those classes don't have constructors which can be used with the `new` keyword. We therefore need to cast each as\n    // an object in order to wrap it.\n    case typeof wat === 'symbol' || typeof wat === 'bigint':\n      objectified = Object(wat);\n      break;\n\n    // this will catch the remaining primitives: `String`, `Number`, and `Boolean`\n    case isPrimitive(wat):\n            objectified = new (wat ).constructor(wat);\n      break;\n\n    // by process of elimination, at this point we know that `wat` must already be an object\n    default:\n      objectified = wat;\n      break;\n  }\n  return objectified;\n}\n\nexport { addNonEnumerableProperty, convertToPlainObject, dropUndefinedKeys, extractExceptionKeysForMessage, fill, getOriginalFunction, markFunctionWrapped, objectify, urlEncode };\n//# sourceMappingURL=object.js.map\n","import { _optionalChain } from './buildPolyfills';\n\nvar STACKTRACE_LIMIT = 50;\n\n/**\n * Creates a stack parser with the supplied line parsers\n *\n * StackFrames are returned in the correct order for Sentry Exception\n * frames and with Sentry SDK internal frames removed from the top and bottom\n *\n */\nfunction createStackParser(...parsers) {\n  var sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map(p => p[1]);\n\n  return (stack, skipFirst = 0) => {\n    var frames = [];\n\n    for (var line of stack.split('\\n').slice(skipFirst)) {\n      // https://github.com/getsentry/sentry-javascript/issues/5459\n      // Remove webpack (error: *) wrappers\n      var cleanedLine = line.replace(/\\(error: (.*)\\)/, '$1');\n\n      for (var parser of sortedParsers) {\n        var frame = parser(cleanedLine);\n\n        if (frame) {\n          frames.push(frame);\n          break;\n        }\n      }\n    }\n\n    return stripSentryFramesAndReverse(frames);\n  };\n}\n\n/**\n * Gets a stack parser implementation from Options.stackParser\n * @see Options\n *\n * If options contains an array of line parsers, it is converted into a parser\n */\nfunction stackParserFromStackParserOptions(stackParser) {\n  if (Array.isArray(stackParser)) {\n    return createStackParser(...stackParser);\n  }\n  return stackParser;\n}\n\n/**\n * @hidden\n */\nfunction stripSentryFramesAndReverse(stack) {\n  if (!stack.length) {\n    return [];\n  }\n\n  let localStack = stack;\n\n  var firstFrameFunction = localStack[0].function || '';\n  var lastFrameFunction = localStack[localStack.length - 1].function || '';\n\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {\n    localStack = localStack.slice(1);\n  }\n\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {\n    localStack = localStack.slice(0, -1);\n  }\n\n  // The frame where the crash happened, should be the last entry in the array\n  return localStack\n    .slice(0, STACKTRACE_LIMIT)\n    .map(frame => ({\n      ...frame,\n      filename: frame.filename || localStack[0].filename,\n      function: frame.function || '?',\n    }))\n    .reverse();\n}\n\nvar defaultFunctionName = '<anonymous>';\n\n/**\n * Safely extract function name from itself\n */\nfunction getFunctionName(fn) {\n  try {\n    if (!fn || typeof fn !== 'function') {\n      return defaultFunctionName;\n    }\n    return fn.name || defaultFunctionName;\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    return defaultFunctionName;\n  }\n}\n\nfunction node(getModule) {\n  var FILENAME_MATCH = /^\\s*[-]{4,}$/;\n  var FULL_MATCH = /at (?:async )?(?:(.+?)\\s+\\()?(?:(.+):(\\d+):(\\d+)?|([^)]+))\\)?/;\n\n    return (line) => {\n    if (line.match(FILENAME_MATCH)) {\n      return {\n        filename: line,\n      };\n    }\n\n    var lineMatch = line.match(FULL_MATCH);\n    if (!lineMatch) {\n      return undefined;\n    }\n\n    let object;\n    let method;\n    let functionName;\n    let typeName;\n    let methodName;\n\n    if (lineMatch[1]) {\n      functionName = lineMatch[1];\n\n      let methodStart = functionName.lastIndexOf('.');\n      if (functionName[methodStart - 1] === '.') {\n                methodStart--;\n      }\n\n      if (methodStart > 0) {\n        object = functionName.substr(0, methodStart);\n        method = functionName.substr(methodStart + 1);\n        var objectEnd = object.indexOf('.Module');\n        if (objectEnd > 0) {\n          functionName = functionName.substr(objectEnd + 1);\n          object = object.substr(0, objectEnd);\n        }\n      }\n      typeName = undefined;\n    }\n\n    if (method) {\n      typeName = object;\n      methodName = method;\n    }\n\n    if (method === '<anonymous>') {\n      methodName = undefined;\n      functionName = undefined;\n    }\n\n    if (functionName === undefined) {\n      methodName = methodName || '<anonymous>';\n      functionName = typeName ? `${typeName}.${methodName}` : methodName;\n    }\n\n    var filename = _optionalChain([lineMatch, 'access', _ => _[2], 'optionalAccess', _2 => _2.startsWith, 'call', _3 => _3('file://')]) ? lineMatch[2].substr(7) : lineMatch[2];\n    var isNative = lineMatch[5] === 'native';\n    var isInternal =\n      isNative || (filename && !filename.startsWith('/') && !filename.startsWith('.') && filename.indexOf(':\\\\') !== 1);\n\n    // in_app is all that's not an internal Node function or a module within node_modules\n    // note that isNative appears to return true even for node core libraries\n    // see https://github.com/getsentry/raven-node/issues/176\n    var in_app = !isInternal && filename !== undefined && !filename.includes('node_modules/');\n\n    return {\n      filename,\n      module: _optionalChain([getModule, 'optionalCall', _4 => _4(filename)]),\n      function: functionName,\n      lineno: parseInt(lineMatch[3], 10) || undefined,\n      colno: parseInt(lineMatch[4], 10) || undefined,\n      in_app,\n    };\n  };\n}\n\n/**\n * Node.js stack line parser\n *\n * This is in @sentry/utils so it can be used from the Electron SDK in the browser for when `nodeIntegration == true`.\n * This allows it to be used without referencing or importing any node specific code which causes bundlers to complain\n */\nfunction nodeStackLineParser(getModule) {\n  return [90, node(getModule)];\n}\n\nexport { createStackParser, getFunctionName, nodeStackLineParser, stackParserFromStackParserOptions, stripSentryFramesAndReverse };\n//# sourceMappingURL=stacktrace.js.map\n","import { isString, isRegExp } from './is.js';\n\n/**\n * Truncates given string to the maximum characters count\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string (0 = unlimited)\n * @returns string Encoded\n */\nfunction truncate(str, max = 0) {\n  if (typeof str !== 'string' || max === 0) {\n    return str;\n  }\n  return str.length <= max ? str : `${str.substr(0, max)}...`;\n}\n\n/**\n * This is basically just `trim_line` from\n * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string\n * @returns string Encoded\n */\nfunction snipLine(line, colno) {\n  let newLine = line;\n  var lineLength = newLine.length;\n  if (lineLength <= 150) {\n    return newLine;\n  }\n  if (colno > lineLength) {\n        colno = lineLength;\n  }\n\n  let start = Math.max(colno - 60, 0);\n  if (start < 5) {\n    start = 0;\n  }\n\n  let end = Math.min(start + 140, lineLength);\n  if (end > lineLength - 5) {\n    end = lineLength;\n  }\n  if (end === lineLength) {\n    start = Math.max(end - 140, 0);\n  }\n\n  newLine = newLine.slice(start, end);\n  if (start > 0) {\n    newLine = `'{snip} ${newLine}`;\n  }\n  if (end < lineLength) {\n    newLine += ' {snip}';\n  }\n\n  return newLine;\n}\n\n/**\n * Join values in array\n * @param input array of values to be joined together\n * @param delimiter string to be placed in-between values\n * @returns Joined values\n */\nfunction safeJoin(input, delimiter) {\n  if (!Array.isArray(input)) {\n    return '';\n  }\n\n  var output = [];\n    for (let i = 0; i < input.length; i++) {\n    var value = input[i];\n    try {\n      output.push(String(value));\n    } catch (e) {\n      output.push('[value cannot be serialized]');\n    }\n  }\n\n  return output.join(delimiter);\n}\n\n/**\n * Checks if the value matches a regex or includes the string\n * @param value The string value to be checked against\n * @param pattern Either a regex or a string that must be contained in value\n */\nfunction isMatchingPattern(value, pattern) {\n  if (!isString(value)) {\n    return false;\n  }\n\n  if (isRegExp(pattern)) {\n    return pattern.test(value);\n  }\n  if (typeof pattern === 'string') {\n    return value.indexOf(pattern) !== -1;\n  }\n  return false;\n}\n\n/**\n * Given a string, escape characters which have meaning in the regex grammar, such that the result is safe to feed to\n * `new RegExp()`.\n *\n * Based on https://github.com/sindresorhus/escape-string-regexp. Vendored to a) reduce the size by skipping the runtime\n * type-checking, and b) ensure it gets down-compiled for old versions of Node (the published package only supports Node\n * 12+).\n *\n * @param regexString The string to escape\n * @returns An version of the string with all special regex characters escaped\n */\nfunction escapeStringForRegex(regexString) {\n  // escape the hyphen separately so we can also replace it with a unicode literal hyphen, to avoid the problems\n  // discussed in https://github.com/sindresorhus/escape-string-regexp/issues/20.\n  return regexString.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d');\n}\n\nexport { escapeStringForRegex, isMatchingPattern, safeJoin, snipLine, truncate };\n//# sourceMappingURL=string.js.map\n","import { getGlobalObject } from './global.js';\nimport { logger } from './logger.js';\n\n/**\n * Tells whether current environment supports ErrorEvent objects\n * {@link supportsErrorEvent}.\n *\n * @returns Answer to the given question.\n */\nfunction supportsErrorEvent() {\n  try {\n    new ErrorEvent('');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports DOMError objects\n * {@link supportsDOMError}.\n *\n * @returns Answer to the given question.\n */\nfunction supportsDOMError() {\n  try {\n    // Chrome: VM89:1 Uncaught TypeError: Failed to construct 'DOMError':\n    // 1 argument required, but only 0 present.\n    // @ts-ignore It really needs 1 argument, not 0.\n    new DOMError('');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports DOMException objects\n * {@link supportsDOMException}.\n *\n * @returns Answer to the given question.\n */\nfunction supportsDOMException() {\n  try {\n    new DOMException('');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports Fetch API\n * {@link supportsFetch}.\n *\n * @returns Answer to the given question.\n */\nfunction supportsFetch() {\n  if (!('fetch' in getGlobalObject())) {\n    return false;\n  }\n\n  try {\n    new Headers();\n    new Request('http://www.example.com');\n    new Response();\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * isNativeFetch checks if the given function is a native implementation of fetch()\n */\nfunction isNativeFetch(func) {\n  return func && /^function fetch\\(\\)\\s+\\{\\s+\\[native code\\]\\s+\\}$/.test(func.toString());\n}\n\n/**\n * Tells whether current environment supports Fetch API natively\n * {@link supportsNativeFetch}.\n *\n * @returns true if `window.fetch` is natively implemented, false otherwise\n */\nfunction supportsNativeFetch() {\n  if (!supportsFetch()) {\n    return false;\n  }\n\n  var global = getGlobalObject();\n\n  // Fast path to avoid DOM I/O\n    if (isNativeFetch(global.fetch)) {\n    return true;\n  }\n\n  // window.fetch is implemented, but is polyfilled or already wrapped (e.g: by a chrome extension)\n  // so create a \"pure\" iframe to see if that has native fetch\n  let result = false;\n  var doc = global.document;\n    if (doc && typeof (doc.createElement ) === 'function') {\n    try {\n      var sandbox = doc.createElement('iframe');\n      sandbox.hidden = true;\n      doc.head.appendChild(sandbox);\n      if (sandbox.contentWindow && sandbox.contentWindow.fetch) {\n                result = isNativeFetch(sandbox.contentWindow.fetch);\n      }\n      doc.head.removeChild(sandbox);\n    } catch (err) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', err);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Tells whether current environment supports ReportingObserver API\n * {@link supportsReportingObserver}.\n *\n * @returns Answer to the given question.\n */\nfunction supportsReportingObserver() {\n  return 'ReportingObserver' in getGlobalObject();\n}\n\n/**\n * Tells whether current environment supports Referrer Policy API\n * {@link supportsReferrerPolicy}.\n *\n * @returns Answer to the given question.\n */\nfunction supportsReferrerPolicy() {\n  // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default'\n  // (see https://caniuse.com/#feat=referrer-policy),\n  // it doesn't. And it throws an exception instead of ignoring this parameter...\n  // REF: https://github.com/getsentry/raven-js/issues/1233\n\n  if (!supportsFetch()) {\n    return false;\n  }\n\n  try {\n    new Request('_', {\n      referrerPolicy: 'origin' ,\n    });\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports History API\n * {@link supportsHistory}.\n *\n * @returns Answer to the given question.\n */\nfunction supportsHistory() {\n  // NOTE: in Chrome App environment, touching history.pushState, *even inside\n  //       a try/catch block*, will cause Chrome to output an error to console.error\n  // borrowed from: https://github.com/angular/angular.js/pull/13945/files\n  var global = getGlobalObject();\n      var chrome = (global ).chrome;\n  var isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;\n    var hasHistoryApi = 'history' in global && !!global.history.pushState && !!global.history.replaceState;\n\n  return !isChromePackagedApp && hasHistoryApi;\n}\n\nexport { isNativeFetch, supportsDOMError, supportsDOMException, supportsErrorEvent, supportsFetch, supportsHistory, supportsNativeFetch, supportsReferrerPolicy, supportsReportingObserver };\n//# sourceMappingURL=supports.js.map\n","import { isThenable } from './is.js';\n\n/** SyncPromise internal states */\nvar States; (function (States) {\n  /** Pending */\n  var PENDING = 0; States[States[\"PENDING\"] = PENDING] = \"PENDING\";\n  /** Resolved / OK */\n  var RESOLVED = 1; States[States[\"RESOLVED\"] = RESOLVED] = \"RESOLVED\";\n  /** Rejected / Error */\n  var REJECTED = 2; States[States[\"REJECTED\"] = REJECTED] = \"REJECTED\";\n})(States || (States = {}));\n\n// Overloads so we can call resolvedSyncPromise without arguments and generic argument\n\n/**\n * Creates a resolved sync promise.\n *\n * @param value the value to resolve the promise with\n * @returns the resolved sync promise\n */\nfunction resolvedSyncPromise(value) {\n  return new SyncPromise(resolve => {\n    resolve(value);\n  });\n}\n\n/**\n * Creates a rejected sync promise.\n *\n * @param value the value to reject the promise with\n * @returns the rejected sync promise\n */\nfunction rejectedSyncPromise(reason) {\n  return new SyncPromise((_, reject) => {\n    reject(reason);\n  });\n}\n\n/**\n * Thenable class that behaves like a Promise and follows it's interface\n * but is not async internally\n */\nclass SyncPromise {\n   __init() {this._state = States.PENDING;}\n   __init2() {this._handlers = [];}\n  \n\n   constructor(\n    executor,\n  ) {;SyncPromise.prototype.__init.call(this);SyncPromise.prototype.__init2.call(this);SyncPromise.prototype.__init3.call(this);SyncPromise.prototype.__init4.call(this);SyncPromise.prototype.__init5.call(this);SyncPromise.prototype.__init6.call(this);\n    try {\n      executor(this._resolve, this._reject);\n    } catch (e) {\n      this._reject(e);\n    }\n  }\n\n  /** JSDoc */\n   then(\n    onfulfilled,\n    onrejected,\n  ) {\n    return new SyncPromise((resolve, reject) => {\n      this._handlers.push([\n        false,\n        result => {\n          if (!onfulfilled) {\n            // TODO: \\_()_/\n            // TODO: FIXME\n            resolve(result );\n          } else {\n            try {\n              resolve(onfulfilled(result));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n        reason => {\n          if (!onrejected) {\n            reject(reason);\n          } else {\n            try {\n              resolve(onrejected(reason));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n      ]);\n      this._executeHandlers();\n    });\n  }\n\n  /** JSDoc */\n   catch(\n    onrejected,\n  ) {\n    return this.then(val => val, onrejected);\n  }\n\n  /** JSDoc */\n   finally(onfinally) {\n    return new SyncPromise((resolve, reject) => {\n      let val;\n      let isRejected;\n\n      return this.then(\n        value => {\n          isRejected = false;\n          val = value;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n        reason => {\n          isRejected = true;\n          val = reason;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n      ).then(() => {\n        if (isRejected) {\n          reject(val);\n          return;\n        }\n\n        resolve(val );\n      });\n    });\n  }\n\n  /** JSDoc */\n    __init3() {this._resolve = (value) => {\n    this._setResult(States.RESOLVED, value);\n  };}\n\n  /** JSDoc */\n    __init4() {this._reject = (reason) => {\n    this._setResult(States.REJECTED, reason);\n  };}\n\n  /** JSDoc */\n    __init5() {this._setResult = (state, value) => {\n    if (this._state !== States.PENDING) {\n      return;\n    }\n\n    if (isThenable(value)) {\n      void (value ).then(this._resolve, this._reject);\n      return;\n    }\n\n    this._state = state;\n    this._value = value;\n\n    this._executeHandlers();\n  };}\n\n  /** JSDoc */\n    __init6() {this._executeHandlers = () => {\n    if (this._state === States.PENDING) {\n      return;\n    }\n\n    var cachedHandlers = this._handlers.slice();\n    this._handlers = [];\n\n    cachedHandlers.forEach(handler => {\n      if (handler[0]) {\n        return;\n      }\n\n      if (this._state === States.RESOLVED) {\n                handler[1](this._value );\n      }\n\n      if (this._state === States.REJECTED) {\n        handler[2](this._value);\n      }\n\n      handler[0] = true;\n    });\n  };}\n}\n\nexport { SyncPromise, rejectedSyncPromise, resolvedSyncPromise };\n//# sourceMappingURL=syncpromise.js.map\n","import { getGlobalObject } from './global.js';\nimport { dynamicRequire, isNodeEnv } from './node.js';\n\n/**\n * An object that can return the current timestamp in seconds since the UNIX epoch.\n */\n\n/**\n * A TimestampSource implementation for environments that do not support the Performance Web API natively.\n *\n * Note that this TimestampSource does not use a monotonic clock. A call to `nowSeconds` may return a timestamp earlier\n * than a previously returned value. We do not try to emulate a monotonic behavior in order to facilitate debugging. It\n * is more obvious to explain \"why does my span have negative duration\" than \"why my spans have zero duration\".\n */\nvar dateTimestampSource = {\n  nowSeconds: () => Date.now() / 1000,\n};\n\n/**\n * A partial definition of the [Performance Web API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance}\n * for accessing a high-resolution monotonic clock.\n */\n\n/**\n * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not\n * support the API.\n *\n * Wrapping the native API works around differences in behavior from different browsers.\n */\nfunction getBrowserPerformance() {\n  const { performance } = getGlobalObject();\n  if (!performance || !performance.now) {\n    return undefined;\n  }\n\n  // Replace performance.timeOrigin with our own timeOrigin based on Date.now().\n  //\n  // This is a partial workaround for browsers reporting performance.timeOrigin such that performance.timeOrigin +\n  // performance.now() gives a date arbitrarily in the past.\n  //\n  // Additionally, computing timeOrigin in this way fills the gap for browsers where performance.timeOrigin is\n  // undefined.\n  //\n  // The assumption that performance.timeOrigin + performance.now() ~= Date.now() is flawed, but we depend on it to\n  // interact with data coming out of performance entries.\n  //\n  // Note that despite recommendations against it in the spec, browsers implement the Performance API with a clock that\n  // might stop when the computer is asleep (and perhaps under other circumstances). Such behavior causes\n  // performance.timeOrigin + performance.now() to have an arbitrary skew over Date.now(). In laptop computers, we have\n  // observed skews that can be as long as days, weeks or months.\n  //\n  // See https://github.com/getsentry/sentry-javascript/issues/2590.\n  //\n  // BUG: despite our best intentions, this workaround has its limitations. It mostly addresses timings of pageload\n  // transactions, but ignores the skew built up over time that can aversely affect timestamps of navigation\n  // transactions of long-lived web pages.\n  var timeOrigin = Date.now() - performance.now();\n\n  return {\n    now: () => performance.now(),\n    timeOrigin,\n  };\n}\n\n/**\n * Returns the native Performance API implementation from Node.js. Returns undefined in old Node.js versions that don't\n * implement the API.\n */\nfunction getNodePerformance() {\n  try {\n    var perfHooks = dynamicRequire(module, 'perf_hooks') ;\n    return perfHooks.performance;\n  } catch (_) {\n    return undefined;\n  }\n}\n\n/**\n * The Performance API implementation for the current platform, if available.\n */\nvar platformPerformance = isNodeEnv() ? getNodePerformance() : getBrowserPerformance();\n\nvar timestampSource =\n  platformPerformance === undefined\n    ? dateTimestampSource\n    : {\n        nowSeconds: () => (platformPerformance.timeOrigin + platformPerformance.now()) / 1000,\n      };\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using the Date API.\n */\nvar dateTimestampInSeconds = dateTimestampSource.nowSeconds.bind(dateTimestampSource);\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the\n * availability of the Performance API.\n *\n * See `usingPerformanceAPI` to test whether the Performance API is used.\n *\n * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is\n * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The\n * skew can grow to arbitrary amounts like days, weeks or months.\n * See https://github.com/getsentry/sentry-javascript/issues/2590.\n */\nvar timestampInSeconds = timestampSource.nowSeconds.bind(timestampSource);\n\n// Re-exported with an old name for backwards-compatibility.\nvar timestampWithMs = timestampInSeconds;\n\n/**\n * A boolean that is true when timestampInSeconds uses the Performance API to produce monotonic timestamps.\n */\nvar usingPerformanceAPI = platformPerformance !== undefined;\n\n/**\n * Internal helper to store what is the source of browserPerformanceTimeOrigin below. For debugging only.\n */\nlet _browserPerformanceTimeOriginMode;\n\n/**\n * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the\n * performance API is available.\n */\nvar browserPerformanceTimeOrigin = (() => {\n  // Unfortunately browsers may report an inaccurate time origin data, through either performance.timeOrigin or\n  // performance.timing.navigationStart, which results in poor results in performance data. We only treat time origin\n  // data as reliable if they are within a reasonable threshold of the current time.\n\n  const { performance } = getGlobalObject();\n  if (!performance || !performance.now) {\n    _browserPerformanceTimeOriginMode = 'none';\n    return undefined;\n  }\n\n  var threshold = 3600 * 1000;\n  var performanceNow = performance.now();\n  var dateNow = Date.now();\n\n  // if timeOrigin isn't available set delta to threshold so it isn't used\n  var timeOriginDelta = performance.timeOrigin\n    ? Math.abs(performance.timeOrigin + performanceNow - dateNow)\n    : threshold;\n  var timeOriginIsReliable = timeOriginDelta < threshold;\n\n  // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin\n  // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.\n  // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always\n  // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the\n  // Date API.\n    var navigationStart = performance.timing && performance.timing.navigationStart;\n  var hasNavigationStart = typeof navigationStart === 'number';\n  // if navigationStart isn't available set delta to threshold so it isn't used\n  var navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;\n  var navigationStartIsReliable = navigationStartDelta < threshold;\n\n  if (timeOriginIsReliable || navigationStartIsReliable) {\n    // Use the more reliable time origin\n    if (timeOriginDelta <= navigationStartDelta) {\n      _browserPerformanceTimeOriginMode = 'timeOrigin';\n      return performance.timeOrigin;\n    } else {\n      _browserPerformanceTimeOriginMode = 'navigationStart';\n      return navigationStart;\n    }\n  }\n\n  // Either both timeOrigin and navigationStart are skewed or neither is available, fallback to Date.\n  _browserPerformanceTimeOriginMode = 'dateNow';\n  return dateNow;\n})();\n\nexport { _browserPerformanceTimeOriginMode, browserPerformanceTimeOrigin, dateTimestampInSeconds, timestampInSeconds, timestampWithMs, usingPerformanceAPI };\n//# sourceMappingURL=time.js.map\n","/**\n * Parses string form of URL into an object\n * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B\n * // intentionally using regex and not <a/> href parsing trick because React Native and other\n * // environments where DOM might not be available\n * @returns parsed URL object\n */\nfunction parseUrl(url)\n\n {\n  if (!url) {\n    return {};\n  }\n\n  var match = url.match(/^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/);\n\n  if (!match) {\n    return {};\n  }\n\n  // coerce to undefined values to empty string so we don't get 'undefined'\n  var query = match[6] || '';\n  var fragment = match[8] || '';\n  return {\n    host: match[4],\n    path: match[5],\n    protocol: match[2],\n    relative: match[5] + query + fragment, // everything minus origin\n  };\n}\n\n/**\n * Strip the query string and fragment off of a given URL or path (if present)\n *\n * @param urlPath Full URL or path, including possible query string and/or fragment\n * @returns URL or path without query string or fragment\n */\nfunction stripUrlQueryAndFragment(urlPath) {\n    return urlPath.split(/[\\?#]/, 1)[0];\n}\n\n/**\n * Returns number of URL segments of a passed string URL.\n */\nfunction getNumberOfUrlSegments(url) {\n  // split at '/' or at '\\/' to split regex urls correctly\n  return url.split(/\\\\?\\//).filter(s => s.length > 0 && s !== ',').length;\n}\n\nexport { getNumberOfUrlSegments, parseUrl, stripUrlQueryAndFragment };\n//# sourceMappingURL=url.js.map\n","var _global = (typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {}); _global.SENTRY_RELEASE={id:\"SKJ_I6npCnjx16Vr40v84\"};","\"use strict\";\nvar ref, ref1;\nmodule.exports = ((ref = global.process) == null ? void 0 : ref.env) && typeof ((ref1 = global.process) == null ? void 0 : ref1.env) === \"object\" ? global.process : require(\"../../compiled/process\");\n\n//# sourceMappingURL=process.js.map","\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_app\",\n      function () {\n        return require(\"next/dist/pages/_app\");\n      }\n    ]);\n    if(module.hot) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_app\"])\n      });\n    }\n  ","var SDK_VERSION = '7.13.0';\n\nexport { SDK_VERSION };\n//# sourceMappingURL=version.js.map\n","import { logger, getEventDescription, isMatchingPattern } from '@sentry/utils';\n\n// \"Script error.\" is hard coded into browsers for errors that it can't read.\n// this is the result of a script being pulled in from an external domain and CORS.\nvar DEFAULT_IGNORE_ERRORS = [/^Script error\\.?$/, /^Javascript error: Script error\\.? on line 0$/];\n\n/** Options for the InboundFilters integration */\n\n/** Inbound filters configurable by the user */\nclass InboundFilters  {\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'InboundFilters';}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = InboundFilters.id;}\n\n   constructor(  _options = {}) {;this._options = _options;InboundFilters.prototype.__init.call(this);}\n\n  /**\n   * @inheritDoc\n   */\n   setupOnce(addGlobalEventProcessor, getCurrentHub) {\n    var eventProcess = (event) => {\n      var hub = getCurrentHub();\n      if (hub) {\n        var self = hub.getIntegration(InboundFilters);\n        if (self) {\n          var client = hub.getClient();\n          var clientOptions = client ? client.getOptions() : {};\n          var options = _mergeOptions(self._options, clientOptions);\n          return _shouldDropEvent(event, options) ? null : event;\n        }\n      }\n      return event;\n    };\n\n    eventProcess.id = this.name;\n    addGlobalEventProcessor(eventProcess);\n  }\n} InboundFilters.__initStatic();\n\n/** JSDoc */\nfunction _mergeOptions(\n  internalOptions = {},\n  clientOptions = {},\n) {\n  return {\n    allowUrls: [...(internalOptions.allowUrls || []), ...(clientOptions.allowUrls || [])],\n    denyUrls: [...(internalOptions.denyUrls || []), ...(clientOptions.denyUrls || [])],\n    ignoreErrors: [\n      ...(internalOptions.ignoreErrors || []),\n      ...(clientOptions.ignoreErrors || []),\n      ...DEFAULT_IGNORE_ERRORS,\n    ],\n    ignoreInternal: internalOptions.ignoreInternal !== undefined ? internalOptions.ignoreInternal : true,\n  };\n}\n\n/** JSDoc */\nfunction _shouldDropEvent(event, options) {\n  if (options.ignoreInternal && _isSentryError(event)) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.warn(`Event dropped due to being internal Sentry Error.\\nEvent: ${getEventDescription(event)}`);\n    return true;\n  }\n  if (_isIgnoredError(event, options.ignoreErrors)) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.warn(\n        `Event dropped due to being matched by \\`ignoreErrors\\` option.\\nEvent: ${getEventDescription(event)}`,\n      );\n    return true;\n  }\n  if (_isDeniedUrl(event, options.denyUrls)) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.warn(\n        `Event dropped due to being matched by \\`denyUrls\\` option.\\nEvent: ${getEventDescription(\n          event,\n        )}.\\nUrl: ${_getEventFilterUrl(event)}`,\n      );\n    return true;\n  }\n  if (!_isAllowedUrl(event, options.allowUrls)) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.warn(\n        `Event dropped due to not being matched by \\`allowUrls\\` option.\\nEvent: ${getEventDescription(\n          event,\n        )}.\\nUrl: ${_getEventFilterUrl(event)}`,\n      );\n    return true;\n  }\n  return false;\n}\n\nfunction _isIgnoredError(event, ignoreErrors) {\n  if (!ignoreErrors || !ignoreErrors.length) {\n    return false;\n  }\n\n  return _getPossibleEventMessages(event).some(message =>\n    ignoreErrors.some(pattern => isMatchingPattern(message, pattern)),\n  );\n}\n\nfunction _isDeniedUrl(event, denyUrls) {\n  // TODO: Use Glob instead?\n  if (!denyUrls || !denyUrls.length) {\n    return false;\n  }\n  var url = _getEventFilterUrl(event);\n  return !url ? false : denyUrls.some(pattern => isMatchingPattern(url, pattern));\n}\n\nfunction _isAllowedUrl(event, allowUrls) {\n  // TODO: Use Glob instead?\n  if (!allowUrls || !allowUrls.length) {\n    return true;\n  }\n  var url = _getEventFilterUrl(event);\n  return !url ? true : allowUrls.some(pattern => isMatchingPattern(url, pattern));\n}\n\nfunction _getPossibleEventMessages(event) {\n  if (event.message) {\n    return [event.message];\n  }\n  if (event.exception) {\n    try {\n      const { type = '', value = '' } = (event.exception.values && event.exception.values[0]) || {};\n      return [`${value}`, `${type}: ${value}`];\n    } catch (oO) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error(`Cannot extract message for event ${getEventDescription(event)}`);\n      return [];\n    }\n  }\n  return [];\n}\n\nfunction _isSentryError(event) {\n  try {\n    // @ts-ignore can't be a sentry error if undefined\n        return event.exception.values[0].type === 'SentryError';\n  } catch (e) {\n    // ignore\n  }\n  return false;\n}\n\nfunction _getLastValidUrl(frames = []) {\n  for (let i = frames.length - 1; i >= 0; i--) {\n    var frame = frames[i];\n\n    if (frame && frame.filename !== '<anonymous>' && frame.filename !== '[native code]') {\n      return frame.filename || null;\n    }\n  }\n\n  return null;\n}\n\nfunction _getEventFilterUrl(event) {\n  try {\n    let frames;\n    try {\n      // @ts-ignore we only care about frames if the whole thing here is defined\n      frames = event.exception.values[0].stacktrace.frames;\n    } catch (e) {\n      // ignore\n    }\n    return frames ? _getLastValidUrl(frames) : null;\n  } catch (oO) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error(`Cannot extract url for event ${getEventDescription(event)}`);\n    return null;\n  }\n}\n\nexport { InboundFilters, _mergeOptions, _shouldDropEvent };\n//# sourceMappingURL=inboundfilters.js.map\n","import { getOriginalFunction } from '@sentry/utils';\n\nlet originalFunctionToString;\n\n/** Patch toString calls to return proper name for wrapped functions */\nclass FunctionToString  {constructor() { FunctionToString.prototype.__init.call(this); }\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'FunctionToString';}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = FunctionToString.id;}\n\n  /**\n   * @inheritDoc\n   */\n   setupOnce() {\n        originalFunctionToString = Function.prototype.toString;\n\n        Function.prototype.toString = function ( ...args) {\n      var context = getOriginalFunction(this) || this;\n      return originalFunctionToString.apply(context, args);\n    };\n  }\n} FunctionToString.__initStatic();\n\nexport { FunctionToString };\n//# sourceMappingURL=functiontostring.js.map\n","import { addGlobalEventProcessor, getCurrentHub } from '@sentry/hub';\nimport { arrayify, logger } from '@sentry/utils';\n\nvar installedIntegrations = [];\n\n/** Map of integrations assigned to a client */\n\n/**\n * Remove duplicates from the given array, preferring the last instance of any duplicate. Not guaranteed to\n * preseve the order of integrations in the array.\n *\n * @private\n */\nfunction filterDuplicates(integrations) {\n  var integrationsByName = {};\n\n  integrations.forEach(currentInstance => {\n    const { name } = currentInstance;\n\n    var existingInstance = integrationsByName[name];\n\n    // We want integrations later in the array to overwrite earlier ones of the same type, except that we never want a\n    // default instance to overwrite an existing user instance\n    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {\n      return;\n    }\n\n    integrationsByName[name] = currentInstance;\n  });\n\n  return Object.values(integrationsByName);\n}\n\n/** Gets integrations to install */\nfunction getIntegrationsToSetup(options) {\n  var defaultIntegrations = options.defaultIntegrations || [];\n  var userIntegrations = options.integrations;\n\n  // We flag default instances, so that later we can tell them apart from any user-created instances of the same class\n  defaultIntegrations.forEach(integration => {\n    integration.isDefaultInstance = true;\n  });\n\n  let integrations;\n\n  if (Array.isArray(userIntegrations)) {\n    integrations = [...defaultIntegrations, ...userIntegrations];\n  } else if (typeof userIntegrations === 'function') {\n    integrations = arrayify(userIntegrations(defaultIntegrations));\n  } else {\n    integrations = defaultIntegrations;\n  }\n\n  var finalIntegrations = filterDuplicates(integrations);\n\n  // The `Debug` integration prints copies of the `event` and `hint` which will be passed to `beforeSend`. It therefore\n  // has to run after all other integrations, so that the changes of all event processors will be reflected in the\n  // printed values. For lack of a more elegant way to guarantee that, we therefore locate it and, assuming it exists,\n  // pop it out of its current spot and shove it onto the end of the array.\n  var debugIndex = finalIntegrations.findIndex(integration => integration.name === 'Debug');\n  if (debugIndex !== -1) {\n    const [debugInstance] = finalIntegrations.splice(debugIndex, 1);\n    finalIntegrations.push(debugInstance);\n  }\n\n  return finalIntegrations;\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nfunction setupIntegrations(integrations) {\n  var integrationIndex = {};\n\n  integrations.forEach(integration => {\n    integrationIndex[integration.name] = integration;\n\n    if (installedIntegrations.indexOf(integration.name) === -1) {\n      integration.setupOnce(addGlobalEventProcessor, getCurrentHub);\n      installedIntegrations.push(integration.name);\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`Integration installed: ${integration.name}`);\n    }\n  });\n\n  return integrationIndex;\n}\n\nexport { getIntegrationsToSetup, installedIntegrations, setupIntegrations };\n//# sourceMappingURL=integration.js.map\n","import { getCurrentHub } from '@sentry/hub';\nimport { logger } from '@sentry/utils';\n\n/** A class object that can instantiate Client objects. */\n\n/**\n * Internal function to create a new SDK client instance. The client is\n * installed and then bound to the current scope.\n *\n * @param clientClass The client class to instantiate.\n * @param options Options to pass to the client.\n */\nfunction initAndBind(\n  clientClass,\n  options,\n) {\n  if (options.debug === true) {\n    if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {\n      logger.enable();\n    } else {\n      // use `console.warn` rather than `logger.warn` since by non-debug bundles have all `logger.x` statements stripped\n            console.warn('[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.');\n    }\n  }\n  var hub = getCurrentHub();\n  var scope = hub.getScope();\n  if (scope) {\n    scope.update(options.initialScope);\n  }\n\n  var client = new clientClass(options);\n  hub.bindClient(client);\n}\n\nexport { initAndBind };\n//# sourceMappingURL=sdk.js.map\n","/** An error emitted by Sentry SDKs and related utilities. */\nclass SentryError extends Error {\n  /** Display name of this error instance. */\n  \n\n   constructor( message, logLevel = 'warn') {\n    super(message);this.message = message;;\n\n    this.name = new.target.prototype.constructor.name;\n    // This sets the prototype to be `Error`, not `SentryError`. It's unclear why we do this, but commenting this line\n    // out causes various (seemingly totally unrelated) playwright tests consistently time out. FYI, this makes\n    // instances of `SentryError` fail `obj instanceof SentryError` checks.\n    Object.setPrototypeOf(this, new.target.prototype);\n    this.logLevel = logLevel;\n  }\n}\n\nexport { SentryError };\n//# sourceMappingURL=error.js.map\n","import { SentryError } from './error.js';\n\n/** Regular expression used to parse a Dsn. */\nvar DSN_REGEX = /^(?:(\\w+):)\\/\\/(?:(\\w+)(?::(\\w+))?@)([\\w.-]+)(?::(\\d+))?\\/(.+)/;\n\nfunction isValidProtocol(protocol) {\n  return protocol === 'http' || protocol === 'https';\n}\n\n/**\n * Renders the string representation of this Dsn.\n *\n * By default, this will render the public representation without the password\n * component. To get the deprecated private representation, set `withPassword`\n * to true.\n *\n * @param withPassword When set to true, the password will be included.\n */\nfunction dsnToString(dsn, withPassword = false) {\n  const { host, path, pass, port, projectId, protocol, publicKey } = dsn;\n  return (\n    `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ''}` +\n    `@${host}${port ? `:${port}` : ''}/${path ? `${path}/` : path}${projectId}`\n  );\n}\n\n/**\n * Parses a Dsn from a given string.\n *\n * @param str A Dsn as string\n * @returns Dsn as DsnComponents\n */\nfunction dsnFromString(str) {\n  var match = DSN_REGEX.exec(str);\n\n  if (!match) {\n    throw new SentryError(`Invalid Sentry Dsn: ${str}`);\n  }\n\n  const [protocol, publicKey, pass = '', host, port = '', lastPath] = match.slice(1);\n  let path = '';\n  let projectId = lastPath;\n\n  var split = projectId.split('/');\n  if (split.length > 1) {\n    path = split.slice(0, -1).join('/');\n    projectId = split.pop() ;\n  }\n\n  if (projectId) {\n    var projectMatch = projectId.match(/^\\d+/);\n    if (projectMatch) {\n      projectId = projectMatch[0];\n    }\n  }\n\n  return dsnFromComponents({ host, pass, path, projectId, port, protocol: protocol , publicKey });\n}\n\nfunction dsnFromComponents(components) {\n  return {\n    protocol: components.protocol,\n    publicKey: components.publicKey || '',\n    pass: components.pass || '',\n    host: components.host,\n    port: components.port || '',\n    path: components.path || '',\n    projectId: components.projectId,\n  };\n}\n\nfunction validateDsn(dsn) {\n  if (!(typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {\n    return;\n  }\n\n  const { port, projectId, protocol } = dsn;\n\n  var requiredComponents = ['protocol', 'publicKey', 'host', 'projectId'];\n  requiredComponents.forEach(component => {\n    if (!dsn[component]) {\n      throw new SentryError(`Invalid Sentry Dsn: ${component} missing`);\n    }\n  });\n\n  if (!projectId.match(/^\\d+$/)) {\n    throw new SentryError(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);\n  }\n\n  if (!isValidProtocol(protocol)) {\n    throw new SentryError(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);\n  }\n\n  if (port && isNaN(parseInt(port, 10))) {\n    throw new SentryError(`Invalid Sentry Dsn: Invalid port ${port}`);\n  }\n\n  return true;\n}\n\n/** The Sentry Dsn, identifying a Sentry instance and project. */\nfunction makeDsn(from) {\n  var components = typeof from === 'string' ? dsnFromString(from) : dsnFromComponents(from);\n  validateDsn(components);\n  return components;\n}\n\nexport { dsnFromString, dsnToString, makeDsn };\n//# sourceMappingURL=dsn.js.map\n","import { dropUndefinedKeys } from './object.js';\n\n/**\n * Creates an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nfunction createEnvelope(headers, items = []) {\n  return [headers, items] ;\n}\n\n/**\n * Add an item to an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nfunction addItemToEnvelope(envelope, newItem) {\n  const [headers, items] = envelope;\n  return [headers, [...items, newItem]] ;\n}\n\n/**\n * Convenience function to loop through the items and item types of an envelope.\n * (This function was mostly created because working with envelope types is painful at the moment)\n */\nfunction forEachEnvelopeItem(\n  envelope,\n  callback,\n) {\n  var envelopeItems = envelope[1];\n  envelopeItems.forEach((envelopeItem) => {\n    var envelopeItemType = envelopeItem[0].type;\n    callback(envelopeItem, envelopeItemType);\n  });\n}\n\nfunction encodeUTF8(input, textEncoder) {\n  var utf8 = textEncoder || new TextEncoder();\n  return utf8.encode(input);\n}\n\n/**\n * Serializes an envelope.\n */\nfunction serializeEnvelope(envelope, textEncoder) {\n  const [envHeaders, items] = envelope;\n\n  // Initially we construct our envelope as a string and only convert to binary chunks if we encounter binary data\n  let parts = JSON.stringify(envHeaders);\n\n  function append(next) {\n    if (typeof parts === 'string') {\n      parts = typeof next === 'string' ? parts + next : [encodeUTF8(parts, textEncoder), next];\n    } else {\n      parts.push(typeof next === 'string' ? encodeUTF8(next, textEncoder) : next);\n    }\n  }\n\n  for (var item of items) {\n    const [itemHeaders, payload] = item ;\n    append(`\\n${JSON.stringify(itemHeaders)}\\n`);\n    append(typeof payload === 'string' || payload instanceof Uint8Array ? payload : JSON.stringify(payload));\n  }\n\n  return typeof parts === 'string' ? parts : concatBuffers(parts);\n}\n\nfunction concatBuffers(buffers) {\n  var totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);\n\n  var merged = new Uint8Array(totalLength);\n  let offset = 0;\n  for (var buffer of buffers) {\n    merged.set(buffer, offset);\n    offset += buffer.length;\n  }\n\n  return merged;\n}\n\n/**\n * Creates attachment envelope items\n */\nfunction createAttachmentEnvelopeItem(\n  attachment,\n  textEncoder,\n) {\n  var buffer = typeof attachment.data === 'string' ? encodeUTF8(attachment.data, textEncoder) : attachment.data;\n\n  return [\n    dropUndefinedKeys({\n      type: 'attachment',\n      length: buffer.length,\n      filename: attachment.filename,\n      content_type: attachment.contentType,\n      attachment_type: attachment.attachmentType,\n    }),\n    buffer,\n  ];\n}\n\nvar ITEM_TYPE_TO_DATA_CATEGORY_MAP = {\n  session: 'session',\n  sessions: 'session',\n  attachment: 'attachment',\n  transaction: 'transaction',\n  event: 'error',\n  client_report: 'internal',\n  user_report: 'default',\n};\n\n/**\n * Maps the type of an envelope item to a data category.\n */\nfunction envelopeItemTypeToDataCategory(type) {\n  return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];\n}\n\nexport { addItemToEnvelope, createAttachmentEnvelopeItem, createEnvelope, envelopeItemTypeToDataCategory, forEachEnvelopeItem, serializeEnvelope };\n//# sourceMappingURL=envelope.js.map\n","import { urlEncode, makeDsn, dsnToString } from '@sentry/utils';\n\nvar SENTRY_API_VERSION = '7';\n\n/** Returns the prefix to construct Sentry ingestion API endpoints. */\nfunction getBaseApiEndpoint(dsn) {\n  var protocol = dsn.protocol ? `${dsn.protocol}:` : '';\n  var port = dsn.port ? `:${dsn.port}` : '';\n  return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ''}/api/`;\n}\n\n/** Returns the ingest API endpoint for target. */\nfunction _getIngestEndpoint(dsn) {\n  return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/envelope/`;\n}\n\n/** Returns a URL-encoded string with auth config suitable for a query string. */\nfunction _encodedAuth(dsn, sdkInfo) {\n  return urlEncode({\n    // We send only the minimum set of required information. See\n    // https://github.com/getsentry/sentry-javascript/issues/2572.\n    sentry_key: dsn.publicKey,\n    sentry_version: SENTRY_API_VERSION,\n    ...(sdkInfo && { sentry_client: `${sdkInfo.name}/${sdkInfo.version}` }),\n  });\n}\n\n/**\n * Returns the envelope endpoint URL with auth in the query string.\n *\n * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.\n */\nfunction getEnvelopeEndpointWithUrlEncodedAuth(\n  dsn,\n  // TODO (v8): Remove `tunnelOrOptions` in favor of `options`, and use the substitute code below\n  // options: ClientOptions = {} as ClientOptions,\n  tunnelOrOptions = {} ,\n) {\n  // TODO (v8): Use this code instead\n  // const { tunnel, _metadata = {} } = options;\n  // return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, _metadata.sdk)}`;\n\n  var tunnel = typeof tunnelOrOptions === 'string' ? tunnelOrOptions : tunnelOrOptions.tunnel;\n  var sdkInfo =\n    typeof tunnelOrOptions === 'string' || !tunnelOrOptions._metadata ? undefined : tunnelOrOptions._metadata.sdk;\n\n  return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, sdkInfo)}`;\n}\n\n/** Returns the url to the report dialog endpoint. */\nfunction getReportDialogEndpoint(\n  dsnLike,\n  dialogOptions\n\n,\n) {\n  var dsn = makeDsn(dsnLike);\n  var endpoint = `${getBaseApiEndpoint(dsn)}embed/error-page/`;\n\n  let encodedOptions = `dsn=${dsnToString(dsn)}`;\n  for (var key in dialogOptions) {\n    if (key === 'dsn') {\n      continue;\n    }\n\n    if (key === 'user') {\n      var user = dialogOptions.user;\n      if (!user) {\n        continue;\n      }\n      if (user.name) {\n        encodedOptions += `&name=${encodeURIComponent(user.name)}`;\n      }\n      if (user.email) {\n        encodedOptions += `&email=${encodeURIComponent(user.email)}`;\n      }\n    } else {\n      encodedOptions += `&${encodeURIComponent(key)}=${encodeURIComponent(dialogOptions[key] )}`;\n    }\n  }\n\n  return `${endpoint}?${encodedOptions}`;\n}\n\nexport { getEnvelopeEndpointWithUrlEncodedAuth, getReportDialogEndpoint };\n//# sourceMappingURL=api.js.map\n","import { dsnToString, createEnvelope, dropUndefinedKeys } from '@sentry/utils';\n\n/** Extract sdk info from from the API metadata */\nfunction getSdkMetadataForEnvelopeHeader(metadata) {\n  if (!metadata || !metadata.sdk) {\n    return;\n  }\n  const { name, version } = metadata.sdk;\n  return { name, version };\n}\n\n/**\n * Apply SdkInfo (name, version, packages, integrations) to the corresponding event key.\n * Merge with existing data if any.\n **/\nfunction enhanceEventWithSdkInfo(event, sdkInfo) {\n  if (!sdkInfo) {\n    return event;\n  }\n  event.sdk = event.sdk || {};\n  event.sdk.name = event.sdk.name || sdkInfo.name;\n  event.sdk.version = event.sdk.version || sdkInfo.version;\n  event.sdk.integrations = [...(event.sdk.integrations || []), ...(sdkInfo.integrations || [])];\n  event.sdk.packages = [...(event.sdk.packages || []), ...(sdkInfo.packages || [])];\n  return event;\n}\n\n/** Creates an envelope from a Session */\nfunction createSessionEnvelope(\n  session,\n  dsn,\n  metadata,\n  tunnel,\n) {\n  var sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);\n  var envelopeHeaders = {\n    sent_at: new Date().toISOString(),\n    ...(sdkInfo && { sdk: sdkInfo }),\n    ...(!!tunnel && { dsn: dsnToString(dsn) }),\n  };\n\n  var envelopeItem =\n    'aggregates' in session ? [{ type: 'sessions' }, session] : [{ type: 'session' }, session];\n\n  return createEnvelope(envelopeHeaders, [envelopeItem]);\n}\n\n/**\n * Create an Envelope from an event.\n */\nfunction createEventEnvelope(\n  event,\n  dsn,\n  metadata,\n  tunnel,\n) {\n  var sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);\n  var eventType = event.type || 'event';\n\n  const { transactionSampling } = event.sdkProcessingMetadata || {};\n  const { method: samplingMethod, rate: sampleRate } = transactionSampling || {};\n\n  enhanceEventWithSdkInfo(event, metadata && metadata.sdk);\n\n  var envelopeHeaders = createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);\n\n  // Prevent this data (which, if it exists, was used in earlier steps in the processing pipeline) from being sent to\n  // sentry. (Note: Our use of this property comes and goes with whatever we might be debugging, whatever hacks we may\n  // have temporarily added, etc. Even if we don't happen to be using it at some point in the future, let's not get rid\n  // of this `delete`, lest we miss putting it back in the next time the property is in use.)\n  delete event.sdkProcessingMetadata;\n\n  var eventItem = [\n    {\n      type: eventType,\n      sample_rates: [{ id: samplingMethod, rate: sampleRate }],\n    },\n    event,\n  ];\n  return createEnvelope(envelopeHeaders, [eventItem]);\n}\n\nfunction createEventEnvelopeHeaders(\n  event,\n  sdkInfo,\n  tunnel,\n  dsn,\n) {\n  var dynamicSamplingContext = event.sdkProcessingMetadata && event.sdkProcessingMetadata.dynamicSamplingContext;\n\n  return {\n    event_id: event.event_id ,\n    sent_at: new Date().toISOString(),\n    ...(sdkInfo && { sdk: sdkInfo }),\n    ...(!!tunnel && { dsn: dsnToString(dsn) }),\n    ...(event.type === 'transaction' &&\n      dynamicSamplingContext && {\n        trace: dropUndefinedKeys({ ...dynamicSamplingContext }),\n      }),\n  };\n}\n\nexport { createEventEnvelope, createSessionEnvelope };\n//# sourceMappingURL=envelope.js.map\n","import { updateSession, Scope } from '@sentry/hub';\nimport { makeDsn, logger, checkOrSetAlreadyCaught, isPrimitive, resolvedSyncPromise, addItemToEnvelope, createAttachmentEnvelopeItem, SyncPromise, uuid4, dateTimestampInSeconds, normalize, truncate, rejectedSyncPromise, SentryError, isThenable, isPlainObject } from '@sentry/utils';\nimport { getEnvelopeEndpointWithUrlEncodedAuth } from './api.js';\nimport { createEventEnvelope, createSessionEnvelope } from './envelope.js';\nimport { setupIntegrations } from './integration.js';\n\nvar ALREADY_SEEN_ERROR = \"Not capturing exception because it's already been captured.\";\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event, it is passed through\n * {@link BaseClient._prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(options);\n *   }\n *\n *   // ...\n * }\n */\nclass BaseClient {\n  /** Options passed to the SDK. */\n  \n\n  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n  \n\n  /** Array of set up integrations. */\n   __init() {this._integrations = {};}\n\n  /** Indicates whether this client's integrations have been set up. */\n   __init2() {this._integrationsInitialized = false;}\n\n  /** Number of calls being processed */\n   __init3() {this._numProcessing = 0;}\n\n  /** Holds flushable  */\n   __init4() {this._outcomes = {};}\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param options Options for the client.\n   */\n   constructor(options) {;BaseClient.prototype.__init.call(this);BaseClient.prototype.__init2.call(this);BaseClient.prototype.__init3.call(this);BaseClient.prototype.__init4.call(this);\n    this._options = options;\n    if (options.dsn) {\n      this._dsn = makeDsn(options.dsn);\n      var url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options);\n      this._transport = options.transport({\n        recordDroppedEvent: this.recordDroppedEvent.bind(this),\n        ...options.transportOptions,\n        url,\n      });\n    } else {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('No DSN provided, client will not do anything.');\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n     captureException(exception, hint, scope) {\n    // ensure we haven't captured this very object before\n    if (checkOrSetAlreadyCaught(exception)) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n\n    let eventId = hint && hint.event_id;\n\n    this._process(\n      this.eventFromException(exception, hint)\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureMessage(\n    message,\n        level,\n    hint,\n    scope,\n  ) {\n    let eventId = hint && hint.event_id;\n\n    var promisedEvent = isPrimitive(message)\n      ? this.eventFromMessage(String(message), level, hint)\n      : this.eventFromException(message, hint);\n\n    this._process(\n      promisedEvent\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureEvent(event, hint, scope) {\n    // ensure we haven't captured this very object before\n    if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n\n    let eventId = hint && hint.event_id;\n\n    this._process(\n      this._captureEvent(event, hint, scope).then(result => {\n        eventId = result;\n      }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureSession(session) {\n    if (!this._isEnabled()) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('SDK not enabled, will not capture session.');\n      return;\n    }\n\n    if (!(typeof session.release === 'string')) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Discarded session because of missing or non-string release');\n    } else {\n      this.sendSession(session);\n      // After sending, we set init false to indicate it's not the first occurrence\n      updateSession(session, { init: false });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getDsn() {\n    return this._dsn;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getOptions() {\n    return this._options;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getTransport() {\n    return this._transport;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   flush(timeout) {\n    var transport = this._transport;\n    if (transport) {\n      return this._isClientDoneProcessing(timeout).then(clientFinished => {\n        return transport.flush(timeout).then(transportFlushed => clientFinished && transportFlushed);\n      });\n    } else {\n      return resolvedSyncPromise(true);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   close(timeout) {\n    return this.flush(timeout).then(result => {\n      this.getOptions().enabled = false;\n      return result;\n    });\n  }\n\n  /**\n   * Sets up the integrations\n   */\n   setupIntegrations() {\n    if (this._isEnabled() && !this._integrationsInitialized) {\n      this._integrations = setupIntegrations(this._options.integrations);\n      this._integrationsInitialized = true;\n    }\n  }\n\n  /**\n   * Gets an installed integration by its `id`.\n   *\n   * @returns The installed integration or `undefined` if no integration with that `id` was installed.\n   */\n   getIntegrationById(integrationId) {\n    return this._integrations[integrationId];\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getIntegration(integration) {\n    try {\n      return (this._integrations[integration.id] ) || null;\n    } catch (_oO) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`);\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   sendEvent(event, hint = {}) {\n    if (this._dsn) {\n      let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);\n\n      for (var attachment of hint.attachments || []) {\n        env = addItemToEnvelope(\n          env,\n          createAttachmentEnvelopeItem(\n            attachment,\n            this._options.transportOptions && this._options.transportOptions.textEncoder,\n          ),\n        );\n      }\n\n      this._sendEnvelope(env);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   sendSession(session) {\n    if (this._dsn) {\n      var env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);\n      this._sendEnvelope(env);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   recordDroppedEvent(reason, category) {\n    if (this._options.sendClientReports) {\n      // We want to track each category (error, transaction, session) separately\n      // but still keep the distinction between different type of outcomes.\n      // We could use nested maps, but it's much easier to read and type this way.\n      // A correct type for map-based implementation if we want to go that route\n      // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n      // With typescript 4.1 we could even use template literal types\n      var key = `${reason}:${category}`;\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`Adding outcome: \"${key}\"`);\n\n      // The following works because undefined + 1 === NaN and NaN is falsy\n      this._outcomes[key] = this._outcomes[key] + 1 || 1;\n    }\n  }\n\n  /** Updates existing session based on the provided event */\n   _updateSessionFromEvent(session, event) {\n    let crashed = false;\n    let errored = false;\n    var exceptions = event.exception && event.exception.values;\n\n    if (exceptions) {\n      errored = true;\n\n      for (var ex of exceptions) {\n        var mechanism = ex.mechanism;\n        if (mechanism && mechanism.handled === false) {\n          crashed = true;\n          break;\n        }\n      }\n    }\n\n    // A session is updated and that session update is sent in only one of the two following scenarios:\n    // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update\n    // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update\n    var sessionNonTerminal = session.status === 'ok';\n    var shouldUpdateAndSend = (sessionNonTerminal && session.errors === 0) || (sessionNonTerminal && crashed);\n\n    if (shouldUpdateAndSend) {\n      updateSession(session, {\n        ...(crashed && { status: 'crashed' }),\n        errors: session.errors || Number(errored || crashed),\n      });\n      this.captureSession(session);\n    }\n  }\n\n  /**\n   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying\n   * \"no\" (resolving to `false`) in order to give the client a chance to potentially finish first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not\n   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and\n   * `false` otherwise\n   */\n   _isClientDoneProcessing(timeout) {\n    return new SyncPromise(resolve => {\n      let ticked = 0;\n      var tick = 1;\n\n      var interval = setInterval(() => {\n        if (this._numProcessing == 0) {\n          clearInterval(interval);\n          resolve(true);\n        } else {\n          ticked += tick;\n          if (timeout && ticked >= timeout) {\n            clearInterval(interval);\n            resolve(false);\n          }\n        }\n      }, tick);\n    });\n  }\n\n  /** Determines whether this SDK is enabled and a valid Dsn is present. */\n   _isEnabled() {\n    return this.getOptions().enabled !== false && this._dsn !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n   _prepareEvent(event, hint, scope) {\n    const { normalizeDepth = 3, normalizeMaxBreadth = 1000 } = this.getOptions();\n    var prepared = {\n      ...event,\n      event_id: event.event_id || hint.event_id || uuid4(),\n      timestamp: event.timestamp || dateTimestampInSeconds(),\n    };\n\n    this._applyClientOptions(prepared);\n    this._applyIntegrationsMetadata(prepared);\n\n    // If we have scope given to us, use it as the base for further modifications.\n    // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n    let finalScope = scope;\n    if (hint.captureContext) {\n      finalScope = Scope.clone(finalScope).update(hint.captureContext);\n    }\n\n    // We prepare the result here with a resolved Event.\n    let result = resolvedSyncPromise(prepared);\n\n    // This should be the last thing called, since we want that\n    // {@link Hub.addEventProcessor} gets the finished prepared event.\n    if (finalScope) {\n      // Collect attachments from the hint and scope\n      var attachments = [...(hint.attachments || []), ...finalScope.getAttachments()];\n\n      if (attachments.length) {\n        hint.attachments = attachments;\n      }\n\n      // In case we have a hub we reassign it.\n      result = finalScope.applyToEvent(prepared, hint);\n    }\n\n    return result.then(evt => {\n      if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n        return this._normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n      }\n      return evt;\n    });\n  }\n\n  /**\n   * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n   * Normalized keys:\n   * - `breadcrumbs.data`\n   * - `user`\n   * - `contexts`\n   * - `extra`\n   * @param event Event\n   * @returns Normalized event\n   */\n   _normalizeEvent(event, depth, maxBreadth) {\n    if (!event) {\n      return null;\n    }\n\n    var normalized = {\n      ...event,\n      ...(event.breadcrumbs && {\n        breadcrumbs: event.breadcrumbs.map(b => ({\n          ...b,\n          ...(b.data && {\n            data: normalize(b.data, depth, maxBreadth),\n          }),\n        })),\n      }),\n      ...(event.user && {\n        user: normalize(event.user, depth, maxBreadth),\n      }),\n      ...(event.contexts && {\n        contexts: normalize(event.contexts, depth, maxBreadth),\n      }),\n      ...(event.extra && {\n        extra: normalize(event.extra, depth, maxBreadth),\n      }),\n    };\n\n    // event.contexts.trace stores information about a Transaction. Similarly,\n    // event.spans[] stores information about child Spans. Given that a\n    // Transaction is conceptually a Span, normalization should apply to both\n    // Transactions and Spans consistently.\n    // For now the decision is to skip normalization of Transactions and Spans,\n    // so this block overwrites the normalized event to add back the original\n    // Transaction information prior to normalization.\n    if (event.contexts && event.contexts.trace && normalized.contexts) {\n      normalized.contexts.trace = event.contexts.trace;\n\n      // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n      if (event.contexts.trace.data) {\n        normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);\n      }\n    }\n\n    // event.spans[].data may contain circular/dangerous data so we need to normalize it\n    if (event.spans) {\n      normalized.spans = event.spans.map(span => {\n        // We cannot use the spread operator here because `toJSON` on `span` is non-enumerable\n        if (span.data) {\n          span.data = normalize(span.data, depth, maxBreadth);\n        }\n        return span;\n      });\n    }\n\n    return normalized;\n  }\n\n  /**\n   *  Enhances event using the client configuration.\n   *  It takes care of all \"static\" values like environment, release and `dist`,\n   *  as well as truncating overly long values.\n   * @param event event instance to be enhanced\n   */\n   _applyClientOptions(event) {\n    var options = this.getOptions();\n    const { environment, release, dist, maxValueLength = 250 } = options;\n\n    if (!('environment' in event)) {\n      event.environment = 'environment' in options ? environment : 'production';\n    }\n\n    if (event.release === undefined && release !== undefined) {\n      event.release = release;\n    }\n\n    if (event.dist === undefined && dist !== undefined) {\n      event.dist = dist;\n    }\n\n    if (event.message) {\n      event.message = truncate(event.message, maxValueLength);\n    }\n\n    var exception = event.exception && event.exception.values && event.exception.values[0];\n    if (exception && exception.value) {\n      exception.value = truncate(exception.value, maxValueLength);\n    }\n\n    var request = event.request;\n    if (request && request.url) {\n      request.url = truncate(request.url, maxValueLength);\n    }\n  }\n\n  /**\n   * This function adds all used integrations to the SDK info in the event.\n   * @param event The event that will be filled with all integrations.\n   */\n   _applyIntegrationsMetadata(event) {\n    var integrationsArray = Object.keys(this._integrations);\n    if (integrationsArray.length > 0) {\n      event.sdk = event.sdk || {};\n      event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationsArray];\n    }\n  }\n\n  /**\n   * Processes the event and logs an error in case of rejection\n   * @param event\n   * @param hint\n   * @param scope\n   */\n   _captureEvent(event, hint = {}, scope) {\n    return this._processEvent(event, hint, scope).then(\n      finalEvent => {\n        return finalEvent.event_id;\n      },\n      reason => {\n        if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {\n          // If something's gone wrong, log the error as a warning. If it's just us having used a `SentryError` for\n          // control flow, log just the message (no stack) as a log-level log.\n          var sentryError = reason ;\n          if (sentryError.logLevel === 'log') {\n            logger.log(sentryError.message);\n          } else {\n            logger.warn(sentryError);\n          }\n        }\n        return undefined;\n      },\n    );\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n   _processEvent(event, hint, scope) {\n    const { beforeSend, sampleRate } = this.getOptions();\n\n    if (!this._isEnabled()) {\n      return rejectedSyncPromise(new SentryError('SDK not enabled, will not capture event.', 'log'));\n    }\n\n    var isTransaction = event.type === 'transaction';\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n    if (!isTransaction && typeof sampleRate === 'number' && Math.random() > sampleRate) {\n      this.recordDroppedEvent('sample_rate', 'error');\n      return rejectedSyncPromise(\n        new SentryError(\n          `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,\n          'log',\n        ),\n      );\n    }\n\n    return this._prepareEvent(event, hint, scope)\n      .then(prepared => {\n        if (prepared === null) {\n          this.recordDroppedEvent('event_processor', event.type || 'error');\n          throw new SentryError('An event processor returned null, will not send event.', 'log');\n        }\n\n        var isInternalException = hint.data && (hint.data ).__sentry__ === true;\n        if (isInternalException || isTransaction || !beforeSend) {\n          return prepared;\n        }\n\n        var beforeSendResult = beforeSend(prepared, hint);\n        return _ensureBeforeSendRv(beforeSendResult);\n      })\n      .then(processedEvent => {\n        if (processedEvent === null) {\n          this.recordDroppedEvent('before_send', event.type || 'error');\n          throw new SentryError('`beforeSend` returned `null`, will not send event.', 'log');\n        }\n\n        var session = scope && scope.getSession();\n        if (!isTransaction && session) {\n          this._updateSessionFromEvent(session, processedEvent);\n        }\n\n        // None of the Sentry built event processor will update transaction name,\n        // so if the transaction name has been changed by an event processor, we know\n        // it has to come from custom event processor added by a user\n        var transactionInfo = processedEvent.transaction_info;\n        if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {\n          var source = 'custom';\n          processedEvent.transaction_info = {\n            ...transactionInfo,\n            source,\n            changes: [\n              ...transactionInfo.changes,\n              {\n                source,\n                // use the same timestamp as the processed event.\n                timestamp: processedEvent.timestamp ,\n                propagations: transactionInfo.propagations,\n              },\n            ],\n          };\n        }\n\n        this.sendEvent(processedEvent, hint);\n        return processedEvent;\n      })\n      .then(null, reason => {\n        if (reason instanceof SentryError) {\n          throw reason;\n        }\n\n        this.captureException(reason, {\n          data: {\n            __sentry__: true,\n          },\n          originalException: reason ,\n        });\n        throw new SentryError(\n          `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: ${reason}`,\n        );\n      });\n  }\n\n  /**\n   * Occupies the client with processing and event\n   */\n   _process(promise) {\n    this._numProcessing += 1;\n    void promise.then(\n      value => {\n        this._numProcessing -= 1;\n        return value;\n      },\n      reason => {\n        this._numProcessing -= 1;\n        return reason;\n      },\n    );\n  }\n\n  /**\n   * @inheritdoc\n   */\n   _sendEnvelope(envelope) {\n    if (this._transport && this._dsn) {\n      this._transport.send(envelope).then(null, reason => {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Error while sending event:', reason);\n      });\n    } else {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Transport disabled');\n    }\n  }\n\n  /**\n   * Clears outcomes on this client and returns them.\n   */\n   _clearOutcomes() {\n    var outcomes = this._outcomes;\n    this._outcomes = {};\n    return Object.keys(outcomes).map(key => {\n      const [reason, category] = key.split(':') ;\n      return {\n        reason,\n        category,\n        quantity: outcomes[key],\n      };\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n    \n\n}\n\n/**\n * Verifies that return value of configured `beforeSend` is of expected type.\n */\nfunction _ensureBeforeSendRv(rv) {\n  var nullErr = '`beforeSend` method has to return `null` or a valid event.';\n  if (isThenable(rv)) {\n    return rv.then(\n      event => {\n        if (!(isPlainObject(event) || event === null)) {\n          throw new SentryError(nullErr);\n        }\n        return event;\n      },\n      e => {\n        throw new SentryError(`beforeSend rejected with ${e}`);\n      },\n    );\n  } else if (!(isPlainObject(rv) || rv === null)) {\n    throw new SentryError(nullErr);\n  }\n  return rv;\n}\n\nexport { BaseClient };\n//# sourceMappingURL=baseclient.js.map\n","import { createEnvelope } from './envelope.js';\nimport { dateTimestampInSeconds } from './time.js';\n\n/**\n * Creates client report envelope\n * @param discarded_events An array of discard events\n * @param dsn A DSN that can be set on the header. Optional.\n */\nfunction createClientReportEnvelope(\n  discarded_events,\n  dsn,\n  timestamp,\n) {\n  var clientReportItem = [\n    { type: 'client_report' },\n    {\n      timestamp: timestamp || dateTimestampInSeconds(),\n      discarded_events,\n    },\n  ];\n  return createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);\n}\n\nexport { createClientReportEnvelope };\n//# sourceMappingURL=clientreport.js.map\n","import { getCurrentHub } from '@sentry/core';\nimport { isEvent, extractExceptionKeysForMessage, normalizeToSize, addExceptionMechanism, resolvedSyncPromise, isErrorEvent, isDOMError, isDOMException, addExceptionTypeValue, isError, isPlainObject } from '@sentry/utils';\n\n/**\n * This function creates an exception from a JavaScript Error\n */\nfunction exceptionFromError(stackParser, ex) {\n  // Get the frames first since Opera can lose the stack if we touch anything else first\n  var frames = parseStackFrames(stackParser, ex);\n\n  var exception = {\n    type: ex && ex.name,\n    value: extractMessage(ex),\n  };\n\n  if (frames.length) {\n    exception.stacktrace = { frames };\n  }\n\n  if (exception.type === undefined && exception.value === '') {\n    exception.value = 'Unrecoverable error caught';\n  }\n\n  return exception;\n}\n\n/**\n * @hidden\n */\nfunction eventFromPlainObject(\n  stackParser,\n  exception,\n  syntheticException,\n  isUnhandledRejection,\n) {\n  var hub = getCurrentHub();\n  var client = hub.getClient();\n  var normalizeDepth = client && client.getOptions().normalizeDepth;\n\n  var event = {\n    exception: {\n      values: [\n        {\n          type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? 'UnhandledRejection' : 'Error',\n          value: `Non-Error ${\n            isUnhandledRejection ? 'promise rejection' : 'exception'\n          } captured with keys: ${extractExceptionKeysForMessage(exception)}`,\n        },\n      ],\n    },\n    extra: {\n      __serialized__: normalizeToSize(exception, normalizeDepth),\n    },\n  };\n\n  if (syntheticException) {\n    var frames = parseStackFrames(stackParser, syntheticException);\n    if (frames.length) {\n      // event.exception.values[0] has been set above\n      (event.exception ).values[0].stacktrace = { frames };\n    }\n  }\n\n  return event;\n}\n\n/**\n * @hidden\n */\nfunction eventFromError(stackParser, ex) {\n  return {\n    exception: {\n      values: [exceptionFromError(stackParser, ex)],\n    },\n  };\n}\n\n/** Parses stack frames from an error */\nfunction parseStackFrames(\n  stackParser,\n  ex,\n) {\n  // Access and store the stacktrace property before doing ANYTHING\n  // else to it because Opera is not very good at providing it\n  // reliably in other circumstances.\n  var stacktrace = ex.stacktrace || ex.stack || '';\n\n  var popSize = getPopSize(ex);\n\n  try {\n    return stackParser(stacktrace, popSize);\n  } catch (e) {\n    // no-empty\n  }\n\n  return [];\n}\n\n// Based on our own mapping pattern - https://github.com/getsentry/sentry/blob/9f08305e09866c8bd6d0c24f5b0aabdd7dd6c59c/src/sentry/lang/javascript/errormapping.py#L83-L108\nvar reactMinifiedRegexp = /Minified React error #\\d+;/i;\n\nfunction getPopSize(ex) {\n  if (ex) {\n    if (typeof ex.framesToPop === 'number') {\n      return ex.framesToPop;\n    }\n\n    if (reactMinifiedRegexp.test(ex.message)) {\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * There are cases where stacktrace.message is an Event object\n * https://github.com/getsentry/sentry-javascript/issues/1949\n * In this specific case we try to extract stacktrace.message.error.message\n */\nfunction extractMessage(ex) {\n  var message = ex && ex.message;\n  if (!message) {\n    return 'No error message';\n  }\n  if (message.error && typeof message.error.message === 'string') {\n    return message.error.message;\n  }\n  return message;\n}\n\n/**\n * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.\n * @hidden\n */\nfunction eventFromException(\n  stackParser,\n  exception,\n  hint,\n  attachStacktrace,\n) {\n  var syntheticException = (hint && hint.syntheticException) || undefined;\n  var event = eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace);\n  addExceptionMechanism(event); // defaults to { type: 'generic', handled: true }\n  event.level = 'error';\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return resolvedSyncPromise(event);\n}\n\n/**\n * Builds and Event from a Message\n * @hidden\n */\nfunction eventFromMessage(\n  stackParser,\n  message,\n    level = 'info',\n  hint,\n  attachStacktrace,\n) {\n  var syntheticException = (hint && hint.syntheticException) || undefined;\n  var event = eventFromString(stackParser, message, syntheticException, attachStacktrace);\n  event.level = level;\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return resolvedSyncPromise(event);\n}\n\n/**\n * @hidden\n */\nfunction eventFromUnknownInput(\n  stackParser,\n  exception,\n  syntheticException,\n  attachStacktrace,\n  isUnhandledRejection,\n) {\n  let event;\n\n  if (isErrorEvent(exception ) && (exception ).error) {\n    // If it is an ErrorEvent with `error` property, extract it to get actual Error\n    var errorEvent = exception ;\n    return eventFromError(stackParser, errorEvent.error );\n  }\n\n  // If it is a `DOMError` (which is a legacy API, but still supported in some browsers) then we just extract the name\n  // and message, as it doesn't provide anything else. According to the spec, all `DOMExceptions` should also be\n  // `Error`s, but that's not the case in IE11, so in that case we treat it the same as we do a `DOMError`.\n  //\n  // https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n  // https://developer.mozilla.org/en-US/docs/Web/API/DOMException\n  // https://webidl.spec.whatwg.org/#es-DOMException-specialness\n  if (isDOMError(exception ) || isDOMException(exception )) {\n    var domException = exception ;\n\n    if ('stack' in (exception )) {\n      event = eventFromError(stackParser, exception );\n    } else {\n      var name = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');\n      var message = domException.message ? `${name}: ${domException.message}` : name;\n      event = eventFromString(stackParser, message, syntheticException, attachStacktrace);\n      addExceptionTypeValue(event, message);\n    }\n    if ('code' in domException) {\n      event.tags = { ...event.tags, 'DOMException.code': `${domException.code}` };\n    }\n\n    return event;\n  }\n  if (isError(exception)) {\n    // we have a real Error object, do nothing\n    return eventFromError(stackParser, exception);\n  }\n  if (isPlainObject(exception) || isEvent(exception)) {\n    // If it's a plain object or an instance of `Event` (the built-in JS kind, not this SDK's `Event` type), serialize\n    // it manually. This will allow us to group events based on top-level keys which is much better than creating a new\n    // group on any key/value change.\n    var objectException = exception ;\n    event = eventFromPlainObject(stackParser, objectException, syntheticException, isUnhandledRejection);\n    addExceptionMechanism(event, {\n      synthetic: true,\n    });\n    return event;\n  }\n\n  // If none of previous checks were valid, then it means that it's not:\n  // - an instance of DOMError\n  // - an instance of DOMException\n  // - an instance of Event\n  // - an instance of Error\n  // - a valid ErrorEvent (one with an error property)\n  // - a plain Object\n  //\n  // So bail out and capture it as a simple message:\n  event = eventFromString(stackParser, exception , syntheticException, attachStacktrace);\n  addExceptionTypeValue(event, `${exception}`, undefined);\n  addExceptionMechanism(event, {\n    synthetic: true,\n  });\n\n  return event;\n}\n\n/**\n * @hidden\n */\nfunction eventFromString(\n  stackParser,\n  input,\n  syntheticException,\n  attachStacktrace,\n) {\n  var event = {\n    message: input,\n  };\n\n  if (attachStacktrace && syntheticException) {\n    var frames = parseStackFrames(stackParser, syntheticException);\n    if (frames.length) {\n      event.exception = {\n        values: [{ value: input, stacktrace: { frames } }],\n      };\n    }\n  }\n\n  return event;\n}\n\nexport { eventFromError, eventFromException, eventFromMessage, eventFromPlainObject, eventFromString, eventFromUnknownInput, exceptionFromError, parseStackFrames };\n//# sourceMappingURL=eventbuilder.js.map\n","// Note: Ideally the `SeverityLevel` type would be derived from `validSeverityLevels`, but that would mean either\n//\n// a) moving `validSeverityLevels` to `@sentry/types`,\n// b) moving the`SeverityLevel` type here, or\n// c) importing `validSeverityLevels` from here into `@sentry/types`.\n//\n// Option A would make `@sentry/types` a runtime dependency of `@sentry/utils` (not good), and options B and C would\n// create a circular dependency between `@sentry/types` and `@sentry/utils` (also not good). So a TODO accompanying the\n// type, reminding anyone who changes it to change this list also, will have to do.\n\nvar validSeverityLevels = ['fatal', 'error', 'warning', 'log', 'info', 'debug'];\n\n/**\n * Converts a string-based level into a member of the deprecated {@link Severity} enum.\n *\n * @deprecated `severityFromString` is deprecated. Please use `severityLevelFromString` instead.\n *\n * @param level String representation of Severity\n * @returns Severity\n */\nfunction severityFromString(level) {\n  return severityLevelFromString(level) ;\n}\n\n/**\n * Converts a string-based level into a `SeverityLevel`, normalizing it along the way.\n *\n * @param level String representation of desired `SeverityLevel`.\n * @returns The `SeverityLevel` corresponding to the given string, or 'log' if the string isn't a valid level.\n */\nfunction severityLevelFromString(level) {\n  return (level === 'warn' ? 'warning' : validSeverityLevels.includes(level) ? level : 'log') ;\n}\n\nexport { severityFromString, severityLevelFromString, validSeverityLevels };\n//# sourceMappingURL=severity.js.map\n","import { getCurrentHub } from '@sentry/core';\nimport { addInstrumentationHandler, htmlTreeAsString, severityLevelFromString, safeJoin, getGlobalObject, parseUrl } from '@sentry/utils';\n\n/** JSDoc */\n\nvar BREADCRUMB_INTEGRATION_ID = 'Breadcrumbs';\n\n/**\n * Default Breadcrumbs instrumentations\n * TODO: Deprecated - with v6, this will be renamed to `Instrument`\n */\nclass Breadcrumbs  {\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = BREADCRUMB_INTEGRATION_ID;}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = Breadcrumbs.id;}\n\n  /**\n   * Options of the breadcrumbs integration.\n   */\n  // This field is public, because we use it in the browser client to check if the `sentry` option is enabled.\n  \n\n  /**\n   * @inheritDoc\n   */\n   constructor(options) {;Breadcrumbs.prototype.__init.call(this);\n    this.options = {\n      console: true,\n      dom: true,\n      fetch: true,\n      history: true,\n      sentry: true,\n      xhr: true,\n      ...options,\n    };\n  }\n\n  /**\n   * Instrument browser built-ins w/ breadcrumb capturing\n   *  - Console API\n   *  - DOM API (click/typing)\n   *  - XMLHttpRequest API\n   *  - Fetch API\n   *  - History API\n   */\n   setupOnce() {\n    if (this.options.console) {\n      addInstrumentationHandler('console', _consoleBreadcrumb);\n    }\n    if (this.options.dom) {\n      addInstrumentationHandler('dom', _domBreadcrumb(this.options.dom));\n    }\n    if (this.options.xhr) {\n      addInstrumentationHandler('xhr', _xhrBreadcrumb);\n    }\n    if (this.options.fetch) {\n      addInstrumentationHandler('fetch', _fetchBreadcrumb);\n    }\n    if (this.options.history) {\n      addInstrumentationHandler('history', _historyBreadcrumb);\n    }\n  }\n} Breadcrumbs.__initStatic();\n\n/**\n * A HOC that creaes a function that creates breadcrumbs from DOM API calls.\n * This is a HOC so that we get access to dom options in the closure.\n */\nfunction _domBreadcrumb(dom) {\n    function _innerDomBreadcrumb(handlerData) {\n    let target;\n    let keyAttrs = typeof dom === 'object' ? dom.serializeAttribute : undefined;\n\n    if (typeof keyAttrs === 'string') {\n      keyAttrs = [keyAttrs];\n    }\n\n    // Accessing event.target can throw (see getsentry/raven-js#838, #768)\n    try {\n      target = handlerData.event.target\n        ? htmlTreeAsString(handlerData.event.target , keyAttrs)\n        : htmlTreeAsString(handlerData.event , keyAttrs);\n    } catch (e) {\n      target = '<unknown>';\n    }\n\n    if (target.length === 0) {\n      return;\n    }\n\n    getCurrentHub().addBreadcrumb(\n      {\n        category: `ui.${handlerData.name}`,\n        message: target,\n      },\n      {\n        event: handlerData.event,\n        name: handlerData.name,\n        global: handlerData.global,\n      },\n    );\n  }\n\n  return _innerDomBreadcrumb;\n}\n\n/**\n * Creates breadcrumbs from console API calls\n */\nfunction _consoleBreadcrumb(handlerData) {\n  var breadcrumb = {\n    category: 'console',\n    data: {\n      arguments: handlerData.args,\n      logger: 'console',\n    },\n    level: severityLevelFromString(handlerData.level),\n    message: safeJoin(handlerData.args, ' '),\n  };\n\n  if (handlerData.level === 'assert') {\n    if (handlerData.args[0] === false) {\n      breadcrumb.message = `Assertion failed: ${safeJoin(handlerData.args.slice(1), ' ') || 'console.assert'}`;\n      breadcrumb.data.arguments = handlerData.args.slice(1);\n    } else {\n      // Don't capture a breadcrumb for passed assertions\n      return;\n    }\n  }\n\n  getCurrentHub().addBreadcrumb(breadcrumb, {\n    input: handlerData.args,\n    level: handlerData.level,\n  });\n}\n\n/**\n * Creates breadcrumbs from XHR API calls\n */\nfunction _xhrBreadcrumb(handlerData) {\n  if (handlerData.endTimestamp) {\n    // We only capture complete, non-sentry requests\n    if (handlerData.xhr.__sentry_own_request__) {\n      return;\n    }\n\n    const { method, url, status_code, body } = handlerData.xhr.__sentry_xhr__ || {};\n\n    getCurrentHub().addBreadcrumb(\n      {\n        category: 'xhr',\n        data: {\n          method,\n          url,\n          status_code,\n        },\n        type: 'http',\n      },\n      {\n        xhr: handlerData.xhr,\n        input: body,\n      },\n    );\n\n    return;\n  }\n}\n\n/**\n * Creates breadcrumbs from fetch API calls\n */\nfunction _fetchBreadcrumb(handlerData) {\n  // We only capture complete fetch requests\n  if (!handlerData.endTimestamp) {\n    return;\n  }\n\n  if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === 'POST') {\n    // We will not create breadcrumbs for fetch requests that contain `sentry_key` (internal sentry requests)\n    return;\n  }\n\n  if (handlerData.error) {\n    getCurrentHub().addBreadcrumb(\n      {\n        category: 'fetch',\n        data: handlerData.fetchData,\n        level: 'error',\n        type: 'http',\n      },\n      {\n        data: handlerData.error,\n        input: handlerData.args,\n      },\n    );\n  } else {\n    getCurrentHub().addBreadcrumb(\n      {\n        category: 'fetch',\n        data: {\n          ...handlerData.fetchData,\n          status_code: handlerData.response.status,\n        },\n        type: 'http',\n      },\n      {\n        input: handlerData.args,\n        response: handlerData.response,\n      },\n    );\n  }\n}\n\n/**\n * Creates breadcrumbs from history API calls\n */\nfunction _historyBreadcrumb(handlerData) {\n  var global = getGlobalObject();\n  let from = handlerData.from;\n  let to = handlerData.to;\n  var parsedLoc = parseUrl(global.location.href);\n  let parsedFrom = parseUrl(from);\n  var parsedTo = parseUrl(to);\n\n  // Initial pushState doesn't provide `from` information\n  if (!parsedFrom.path) {\n    parsedFrom = parsedLoc;\n  }\n\n  // Use only the path component of the URL if the URL matches the current\n  // document (almost all the time when using pushState)\n  if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {\n    to = parsedTo.relative;\n  }\n  if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {\n    from = parsedFrom.relative;\n  }\n\n  getCurrentHub().addBreadcrumb({\n    category: 'navigation',\n    data: {\n      from,\n      to,\n    },\n  });\n}\n\nexport { BREADCRUMB_INTEGRATION_ID, Breadcrumbs };\n//# sourceMappingURL=breadcrumbs.js.map\n","import { getGlobalObject, isNativeFetch, logger, supportsFetch } from '@sentry/utils';\n\nvar global = getGlobalObject();\nlet cachedFetchImpl;\n\n/**\n * A special usecase for incorrectly wrapped Fetch APIs in conjunction with ad-blockers.\n * Whenever someone wraps the Fetch API and returns the wrong promise chain,\n * this chain becomes orphaned and there is no possible way to capture it's rejections\n * other than allowing it bubble up to this very handler. eg.\n *\n * var f = window.fetch;\n * window.fetch = function () {\n *   var p = f.apply(this, arguments);\n *\n *   p.then(function() {\n *     console.log('hi.');\n *   });\n *\n *   return p;\n * }\n *\n * `p.then(function () { ... })` is producing a completely separate promise chain,\n * however, what's returned is `p` - the result of original `fetch` call.\n *\n * This mean, that whenever we use the Fetch API to send our own requests, _and_\n * some ad-blocker blocks it, this orphaned chain will _always_ reject,\n * effectively causing another event to be captured.\n * This makes a whole process become an infinite loop, which we need to somehow\n * deal with, and break it in one way or another.\n *\n * To deal with this issue, we are making sure that we _always_ use the real\n * browser Fetch API, instead of relying on what `window.fetch` exposes.\n * The only downside to this would be missing our own requests as breadcrumbs,\n * but because we are already not doing this, it should be just fine.\n *\n * Possible failed fetch error messages per-browser:\n *\n * Chrome:  Failed to fetch\n * Edge:    Failed to Fetch\n * Firefox: NetworkError when attempting to fetch resource\n * Safari:  resource blocked by content blocker\n */\nfunction getNativeFetchImplementation() {\n  if (cachedFetchImpl) {\n    return cachedFetchImpl;\n  }\n\n  // Fast path to avoid DOM I/O\n  if (isNativeFetch(global.fetch)) {\n    return (cachedFetchImpl = global.fetch.bind(global));\n  }\n\n  var document = global.document;\n  let fetchImpl = global.fetch;\n    if (document && typeof document.createElement === 'function') {\n    try {\n      var sandbox = document.createElement('iframe');\n      sandbox.hidden = true;\n      document.head.appendChild(sandbox);\n      var contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow.fetch) {\n        fetchImpl = contentWindow.fetch;\n      }\n      document.head.removeChild(sandbox);\n    } catch (e) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', e);\n    }\n  }\n\n  return (cachedFetchImpl = fetchImpl.bind(global));\n  }\n\n/**\n * Sends sdk client report using sendBeacon or fetch as a fallback if available\n *\n * @param url report endpoint\n * @param body report payload\n */\nfunction sendReport(url, body) {\n  var isRealNavigator = Object.prototype.toString.call(global && global.navigator) === '[object Navigator]';\n  var hasSendBeacon = isRealNavigator && typeof global.navigator.sendBeacon === 'function';\n\n  if (hasSendBeacon) {\n    // Prevent illegal invocations - https://xgwang.me/posts/you-may-not-know-beacon/#it-may-throw-error%2C-be-sure-to-catch\n    var sendBeacon = global.navigator.sendBeacon.bind(global.navigator);\n    sendBeacon(url, body);\n  } else if (supportsFetch()) {\n    var fetch = getNativeFetchImplementation();\n    fetch(url, {\n      body,\n      method: 'POST',\n      credentials: 'omit',\n      keepalive: true,\n    }).then(null, error => {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error(error);\n    });\n  }\n}\n\nexport { getNativeFetchImplementation, sendReport };\n//# sourceMappingURL=utils.js.map\n","import { BaseClient, SDK_VERSION, getCurrentHub, getEnvelopeEndpointWithUrlEncodedAuth } from '@sentry/core';\nimport { getGlobalObject, getEventDescription, logger, createClientReportEnvelope, dsnToString, serializeEnvelope } from '@sentry/utils';\nimport { eventFromException, eventFromMessage } from './eventbuilder.js';\nimport { BREADCRUMB_INTEGRATION_ID } from './integrations/breadcrumbs.js';\nimport { sendReport } from './transports/utils.js';\n\nvar globalObject = getGlobalObject();\n\n/**\n * The Sentry Browser SDK Client.\n *\n * @see BrowserOptions for documentation on configuration options.\n * @see SentryClient for usage documentation.\n */\nclass BrowserClient extends BaseClient {\n  /**\n   * Creates a new Browser SDK instance.\n   *\n   * @param options Configuration options for this SDK.\n   */\n   constructor(options) {\n    options._metadata = options._metadata || {};\n    options._metadata.sdk = options._metadata.sdk || {\n      name: 'sentry.javascript.browser',\n      packages: [\n        {\n          name: 'npm:@sentry/browser',\n          version: SDK_VERSION,\n        },\n      ],\n      version: SDK_VERSION,\n    };\n\n    super(options);\n\n    if (options.sendClientReports && globalObject.document) {\n      globalObject.document.addEventListener('visibilitychange', () => {\n        if (globalObject.document.visibilityState === 'hidden') {\n          this._flushOutcomes();\n        }\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   eventFromException(exception, hint) {\n    return eventFromException(this._options.stackParser, exception, hint, this._options.attachStacktrace);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   eventFromMessage(\n    message,\n        level = 'info',\n    hint,\n  ) {\n    return eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   sendEvent(event, hint) {\n    // We only want to add the sentry event breadcrumb when the user has the breadcrumb integration installed and\n    // activated its `sentry` option.\n    // We also do not want to use the `Breadcrumbs` class here directly, because we do not want it to be included in\n    // bundles, if it is not used by the SDK.\n    // This all sadly is a bit ugly, but we currently don't have a \"pre-send\" hook on the integrations so we do it this\n    // way for now.\n    var breadcrumbIntegration = this.getIntegrationById(BREADCRUMB_INTEGRATION_ID) ;\n    if (\n      breadcrumbIntegration &&\n      // We check for definedness of `options`, even though it is not strictly necessary, because that access to\n      // `.sentry` below does not throw, in case users provided their own integration with id \"Breadcrumbs\" that does\n      // not have an`options` field\n      breadcrumbIntegration.options &&\n      breadcrumbIntegration.options.sentry\n    ) {\n      getCurrentHub().addBreadcrumb(\n        {\n          category: `sentry.${event.type === 'transaction' ? 'transaction' : 'event'}`,\n          event_id: event.event_id,\n          level: event.level,\n          message: getEventDescription(event),\n        },\n        {\n          event,\n        },\n      );\n    }\n\n    super.sendEvent(event, hint);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   _prepareEvent(event, hint, scope) {\n    event.platform = event.platform || 'javascript';\n    return super._prepareEvent(event, hint, scope);\n  }\n\n  /**\n   * Sends client reports as an envelope.\n   */\n   _flushOutcomes() {\n    var outcomes = this._clearOutcomes();\n\n    if (outcomes.length === 0) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('No outcomes to send');\n      return;\n    }\n\n    if (!this._dsn) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('No dsn provided, will not send outcomes');\n      return;\n    }\n\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('Sending outcomes:', outcomes);\n\n    var url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, this._options);\n    var envelope = createClientReportEnvelope(outcomes, this._options.tunnel && dsnToString(this._dsn));\n\n    try {\n      sendReport(url, serializeEnvelope(envelope));\n    } catch (e) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error(e);\n    }\n  }\n}\n\nexport { BrowserClient };\n//# sourceMappingURL=client.js.map\n","import { createStackParser } from '@sentry/utils';\n\n// global reference to slice\nvar UNKNOWN_FUNCTION = '?';\n\nvar OPERA10_PRIORITY = 10;\nvar OPERA11_PRIORITY = 20;\nvar CHROME_PRIORITY = 30;\nvar WINJS_PRIORITY = 40;\nvar GECKO_PRIORITY = 50;\n\nfunction createFrame(filename, func, lineno, colno) {\n  var frame = {\n    filename,\n    function: func,\n    // All browser frames are considered in_app\n    in_app: true,\n  };\n\n  if (lineno !== undefined) {\n    frame.lineno = lineno;\n  }\n\n  if (colno !== undefined) {\n    frame.colno = colno;\n  }\n\n  return frame;\n}\n\n// Chromium based browsers: Chrome, Brave, new Opera, new Edge\nvar chromeRegex =\n  /^\\s*at (?:(.*\\).*?|.*?) ?\\((?:address at )?)?((?:file|https?|blob|chrome-extension|address|native|eval|webpack|<anonymous>|[-a-z]+:|.*bundle|\\/)?.*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\nvar chromeEvalRegex = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n\nvar chrome = line => {\n  var parts = chromeRegex.exec(line);\n\n  if (parts) {\n    var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n\n    if (isEval) {\n      var subMatch = chromeEvalRegex.exec(parts[2]);\n\n      if (subMatch) {\n        // throw out eval line/column and use top-most line/column number\n        parts[2] = subMatch[1]; // url\n        parts[3] = subMatch[2]; // line\n        parts[4] = subMatch[3]; // column\n      }\n    }\n\n    // Kamil: One more hack won't hurt us right? Understanding and adding more rules on top of these regexps right now\n    // would be way too time consuming. (TODO: Rewrite whole RegExp to be more readable)\n    const [func, filename] = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]);\n\n    return createFrame(filename, func, parts[3] ? +parts[3] : undefined, parts[4] ? +parts[4] : undefined);\n  }\n\n  return;\n};\n\nvar chromeStackLineParser = [CHROME_PRIORITY, chrome];\n\n// gecko regex: `(?:bundle|\\d+\\.js)`: `bundle` is for react native, `\\d+\\.js` also but specifically for ram bundles because it\n// generates filenames without a prefix like `file://` the filenames in the stacktrace are just 42.js\n// We need this specific case for now because we want no other regex to match.\nvar geckoREgex =\n  /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)?((?:file|https?|blob|chrome|webpack|resource|moz-extension|safari-extension|safari-web-extension|capacitor)?:\\/.*?|\\[native code\\]|[^@]*(?:bundle|\\d+\\.js)|\\/[\\w\\-. /=]+)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nvar geckoEvalRegex = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\n\nvar gecko = line => {\n  var parts = geckoREgex.exec(line);\n\n  if (parts) {\n    var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n    if (isEval) {\n      var subMatch = geckoEvalRegex.exec(parts[3]);\n\n      if (subMatch) {\n        // throw out eval line/column and use top-most line number\n        parts[1] = parts[1] || 'eval';\n        parts[3] = subMatch[1];\n        parts[4] = subMatch[2];\n        parts[5] = ''; // no column when eval\n      }\n    }\n\n    let filename = parts[3];\n    let func = parts[1] || UNKNOWN_FUNCTION;\n    [func, filename] = extractSafariExtensionDetails(func, filename);\n\n    return createFrame(filename, func, parts[4] ? +parts[4] : undefined, parts[5] ? +parts[5] : undefined);\n  }\n\n  return;\n};\n\nvar geckoStackLineParser = [GECKO_PRIORITY, gecko];\n\nvar winjsRegex =\n  /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n\nvar winjs = line => {\n  var parts = winjsRegex.exec(line);\n\n  return parts\n    ? createFrame(parts[2], parts[1] || UNKNOWN_FUNCTION, +parts[3], parts[4] ? +parts[4] : undefined)\n    : undefined;\n};\n\nvar winjsStackLineParser = [WINJS_PRIORITY, winjs];\n\nvar opera10Regex = / line (\\d+).*script (?:in )?(\\S+)(?:: in function (\\S+))?$/i;\n\nvar opera10 = line => {\n  var parts = opera10Regex.exec(line);\n  return parts ? createFrame(parts[2], parts[3] || UNKNOWN_FUNCTION, +parts[1]) : undefined;\n};\n\nvar opera10StackLineParser = [OPERA10_PRIORITY, opera10];\n\nvar opera11Regex =\n  / line (\\d+), column (\\d+)\\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\\(.*\\))? in (.*):\\s*$/i;\n\nvar opera11 = line => {\n  var parts = opera11Regex.exec(line);\n  return parts ? createFrame(parts[5], parts[3] || parts[4] || UNKNOWN_FUNCTION, +parts[1], +parts[2]) : undefined;\n};\n\nvar opera11StackLineParser = [OPERA11_PRIORITY, opera11];\n\nvar defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser, winjsStackLineParser];\n\nvar defaultStackParser = createStackParser(...defaultStackLineParsers);\n\n/**\n * Safari web extensions, starting version unknown, can produce \"frames-only\" stacktraces.\n * What it means, is that instead of format like:\n *\n * Error: wat\n *   at function@url:row:col\n *   at function@url:row:col\n *   at function@url:row:col\n *\n * it produces something like:\n *\n *   function@url:row:col\n *   function@url:row:col\n *   function@url:row:col\n *\n * Because of that, it won't be captured by `chrome` RegExp and will fall into `Gecko` branch.\n * This function is extracted so that we can use it in both places without duplicating the logic.\n * Unfortunately \"just\" changing RegExp is too complicated now and making it pass all tests\n * and fix this case seems like an impossible, or at least way too time-consuming task.\n */\nvar extractSafariExtensionDetails = (func, filename) => {\n  var isSafariExtension = func.indexOf('safari-extension') !== -1;\n  var isSafariWebExtension = func.indexOf('safari-web-extension') !== -1;\n\n  return isSafariExtension || isSafariWebExtension\n    ? [\n        func.indexOf('@') !== -1 ? func.split('@')[0] : UNKNOWN_FUNCTION,\n        isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}`,\n      ]\n    : [func, filename];\n};\n\nexport { chromeStackLineParser, defaultStackLineParsers, defaultStackParser, geckoStackLineParser, opera10StackLineParser, opera11StackLineParser, winjsStackLineParser };\n//# sourceMappingURL=stack-parsers.js.map\n","import { withScope, captureException } from '@sentry/core';\nimport { getOriginalFunction, addExceptionTypeValue, addExceptionMechanism, markFunctionWrapped, addNonEnumerableProperty } from '@sentry/utils';\n\nlet ignoreOnError = 0;\n\n/**\n * @hidden\n */\nfunction shouldIgnoreOnError() {\n  return ignoreOnError > 0;\n}\n\n/**\n * @hidden\n */\nfunction ignoreNextOnError() {\n  // onerror should trigger before setTimeout\n  ignoreOnError += 1;\n  setTimeout(() => {\n    ignoreOnError -= 1;\n  });\n}\n\n/**\n * Instruments the given function and sends an event to Sentry every time the\n * function throws an exception.\n *\n * @param fn A function to wrap. It is generally safe to pass an unbound function, because the returned wrapper always\n * has a correct `this` context.\n * @returns The wrapped function.\n * @hidden\n */\nfunction wrap(\n  fn,\n  options\n\n = {},\n  before,\n  ) {\n  // for future readers what this does is wrap a function and then create\n  // a bi-directional wrapping between them.\n  //\n  // example: wrapped = wrap(original);\n  //  original.__sentry_wrapped__ -> wrapped\n  //  wrapped.__sentry_original__ -> original\n\n  if (typeof fn !== 'function') {\n    return fn;\n  }\n\n  try {\n    // if we're dealing with a function that was previously wrapped, return\n    // the original wrapper.\n    var wrapper = fn.__sentry_wrapped__;\n    if (wrapper) {\n      return wrapper;\n    }\n\n    // We don't wanna wrap it twice\n    if (getOriginalFunction(fn)) {\n      return fn;\n    }\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    // Bail on wrapping and return the function as-is (defers to window.onerror).\n    return fn;\n  }\n\n    // It is important that `sentryWrapped` is not an arrow function to preserve the context of `this`\n  var sentryWrapped = function () {\n    var args = Array.prototype.slice.call(arguments);\n\n    try {\n      if (before && typeof before === 'function') {\n        before.apply(this, arguments);\n      }\n\n            var wrappedArguments = args.map((arg) => wrap(arg, options));\n\n      // Attempt to invoke user-land function\n      // NOTE: If you are a Sentry user, and you are seeing this stack frame, it\n      //       means the sentry.javascript SDK caught an error invoking your application code. This\n      //       is expected behavior and NOT indicative of a bug with sentry.javascript.\n      return fn.apply(this, wrappedArguments);\n    } catch (ex) {\n      ignoreNextOnError();\n\n      withScope((scope) => {\n        scope.addEventProcessor((event) => {\n          if (options.mechanism) {\n            addExceptionTypeValue(event, undefined, undefined);\n            addExceptionMechanism(event, options.mechanism);\n          }\n\n          event.extra = {\n            ...event.extra,\n            arguments: args,\n          };\n\n          return event;\n        });\n\n        captureException(ex);\n      });\n\n      throw ex;\n    }\n  };\n  \n  // Accessing some objects may throw\n  // ref: https://github.com/getsentry/sentry-javascript/issues/1168\n  try {\n    for (var property in fn) {\n      if (Object.prototype.hasOwnProperty.call(fn, property)) {\n        sentryWrapped[property] = fn[property];\n      }\n    }\n  } catch (_oO) {} \n  // Signal that this function has been wrapped/filled already\n  // for both debugging and to prevent it to being wrapped/filled twice\n  markFunctionWrapped(sentryWrapped, fn);\n\n  addNonEnumerableProperty(fn, '__sentry_wrapped__', sentryWrapped);\n\n  // Restore original function name (not all browsers allow that)\n  try {\n    var descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, 'name') ;\n    if (descriptor.configurable) {\n      Object.defineProperty(sentryWrapped, 'name', {\n        get() {\n          return fn.name;\n        },\n      });\n    }\n      } catch (_oO) {}\n\n  return sentryWrapped;\n}\n\n/**\n * All properties the report dialog supports\n */\n\nexport { ignoreNextOnError, shouldIgnoreOnError, wrap };\n//# sourceMappingURL=helpers.js.map\n","import { getGlobalObject, fill, getFunctionName, getOriginalFunction } from '@sentry/utils';\nimport { wrap } from '../helpers.js';\n\nvar DEFAULT_EVENT_TARGET = [\n  'EventTarget',\n  'Window',\n  'Node',\n  'ApplicationCache',\n  'AudioTrackList',\n  'ChannelMergerNode',\n  'CryptoOperation',\n  'EventSource',\n  'FileReader',\n  'HTMLUnknownElement',\n  'IDBDatabase',\n  'IDBRequest',\n  'IDBTransaction',\n  'KeyOperation',\n  'MediaController',\n  'MessagePort',\n  'ModalWindow',\n  'Notification',\n  'SVGElementInstance',\n  'Screen',\n  'TextTrack',\n  'TextTrackCue',\n  'TextTrackList',\n  'WebSocket',\n  'WebSocketWorker',\n  'Worker',\n  'XMLHttpRequest',\n  'XMLHttpRequestEventTarget',\n  'XMLHttpRequestUpload',\n];\n\n/** Wrap timer functions and event targets to catch errors and provide better meta data */\nclass TryCatch  {\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'TryCatch';}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = TryCatch.id;}\n\n  /** JSDoc */\n  \n\n  /**\n   * @inheritDoc\n   */\n   constructor(options) {;TryCatch.prototype.__init.call(this);\n    this._options = {\n      XMLHttpRequest: true,\n      eventTarget: true,\n      requestAnimationFrame: true,\n      setInterval: true,\n      setTimeout: true,\n      ...options,\n    };\n  }\n\n  /**\n   * Wrap timer functions and event targets to catch errors\n   * and provide better metadata.\n   */\n   setupOnce() {\n    var global = getGlobalObject();\n\n    if (this._options.setTimeout) {\n      fill(global, 'setTimeout', _wrapTimeFunction);\n    }\n\n    if (this._options.setInterval) {\n      fill(global, 'setInterval', _wrapTimeFunction);\n    }\n\n    if (this._options.requestAnimationFrame) {\n      fill(global, 'requestAnimationFrame', _wrapRAF);\n    }\n\n    if (this._options.XMLHttpRequest && 'XMLHttpRequest' in global) {\n      fill(XMLHttpRequest.prototype, 'send', _wrapXHR);\n    }\n\n    var eventTargetOption = this._options.eventTarget;\n    if (eventTargetOption) {\n      var eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;\n      eventTarget.forEach(_wrapEventTarget);\n    }\n  }\n} TryCatch.__initStatic();\n\n/** JSDoc */\nfunction _wrapTimeFunction(original) {\n    return function ( ...args) {\n    var originalCallback = args[0];\n    args[0] = wrap(originalCallback, {\n      mechanism: {\n        data: { function: getFunctionName(original) },\n        handled: true,\n        type: 'instrument',\n      },\n    });\n    return original.apply(this, args);\n  };\n}\n\n/** JSDoc */\nfunction _wrapRAF(original) {\n    return function ( callback) {\n        return original.apply(this, [\n      wrap(callback, {\n        mechanism: {\n          data: {\n            function: 'requestAnimationFrame',\n            handler: getFunctionName(original),\n          },\n          handled: true,\n          type: 'instrument',\n        },\n      }),\n    ]);\n  };\n}\n\n/** JSDoc */\nfunction _wrapXHR(originalSend) {\n    return function ( ...args) {\n        var xhr = this;\n    var xmlHttpRequestProps = ['onload', 'onerror', 'onprogress', 'onreadystatechange'];\n\n    xmlHttpRequestProps.forEach(prop => {\n      if (prop in xhr && typeof xhr[prop] === 'function') {\n                fill(xhr, prop, function (original) {\n          var wrapOptions = {\n            mechanism: {\n              data: {\n                function: prop,\n                handler: getFunctionName(original),\n              },\n              handled: true,\n              type: 'instrument',\n            },\n          };\n\n          // If Instrument integration has been called before TryCatch, get the name of original function\n          var originalFunction = getOriginalFunction(original);\n          if (originalFunction) {\n            wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);\n          }\n\n          // Otherwise wrap directly\n          return wrap(original, wrapOptions);\n        });\n      }\n    });\n\n    return originalSend.apply(this, args);\n  };\n}\n\n/** JSDoc */\nfunction _wrapEventTarget(target) {\n    var global = getGlobalObject() ;\n    var proto = global[target] && global[target].prototype;\n\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n    return;\n  }\n\n  fill(proto, 'addEventListener', function (original)\n\n {\n    return function (\n            \n      eventName,\n      fn,\n      options,\n    ) {\n      try {\n        if (typeof fn.handleEvent === 'function') {\n          // ESlint disable explanation:\n          //  First, it is generally safe to call `wrap` with an unbound function. Furthermore, using `.bind()` would\n          //  introduce a bug here, because bind returns a new function that doesn't have our\n          //  flags(like __sentry_original__) attached. `wrap` checks for those flags to avoid unnecessary wrapping.\n          //  Without those flags, every call to addEventListener wraps the function again, causing a memory leak.\n                    fn.handleEvent = wrap(fn.handleEvent, {\n            mechanism: {\n              data: {\n                function: 'handleEvent',\n                handler: getFunctionName(fn),\n                target,\n              },\n              handled: true,\n              type: 'instrument',\n            },\n          });\n        }\n      } catch (err) {\n        // can sometimes get 'Permission denied to access property \"handle Event'\n      }\n\n      return original.apply(this, [\n        eventName,\n                wrap(fn , {\n          mechanism: {\n            data: {\n              function: 'addEventListener',\n              handler: getFunctionName(fn),\n              target,\n            },\n            handled: true,\n            type: 'instrument',\n          },\n        }),\n        options,\n      ]);\n    };\n  });\n\n  fill(\n    proto,\n    'removeEventListener',\n    function (\n      originalRemoveEventListener,\n          ) {\n      return function (\n                \n        eventName,\n        fn,\n        options,\n      ) {\n        /**\n         * There are 2 possible scenarios here:\n         *\n         * 1. Someone passes a callback, which was attached prior to Sentry initialization, or by using unmodified\n         * method, eg. `document.addEventListener.call(el, name, handler). In this case, we treat this function\n         * as a pass-through, and call original `removeEventListener` with it.\n         *\n         * 2. Someone passes a callback, which was attached after Sentry was initialized, which means that it was using\n         * our wrapped version of `addEventListener`, which internally calls `wrap` helper.\n         * This helper \"wraps\" whole callback inside a try/catch statement, and attached appropriate metadata to it,\n         * in order for us to make a distinction between wrapped/non-wrapped functions possible.\n         * If a function was wrapped, it has additional property of `__sentry_wrapped__`, holding the handler.\n         *\n         * When someone adds a handler prior to initialization, and then do it again, but after,\n         * then we have to detach both of them. Otherwise, if we'd detach only wrapped one, it'd be impossible\n         * to get rid of the initial handler and it'd stick there forever.\n         */\n        var wrappedEventHandler = fn ;\n        try {\n          var originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;\n          if (originalEventHandler) {\n            originalRemoveEventListener.call(this, eventName, originalEventHandler, options);\n          }\n        } catch (e) {\n          // ignore, accessing __sentry_wrapped__ will throw in some Selenium environments\n        }\n        return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);\n      };\n    },\n  );\n}\n\nexport { TryCatch };\n//# sourceMappingURL=trycatch.js.map\n","import { getCurrentHub } from '@sentry/core';\nimport { addInstrumentationHandler, isString, isPrimitive, isErrorEvent, getLocationHref, logger, addExceptionMechanism } from '@sentry/utils';\nimport { eventFromUnknownInput } from '../eventbuilder.js';\nimport { shouldIgnoreOnError } from '../helpers.js';\n\n/** Global handlers */\nclass GlobalHandlers  {\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'GlobalHandlers';}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = GlobalHandlers.id;}\n\n  /** JSDoc */\n  \n\n  /**\n   * Stores references functions to installing handlers. Will set to undefined\n   * after they have been run so that they are not used twice.\n   */\n   __init2() {this._installFunc = {\n    onerror: _installGlobalOnErrorHandler,\n    onunhandledrejection: _installGlobalOnUnhandledRejectionHandler,\n  };}\n\n  /** JSDoc */\n   constructor(options) {;GlobalHandlers.prototype.__init.call(this);GlobalHandlers.prototype.__init2.call(this);\n    this._options = {\n      onerror: true,\n      onunhandledrejection: true,\n      ...options,\n    };\n  }\n  /**\n   * @inheritDoc\n   */\n   setupOnce() {\n    Error.stackTraceLimit = 50;\n    var options = this._options;\n\n    // We can disable guard-for-in as we construct the options object above + do checks against\n    // `this._installFunc` for the property.\n        for (var key in options) {\n      var installFunc = this._installFunc[key ];\n      if (installFunc && options[key ]) {\n        globalHandlerLog(key);\n        installFunc();\n        this._installFunc[key ] = undefined;\n      }\n    }\n  }\n} GlobalHandlers.__initStatic();\n\n/** JSDoc */\nfunction _installGlobalOnErrorHandler() {\n  addInstrumentationHandler(\n    'error',\n        (data) => {\n      const [hub, stackParser, attachStacktrace] = getHubAndOptions();\n      if (!hub.getIntegration(GlobalHandlers)) {\n        return;\n      }\n      const { msg, url, line, column, error } = data;\n      if (shouldIgnoreOnError() || (error && error.__sentry_own_request__)) {\n        return;\n      }\n\n      var event =\n        error === undefined && isString(msg)\n          ? _eventFromIncompleteOnError(msg, url, line, column)\n          : _enhanceEventWithInitialFrame(\n              eventFromUnknownInput(stackParser, error || msg, undefined, attachStacktrace, false),\n              url,\n              line,\n              column,\n            );\n\n      event.level = 'error';\n\n      addMechanismAndCapture(hub, error, event, 'onerror');\n    },\n  );\n}\n\n/** JSDoc */\nfunction _installGlobalOnUnhandledRejectionHandler() {\n  addInstrumentationHandler(\n    'unhandledrejection',\n        (e) => {\n      const [hub, stackParser, attachStacktrace] = getHubAndOptions();\n      if (!hub.getIntegration(GlobalHandlers)) {\n        return;\n      }\n      let error = e;\n\n      // dig the object of the rejection out of known event types\n      try {\n        // PromiseRejectionEvents store the object of the rejection under 'reason'\n        // see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent\n        if ('reason' in e) {\n          error = e.reason;\n        }\n        // something, somewhere, (likely a browser extension) effectively casts PromiseRejectionEvents\n        // to CustomEvents, moving the `promise` and `reason` attributes of the PRE into\n        // the CustomEvent's `detail` attribute, since they're not part of CustomEvent's spec\n        // see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent and\n        // https://github.com/getsentry/sentry-javascript/issues/2380\n        else if ('detail' in e && 'reason' in e.detail) {\n          error = e.detail.reason;\n        }\n      } catch (_oO) {\n        // no-empty\n      }\n\n      if (shouldIgnoreOnError() || (error && error.__sentry_own_request__)) {\n        return true;\n      }\n\n      var event = isPrimitive(error)\n        ? _eventFromRejectionWithPrimitive(error)\n        : eventFromUnknownInput(stackParser, error, undefined, attachStacktrace, true);\n\n      event.level = 'error';\n\n      addMechanismAndCapture(hub, error, event, 'onunhandledrejection');\n      return;\n    },\n  );\n}\n\n/**\n * Create an event from a promise rejection where the `reason` is a primitive.\n *\n * @param reason: The `reason` property of the promise rejection\n * @returns An Event object with an appropriate `exception` value\n */\nfunction _eventFromRejectionWithPrimitive(reason) {\n  return {\n    exception: {\n      values: [\n        {\n          type: 'UnhandledRejection',\n          // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)\n          value: `Non-Error promise rejection captured with value: ${String(reason)}`,\n        },\n      ],\n    },\n  };\n}\n\n/**\n * This function creates a stack from an old, error-less onerror handler.\n */\nfunction _eventFromIncompleteOnError(msg, url, line, column) {\n  var ERROR_TYPES_RE =\n    /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;\n\n  // If 'message' is ErrorEvent, get real message from inside\n  let message = isErrorEvent(msg) ? msg.message : msg;\n  let name = 'Error';\n\n  var groups = message.match(ERROR_TYPES_RE);\n  if (groups) {\n    name = groups[1];\n    message = groups[2];\n  }\n\n  var event = {\n    exception: {\n      values: [\n        {\n          type: name,\n          value: message,\n        },\n      ],\n    },\n  };\n\n  return _enhanceEventWithInitialFrame(event, url, line, column);\n}\n\n/** JSDoc */\nfunction _enhanceEventWithInitialFrame(event, url, line, column) {\n  // event.exception\n  var e = (event.exception = event.exception || {});\n  // event.exception.values\n  var ev = (e.values = e.values || []);\n  // event.exception.values[0]\n  var ev0 = (ev[0] = ev[0] || {});\n  // event.exception.values[0].stacktrace\n  var ev0s = (ev0.stacktrace = ev0.stacktrace || {});\n  // event.exception.values[0].stacktrace.frames\n  var ev0sf = (ev0s.frames = ev0s.frames || []);\n\n  var colno = isNaN(parseInt(column, 10)) ? undefined : column;\n  var lineno = isNaN(parseInt(line, 10)) ? undefined : line;\n  var filename = isString(url) && url.length > 0 ? url : getLocationHref();\n\n  // event.exception.values[0].stacktrace.frames\n  if (ev0sf.length === 0) {\n    ev0sf.push({\n      colno,\n      filename,\n      function: '?',\n      in_app: true,\n      lineno,\n    });\n  }\n\n  return event;\n}\n\nfunction globalHandlerLog(type) {\n  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`Global Handler attached: ${type}`);\n}\n\nfunction addMechanismAndCapture(hub, error, event, type) {\n  addExceptionMechanism(event, {\n    handled: false,\n    type,\n  });\n  hub.captureEvent(event, {\n    originalException: error,\n  });\n}\n\nfunction getHubAndOptions() {\n  var hub = getCurrentHub();\n  var client = hub.getClient();\n  var options = (client && client.getOptions()) || {\n    stackParser: () => [],\n    attachStacktrace: false,\n  };\n  return [hub, options.stackParser, options.attachStacktrace];\n}\n\nexport { GlobalHandlers };\n//# sourceMappingURL=globalhandlers.js.map\n","import { getCurrentHub, addGlobalEventProcessor } from '@sentry/core';\nimport { isInstanceOf } from '@sentry/utils';\nimport { exceptionFromError } from '../eventbuilder.js';\n\nvar DEFAULT_KEY = 'cause';\nvar DEFAULT_LIMIT = 5;\n\n/** Adds SDK info to an event. */\nclass LinkedErrors  {\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'LinkedErrors';}\n\n  /**\n   * @inheritDoc\n   */\n    __init() {this.name = LinkedErrors.id;}\n\n  /**\n   * @inheritDoc\n   */\n  \n\n  /**\n   * @inheritDoc\n   */\n  \n\n  /**\n   * @inheritDoc\n   */\n   constructor(options = {}) {;LinkedErrors.prototype.__init.call(this);\n    this._key = options.key || DEFAULT_KEY;\n    this._limit = options.limit || DEFAULT_LIMIT;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setupOnce() {\n    var client = getCurrentHub().getClient();\n    if (!client) {\n      return;\n    }\n    addGlobalEventProcessor((event, hint) => {\n      var self = getCurrentHub().getIntegration(LinkedErrors);\n      return self ? _handler(client.getOptions().stackParser, self._key, self._limit, event, hint) : event;\n    });\n  }\n} LinkedErrors.__initStatic();\n\n/**\n * @inheritDoc\n */\nfunction _handler(\n  parser,\n  key,\n  limit,\n  event,\n  hint,\n) {\n  if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {\n    return event;\n  }\n  var linkedErrors = _walkErrorTree(parser, limit, hint.originalException , key);\n  event.exception.values = [...linkedErrors, ...event.exception.values];\n  return event;\n}\n\n/**\n * JSDOC\n */\nfunction _walkErrorTree(\n  parser,\n  limit,\n  error,\n  key,\n  stack = [],\n) {\n  if (!isInstanceOf(error[key], Error) || stack.length + 1 >= limit) {\n    return stack;\n  }\n  var exception = exceptionFromError(parser, error[key]);\n  return _walkErrorTree(parser, limit, error[key], key, [exception, ...stack]);\n}\n\nexport { LinkedErrors, _handler, _walkErrorTree };\n//# sourceMappingURL=linkederrors.js.map\n","import { logger } from '@sentry/utils';\n\n/** Deduplication filter */\nclass Dedupe  {constructor() { Dedupe.prototype.__init.call(this); }\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'Dedupe';}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = Dedupe.id;}\n\n  /**\n   * @inheritDoc\n   */\n  \n\n  /**\n   * @inheritDoc\n   */\n   setupOnce(addGlobalEventProcessor, getCurrentHub) {\n    var eventProcessor = currentEvent => {\n      var self = getCurrentHub().getIntegration(Dedupe);\n      if (self) {\n        // Juuust in case something goes wrong\n        try {\n          if (_shouldDropEvent(currentEvent, self._previousEvent)) {\n            (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Event dropped due to being a duplicate of previously captured event.');\n            return null;\n          }\n        } catch (_oO) {\n          return (self._previousEvent = currentEvent);\n        }\n\n        return (self._previousEvent = currentEvent);\n      }\n      return currentEvent;\n    };\n\n    eventProcessor.id = this.name;\n    addGlobalEventProcessor(eventProcessor);\n  }\n} Dedupe.__initStatic();\n\n/** JSDoc */\nfunction _shouldDropEvent(currentEvent, previousEvent) {\n  if (!previousEvent) {\n    return false;\n  }\n\n  if (_isSameMessageEvent(currentEvent, previousEvent)) {\n    return true;\n  }\n\n  if (_isSameExceptionEvent(currentEvent, previousEvent)) {\n    return true;\n  }\n\n  return false;\n}\n\n/** JSDoc */\nfunction _isSameMessageEvent(currentEvent, previousEvent) {\n  var currentMessage = currentEvent.message;\n  var previousMessage = previousEvent.message;\n\n  // If neither event has a message property, they were both exceptions, so bail out\n  if (!currentMessage && !previousMessage) {\n    return false;\n  }\n\n  // If only one event has a stacktrace, but not the other one, they are not the same\n  if ((currentMessage && !previousMessage) || (!currentMessage && previousMessage)) {\n    return false;\n  }\n\n  if (currentMessage !== previousMessage) {\n    return false;\n  }\n\n  if (!_isSameFingerprint(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  if (!_isSameStacktrace(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  return true;\n}\n\n/** JSDoc */\nfunction _isSameExceptionEvent(currentEvent, previousEvent) {\n  var previousException = _getExceptionFromEvent(previousEvent);\n  var currentException = _getExceptionFromEvent(currentEvent);\n\n  if (!previousException || !currentException) {\n    return false;\n  }\n\n  if (previousException.type !== currentException.type || previousException.value !== currentException.value) {\n    return false;\n  }\n\n  if (!_isSameFingerprint(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  if (!_isSameStacktrace(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  return true;\n}\n\n/** JSDoc */\nfunction _isSameStacktrace(currentEvent, previousEvent) {\n  let currentFrames = _getFramesFromEvent(currentEvent);\n  let previousFrames = _getFramesFromEvent(previousEvent);\n\n  // If neither event has a stacktrace, they are assumed to be the same\n  if (!currentFrames && !previousFrames) {\n    return true;\n  }\n\n  // If only one event has a stacktrace, but not the other one, they are not the same\n  if ((currentFrames && !previousFrames) || (!currentFrames && previousFrames)) {\n    return false;\n  }\n\n  currentFrames = currentFrames ;\n  previousFrames = previousFrames ;\n\n  // If number of frames differ, they are not the same\n  if (previousFrames.length !== currentFrames.length) {\n    return false;\n  }\n\n  // Otherwise, compare the two\n  for (let i = 0; i < previousFrames.length; i++) {\n    var frameA = previousFrames[i];\n    var frameB = currentFrames[i];\n\n    if (\n      frameA.filename !== frameB.filename ||\n      frameA.lineno !== frameB.lineno ||\n      frameA.colno !== frameB.colno ||\n      frameA.function !== frameB.function\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/** JSDoc */\nfunction _isSameFingerprint(currentEvent, previousEvent) {\n  let currentFingerprint = currentEvent.fingerprint;\n  let previousFingerprint = previousEvent.fingerprint;\n\n  // If neither event has a fingerprint, they are assumed to be the same\n  if (!currentFingerprint && !previousFingerprint) {\n    return true;\n  }\n\n  // If only one event has a fingerprint, but not the other one, they are not the same\n  if ((currentFingerprint && !previousFingerprint) || (!currentFingerprint && previousFingerprint)) {\n    return false;\n  }\n\n  currentFingerprint = currentFingerprint ;\n  previousFingerprint = previousFingerprint ;\n\n  // Otherwise, compare the two\n  try {\n    return !!(currentFingerprint.join('') === previousFingerprint.join(''));\n  } catch (_oO) {\n    return false;\n  }\n}\n\n/** JSDoc */\nfunction _getExceptionFromEvent(event) {\n  return event.exception && event.exception.values && event.exception.values[0];\n}\n\n/** JSDoc */\nfunction _getFramesFromEvent(event) {\n  var exception = event.exception;\n\n  if (exception) {\n    try {\n      // @ts-ignore Object could be undefined\n      return exception.values[0].stacktrace.frames;\n    } catch (_oO) {\n      return undefined;\n    }\n  }\n  return undefined;\n}\n\nexport { Dedupe };\n//# sourceMappingURL=dedupe.js.map\n","import { addGlobalEventProcessor, getCurrentHub } from '@sentry/core';\nimport { getGlobalObject } from '@sentry/utils';\n\nvar global = getGlobalObject();\n\n/** HttpContext integration collects information about HTTP request headers */\nclass HttpContext  {constructor() { HttpContext.prototype.__init.call(this); }\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'HttpContext';}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = HttpContext.id;}\n\n  /**\n   * @inheritDoc\n   */\n   setupOnce() {\n    addGlobalEventProcessor((event) => {\n      if (getCurrentHub().getIntegration(HttpContext)) {\n        // if none of the information we want exists, don't bother\n        if (!global.navigator && !global.location && !global.document) {\n          return event;\n        }\n\n        // grab as much info as exists and add it to the event\n        var url = (event.request && event.request.url) || (global.location && global.location.href);\n        const { referrer } = global.document || {};\n        const { userAgent } = global.navigator || {};\n\n        var headers = {\n          ...(event.request && event.request.headers),\n          ...(referrer && { Referer: referrer }),\n          ...(userAgent && { 'User-Agent': userAgent }),\n        };\n        var request = { ...(url && { url }), headers };\n\n        return { ...event, request };\n      }\n      return event;\n    });\n  }\n} HttpContext.__initStatic();\n\nexport { HttpContext };\n//# sourceMappingURL=httpcontext.js.map\n","import { SentryError } from './error.js';\nimport { rejectedSyncPromise, SyncPromise, resolvedSyncPromise } from './syncpromise.js';\n\n/**\n * Creates an new PromiseBuffer object with the specified limit\n * @param limit max number of promises that can be stored in the buffer\n */\nfunction makePromiseBuffer(limit) {\n  var buffer = [];\n\n  function isReady() {\n    return limit === undefined || buffer.length < limit;\n  }\n\n  /**\n   * Remove a promise from the queue.\n   *\n   * @param task Can be any PromiseLike<T>\n   * @returns Removed promise.\n   */\n  function remove(task) {\n    return buffer.splice(buffer.indexOf(task), 1)[0];\n  }\n\n  /**\n   * Add a promise (representing an in-flight action) to the queue, and set it to remove itself on fulfillment.\n   *\n   * @param taskProducer A function producing any PromiseLike<T>; In previous versions this used to be `task:\n   *        PromiseLike<T>`, but under that model, Promises were instantly created on the call-site and their executor\n   *        functions therefore ran immediately. Thus, even if the buffer was full, the action still happened. By\n   *        requiring the promise to be wrapped in a function, we can defer promise creation until after the buffer\n   *        limit check.\n   * @returns The original promise.\n   */\n  function add(taskProducer) {\n    if (!isReady()) {\n      return rejectedSyncPromise(new SentryError('Not adding Promise because buffer limit was reached.'));\n    }\n\n    // start the task and add its promise to the queue\n    var task = taskProducer();\n    if (buffer.indexOf(task) === -1) {\n      buffer.push(task);\n    }\n    void task\n      .then(() => remove(task))\n      // Use `then(null, rejectionHandler)` rather than `catch(rejectionHandler)` so that we can use `PromiseLike`\n      // rather than `Promise`. `PromiseLike` doesn't have a `.catch` method, making its polyfill smaller. (ES5 didn't\n      // have promises, so TS has to polyfill when down-compiling.)\n      .then(null, () =>\n        remove(task).then(null, () => {\n          // We have to add another catch here because `remove()` starts a new promise chain.\n        }),\n      );\n    return task;\n  }\n\n  /**\n   * Wait for all promises in the queue to resolve or for timeout to expire, whichever comes first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the queue is still non-empty. Passing `0` (or\n   * not passing anything) will make the promise wait as long as it takes for the queue to drain before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if the queue is already empty or drains before the timeout, and\n   * `false` otherwise\n   */\n  function drain(timeout) {\n    return new SyncPromise((resolve, reject) => {\n      let counter = buffer.length;\n\n      if (!counter) {\n        return resolve(true);\n      }\n\n      // wait for `timeout` ms and then resolve to `false` (if not cancelled first)\n      var capturedSetTimeout = setTimeout(() => {\n        if (timeout && timeout > 0) {\n          resolve(false);\n        }\n      }, timeout);\n\n      // if all promises resolve in time, cancel the timer and resolve to `true`\n      buffer.forEach(item => {\n        void resolvedSyncPromise(item).then(() => {\n                    if (!--counter) {\n            clearTimeout(capturedSetTimeout);\n            resolve(true);\n          }\n        }, reject);\n      });\n    });\n  }\n\n  return {\n    $: buffer,\n    add,\n    drain,\n  };\n}\n\nexport { makePromiseBuffer };\n//# sourceMappingURL=promisebuffer.js.map\n","// Intentionally keeping the key broad, as we don't know for sure what rate limit headers get returned from backend\n\nvar DEFAULT_RETRY_AFTER = 60 * 1000; // 60 seconds\n\n/**\n * Extracts Retry-After value from the request header or returns default value\n * @param header string representation of 'Retry-After' header\n * @param now current unix timestamp\n *\n */\nfunction parseRetryAfterHeader(header, now = Date.now()) {\n  var headerDelay = parseInt(`${header}`, 10);\n  if (!isNaN(headerDelay)) {\n    return headerDelay * 1000;\n  }\n\n  var headerDate = Date.parse(`${header}`);\n  if (!isNaN(headerDate)) {\n    return headerDate - now;\n  }\n\n  return DEFAULT_RETRY_AFTER;\n}\n\n/**\n * Gets the time that given category is disabled until for rate limiting\n */\nfunction disabledUntil(limits, category) {\n  return limits[category] || limits.all || 0;\n}\n\n/**\n * Checks if a category is rate limited\n */\nfunction isRateLimited(limits, category, now = Date.now()) {\n  return disabledUntil(limits, category) > now;\n}\n\n/**\n * Update ratelimits from incoming headers.\n * Returns true if headers contains a non-empty rate limiting header.\n */\nfunction updateRateLimits(\n  limits,\n  { statusCode, headers },\n  now = Date.now(),\n) {\n  var updatedRateLimits = {\n    ...limits,\n  };\n\n  // \"The name is case-insensitive.\"\n  // https://developer.mozilla.org/en-US/docs/Web/API/Headers/get\n  var rateLimitHeader = headers && headers['x-sentry-rate-limits'];\n  var retryAfterHeader = headers && headers['retry-after'];\n\n  if (rateLimitHeader) {\n    /**\n     * rate limit headers are of the form\n     *     <header>,<header>,..\n     * where each <header> is of the form\n     *     <retry_after>: <categories>: <scope>: <reason_code>\n     * where\n     *     <retry_after> is a delay in seconds\n     *     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form\n     *         <category>;<category>;...\n     *     <scope> is what's being limited (org, project, or key) - ignored by SDK\n     *     <reason_code> is an arbitrary string like \"org_quota\" - ignored by SDK\n     */\n    for (var limit of rateLimitHeader.trim().split(',')) {\n      const [retryAfter, categories] = limit.split(':', 2);\n      var headerDelay = parseInt(retryAfter, 10);\n      var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default\n      if (!categories) {\n        updatedRateLimits.all = now + delay;\n      } else {\n        for (var category of categories.split(';')) {\n          updatedRateLimits[category] = now + delay;\n        }\n      }\n    }\n  } else if (retryAfterHeader) {\n    updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);\n  } else if (statusCode === 429) {\n    updatedRateLimits.all = now + 60 * 1000;\n  }\n\n  return updatedRateLimits;\n}\n\nexport { DEFAULT_RETRY_AFTER, disabledUntil, isRateLimited, parseRetryAfterHeader, updateRateLimits };\n//# sourceMappingURL=ratelimit.js.map\n","import { makePromiseBuffer, forEachEnvelopeItem, envelopeItemTypeToDataCategory, isRateLimited, resolvedSyncPromise, createEnvelope, serializeEnvelope, logger, updateRateLimits, SentryError } from '@sentry/utils';\n\nvar DEFAULT_TRANSPORT_BUFFER_SIZE = 30;\n\n/**\n * Creates an instance of a Sentry `Transport`\n *\n * @param options\n * @param makeRequest\n */\nfunction createTransport(\n  options,\n  makeRequest,\n  buffer = makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE),\n) {\n  let rateLimits = {};\n\n  var flush = (timeout) => buffer.drain(timeout);\n\n  function send(envelope) {\n    var filteredEnvelopeItems = [];\n\n    // Drop rate limited items from envelope\n    forEachEnvelopeItem(envelope, (item, type) => {\n      var envelopeItemDataCategory = envelopeItemTypeToDataCategory(type);\n      if (isRateLimited(rateLimits, envelopeItemDataCategory)) {\n        options.recordDroppedEvent('ratelimit_backoff', envelopeItemDataCategory);\n      } else {\n        filteredEnvelopeItems.push(item);\n      }\n    });\n\n    // Skip sending if envelope is empty after filtering out rate limited events\n    if (filteredEnvelopeItems.length === 0) {\n      return resolvedSyncPromise();\n    }\n\n        var filteredEnvelope = createEnvelope(envelope[0], filteredEnvelopeItems );\n\n    // Creates client report for each item in an envelope\n    var recordEnvelopeLoss = (reason) => {\n      forEachEnvelopeItem(filteredEnvelope, (_, type) => {\n        options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type));\n      });\n    };\n\n    var requestTask = () =>\n      makeRequest({ body: serializeEnvelope(filteredEnvelope, options.textEncoder) }).then(\n        response => {\n          // We don't want to throw on NOK responses, but we want to at least log them\n          if (response.statusCode !== undefined && (response.statusCode < 200 || response.statusCode >= 300)) {\n            (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);\n          }\n\n          rateLimits = updateRateLimits(rateLimits, response);\n        },\n        error => {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Failed while sending event:', error);\n          recordEnvelopeLoss('network_error');\n        },\n      );\n\n    return buffer.add(requestTask).then(\n      result => result,\n      error => {\n        if (error instanceof SentryError) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Skipped sending event because buffer is full.');\n          recordEnvelopeLoss('queue_overflow');\n          return resolvedSyncPromise();\n        } else {\n          throw error;\n        }\n      },\n    );\n  }\n\n  return {\n    send,\n    flush,\n  };\n}\n\nexport { DEFAULT_TRANSPORT_BUFFER_SIZE, createTransport };\n//# sourceMappingURL=base.js.map\n","import { createTransport } from '@sentry/core';\nimport { getNativeFetchImplementation } from './utils.js';\n\n/**\n * Creates a Transport that uses the Fetch API to send events to Sentry.\n */\nfunction makeFetchTransport(\n  options,\n  nativeFetch = getNativeFetchImplementation(),\n) {\n  function makeRequest(request) {\n    var requestOptions = {\n      body: request.body,\n      method: 'POST',\n      referrerPolicy: 'origin',\n      headers: options.headers,\n      // Outgoing requests are usually cancelled when navigating to a different page, causing a \"TypeError: Failed to\n      // fetch\" error and sending a \"network_error\" client-outcome - in Chrome, the request status shows \"(cancelled)\".\n      // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're\n      // frequently sending events right before the user is switching pages (eg. whenfinishing navigation transactions).\n      // Gotchas:\n      // - `keepalive` isn't supported by Firefox\n      // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch), a request with `keepalive: true`\n      //   and a content length of > 64 kibibytes returns a network error. We will therefore only activate the flag when\n      //   we're below that limit.\n      keepalive: request.body.length <= 65536,\n      ...options.fetchOptions,\n    };\n\n    return nativeFetch(options.url, requestOptions).then(response => ({\n      statusCode: response.status,\n      headers: {\n        'x-sentry-rate-limits': response.headers.get('X-Sentry-Rate-Limits'),\n        'retry-after': response.headers.get('Retry-After'),\n      },\n    }));\n  }\n\n  return createTransport(options, makeRequest);\n}\n\nexport { makeFetchTransport };\n//# sourceMappingURL=fetch.js.map\n","import { createTransport } from '@sentry/core';\nimport { SyncPromise } from '@sentry/utils';\n\n/**\n * The DONE ready state for XmlHttpRequest\n *\n * Defining it here as a constant b/c XMLHttpRequest.DONE is not always defined\n * (e.g. during testing, it is `undefined`)\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState}\n */\nvar XHR_READYSTATE_DONE = 4;\n\n/**\n * Creates a Transport that uses the XMLHttpRequest API to send events to Sentry.\n */\nfunction makeXHRTransport(options) {\n  function makeRequest(request) {\n    return new SyncPromise((resolve, reject) => {\n      var xhr = new XMLHttpRequest();\n\n      xhr.onerror = reject;\n\n      xhr.onreadystatechange = () => {\n        if (xhr.readyState === XHR_READYSTATE_DONE) {\n          resolve({\n            statusCode: xhr.status,\n            headers: {\n              'x-sentry-rate-limits': xhr.getResponseHeader('X-Sentry-Rate-Limits'),\n              'retry-after': xhr.getResponseHeader('Retry-After'),\n            },\n          });\n        }\n      };\n\n      xhr.open('POST', options.url);\n\n      for (var header in options.headers) {\n        if (Object.prototype.hasOwnProperty.call(options.headers, header)) {\n          xhr.setRequestHeader(header, options.headers[header]);\n        }\n      }\n\n      xhr.send(request.body);\n    });\n  }\n\n  return createTransport(options, makeRequest);\n}\n\nexport { makeXHRTransport };\n//# sourceMappingURL=xhr.js.map\n","import { Integrations, getIntegrationsToSetup, initAndBind, getCurrentHub, getReportDialogEndpoint } from '@sentry/core';\nimport { getGlobalObject, stackParserFromStackParserOptions, supportsFetch, logger, resolvedSyncPromise, addInstrumentationHandler } from '@sentry/utils';\nimport { BrowserClient } from './client.js';\nimport { wrap as wrap$1 } from './helpers.js';\nimport './integrations/index.js';\nimport { defaultStackParser } from './stack-parsers.js';\nimport './transports/index.js';\nimport { TryCatch } from './integrations/trycatch.js';\nimport { Breadcrumbs } from './integrations/breadcrumbs.js';\nimport { GlobalHandlers } from './integrations/globalhandlers.js';\nimport { LinkedErrors } from './integrations/linkederrors.js';\nimport { Dedupe } from './integrations/dedupe.js';\nimport { HttpContext } from './integrations/httpcontext.js';\nimport { makeFetchTransport } from './transports/fetch.js';\nimport { makeXHRTransport } from './transports/xhr.js';\n\nvar defaultIntegrations = [\n  new Integrations.InboundFilters(),\n  new Integrations.FunctionToString(),\n  new TryCatch(),\n  new Breadcrumbs(),\n  new GlobalHandlers(),\n  new LinkedErrors(),\n  new Dedupe(),\n  new HttpContext(),\n];\n\n/**\n * The Sentry Browser SDK Client.\n *\n * To use this SDK, call the {@link init} function as early as possible when\n * loading the web page. To set context information or send manual events, use\n * the provided methods.\n *\n * @example\n *\n * ```\n *\n * import { init } from '@sentry/browser';\n *\n * init({\n *   dsn: '__DSN__',\n *   // ...\n * });\n * ```\n *\n * @example\n * ```\n *\n * import { configureScope } from '@sentry/browser';\n * configureScope((scope: Scope) => {\n *   scope.setExtra({ battery: 0.7 });\n *   scope.setTag({ user_mode: 'admin' });\n *   scope.setUser({ id: '4711' });\n * });\n * ```\n *\n * @example\n * ```\n *\n * import { addBreadcrumb } from '@sentry/browser';\n * addBreadcrumb({\n *   message: 'My Breadcrumb',\n *   // ...\n * });\n * ```\n *\n * @example\n *\n * ```\n *\n * import * as Sentry from '@sentry/browser';\n * Sentry.captureMessage('Hello, world!');\n * Sentry.captureException(new Error('Good bye'));\n * Sentry.captureEvent({\n *   message: 'Manual',\n *   stacktrace: [\n *     // ...\n *   ],\n * });\n * ```\n *\n * @see {@link BrowserOptions} for documentation on configuration options.\n */\nfunction init(options = {}) {\n  if (options.defaultIntegrations === undefined) {\n    options.defaultIntegrations = defaultIntegrations;\n  }\n  if (options.release === undefined) {\n    var window = getGlobalObject();\n    // This supports the variable that sentry-webpack-plugin injects\n    if (window.SENTRY_RELEASE && window.SENTRY_RELEASE.id) {\n      options.release = window.SENTRY_RELEASE.id;\n    }\n  }\n  if (options.autoSessionTracking === undefined) {\n    options.autoSessionTracking = true;\n  }\n  if (options.sendClientReports === undefined) {\n    options.sendClientReports = true;\n  }\n\n  var clientOptions = {\n    ...options,\n    stackParser: stackParserFromStackParserOptions(options.stackParser || defaultStackParser),\n    integrations: getIntegrationsToSetup(options),\n    transport: options.transport || (supportsFetch() ? makeFetchTransport : makeXHRTransport),\n  };\n\n  initAndBind(BrowserClient, clientOptions);\n\n  if (options.autoSessionTracking) {\n    startSessionTracking();\n  }\n}\n\n/**\n * Present the user with a report dialog.\n *\n * @param options Everything is optional, we try to fetch all info need from the global scope.\n */\nfunction showReportDialog(options = {}, hub = getCurrentHub()) {\n  // doesn't work without a document (React Native)\n  var global = getGlobalObject();\n  if (!global.document) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Global document not defined in showReportDialog call');\n    return;\n  }\n\n  const { client, scope } = hub.getStackTop();\n  var dsn = options.dsn || (client && client.getDsn());\n  if (!dsn) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('DSN not configured for showReportDialog call');\n    return;\n  }\n\n  if (scope) {\n    options.user = {\n      ...scope.getUser(),\n      ...options.user,\n    };\n  }\n\n  if (!options.eventId) {\n    options.eventId = hub.lastEventId();\n  }\n\n  var script = global.document.createElement('script');\n  script.async = true;\n  script.src = getReportDialogEndpoint(dsn, options);\n\n  if (options.onLoad) {\n        script.onload = options.onLoad;\n  }\n\n  var injectionPoint = global.document.head || global.document.body;\n  if (injectionPoint) {\n    injectionPoint.appendChild(script);\n  } else {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Not injecting report dialog. No injection point found in HTML');\n  }\n}\n\n/**\n * This is the getter for lastEventId.\n *\n * @returns The last event id of a captured event.\n */\nfunction lastEventId() {\n  return getCurrentHub().lastEventId();\n}\n\n/**\n * This function is here to be API compatible with the loader.\n * @hidden\n */\nfunction forceLoad() {\n  // Noop\n}\n\n/**\n * This function is here to be API compatible with the loader.\n * @hidden\n */\nfunction onLoad(callback) {\n  callback();\n}\n\n/**\n * Call `flush()` on the current client, if there is one. See {@link Client.flush}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause\n * the client to wait until all events are sent before resolving the promise.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nfunction flush(timeout) {\n  var client = getCurrentHub().getClient();\n  if (client) {\n    return client.flush(timeout);\n  }\n  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Cannot flush events. No client defined.');\n  return resolvedSyncPromise(false);\n}\n\n/**\n * Call `close()` on the current client, if there is one. See {@link Client.close}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this\n * parameter will cause the client to wait until all events are sent before disabling itself.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nfunction close(timeout) {\n  var client = getCurrentHub().getClient();\n  if (client) {\n    return client.close(timeout);\n  }\n  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Cannot flush events and disable SDK. No client defined.');\n  return resolvedSyncPromise(false);\n}\n\n/**\n * Wrap code within a try/catch block so the SDK is able to capture errors.\n *\n * @param fn A function to wrap.\n *\n * @returns The result of wrapped function call.\n */\nfunction wrap(fn) {\n  return wrap$1(fn)();\n}\n\nfunction startSessionOnHub(hub) {\n  hub.startSession({ ignoreDuration: true });\n  hub.captureSession();\n}\n\n/**\n * Enable automatic Session Tracking for the initial page load.\n */\nfunction startSessionTracking() {\n  var window = getGlobalObject();\n  var document = window.document;\n\n  if (typeof document === 'undefined') {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.warn('Session tracking in non-browser environment with @sentry/browser is not supported.');\n    return;\n  }\n\n  var hub = getCurrentHub();\n\n  // The only way for this to be false is for there to be a version mismatch between @sentry/browser (>= 6.0.0) and\n  // @sentry/hub (< 5.27.0). In the simple case, there won't ever be such a mismatch, because the two packages are\n  // pinned at the same version in package.json, but there are edge cases where it's possible. See\n  // https://github.com/getsentry/sentry-javascript/issues/3207 and\n  // https://github.com/getsentry/sentry-javascript/issues/3234 and\n  // https://github.com/getsentry/sentry-javascript/issues/3278.\n  if (!hub.captureSession) {\n    return;\n  }\n\n  // The session duration for browser sessions does not track a meaningful\n  // concept that can be used as a metric.\n  // Automatically captured sessions are akin to page views, and thus we\n  // discard their duration.\n  startSessionOnHub(hub);\n\n  // We want to create a session for every navigation as well\n  addInstrumentationHandler('history', ({ from, to }) => {\n    // Don't create an additional session for the initial route or if the location did not change\n    if (!(from === undefined || from === to)) {\n      startSessionOnHub(getCurrentHub());\n    }\n  });\n}\n\nexport { close, defaultIntegrations, flush, forceLoad, init, lastEventId, onLoad, showReportDialog, wrap };\n//# sourceMappingURL=sdk.js.map\n","import { SDK_VERSION, init as init$1 } from '@sentry/browser';\n\n/**\n * Inits the React SDK\n */\nfunction init(options) {\n  options._metadata = options._metadata || {};\n  options._metadata.sdk = options._metadata.sdk || {\n    name: 'sentry.javascript.react',\n    packages: [\n      {\n        name: 'npm:@sentry/react',\n        version: SDK_VERSION,\n      },\n    ],\n    version: SDK_VERSION,\n  };\n  init$1(options);\n}\n\nexport { init };\n//# sourceMappingURL=sdk.js.map\n","var TRACEPARENT_REGEXP = new RegExp(\n  '^[ \\\\t]*' + // whitespace\n    '([0-9a-f]{32})?' + // trace_id\n    '-?([0-9a-f]{16})?' + // span_id\n    '-?([01])?' + // sampled\n    '[ \\\\t]*$', // whitespace\n);\n\n/**\n * Extract transaction context data from a `sentry-trace` header.\n *\n * @param traceparent Traceparent string\n *\n * @returns Object containing data from the header, or undefined if traceparent string is malformed\n */\nfunction extractTraceparentData(traceparent) {\n  var matches = traceparent.match(TRACEPARENT_REGEXP);\n\n  if (!traceparent || !matches) {\n    // empty string or no matches is invalid traceparent data\n    return undefined;\n  }\n\n  let parentSampled;\n  if (matches[3] === '1') {\n    parentSampled = true;\n  } else if (matches[3] === '0') {\n    parentSampled = false;\n  }\n\n  return {\n    traceId: matches[1],\n    parentSampled,\n    parentSpanId: matches[2],\n  };\n}\n\nexport { TRACEPARENT_REGEXP, extractTraceparentData };\n//# sourceMappingURL=tracing.js.map\n","import { isString } from './is.js';\nimport { logger } from './logger.js';\n\nvar BAGGAGE_HEADER_NAME = 'baggage';\n\nvar SENTRY_BAGGAGE_KEY_PREFIX = 'sentry-';\n\nvar SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;\n\n/**\n * Max length of a serialized baggage string\n *\n * https://www.w3.org/TR/baggage/#limits\n */\nvar MAX_BAGGAGE_STRING_LENGTH = 8192;\n\n/**\n * Takes a baggage header and turns it into Dynamic Sampling Context, by extracting all the \"sentry-\" prefixed values\n * from it.\n *\n * @param baggageHeader A very bread definition of a baggage header as it might appear in various frameworks.\n * @returns The Dynamic Sampling Context that was found on `baggageHeader`, if there was any, `undefined` otherwise.\n */\nfunction baggageHeaderToDynamicSamplingContext(\n  // Very liberal definition of what any incoming header might look like\n  baggageHeader,\n) {\n  if (!isString(baggageHeader) && !Array.isArray(baggageHeader)) {\n    return undefined;\n  }\n\n  // Intermediary object to store baggage key value pairs of incoming baggage headers on.\n  // It is later used to read Sentry-DSC-values from.\n  let baggageObject = {};\n\n  if (Array.isArray(baggageHeader)) {\n    // Combine all baggage headers into one object containing the baggage values so we can later read the Sentry-DSC-values from it\n    baggageObject = baggageHeader.reduce((acc, curr) => {\n      var currBaggageObject = baggageHeaderToObject(curr);\n      return {\n        ...acc,\n        ...currBaggageObject,\n      };\n    }, {});\n  } else {\n    // Return undefined if baggage header is an empty string (technically an empty baggage header is not spec conform but\n    // this is how we choose to handle it)\n    if (!baggageHeader) {\n      return undefined;\n    }\n\n    baggageObject = baggageHeaderToObject(baggageHeader);\n  }\n\n  // Read all \"sentry-\" prefixed values out of the baggage object and put it onto a dynamic sampling context object.\n  var dynamicSamplingContext = Object.entries(baggageObject).reduce((acc, [key, value]) => {\n    if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {\n      var nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);\n      acc[nonPrefixedKey] = value;\n    }\n    return acc;\n  }, {});\n\n  // Only return a dynamic sampling context object if there are keys in it.\n  // A keyless object means there were no sentry values on the header, which means that there is no DSC.\n  if (Object.keys(dynamicSamplingContext).length > 0) {\n    return dynamicSamplingContext ;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Turns a Dynamic Sampling Object into a baggage header by prefixing all the keys on the object with \"sentry-\".\n *\n * @param dynamicSamplingContext The Dynamic Sampling Context to turn into a header. For convenience and compatibility\n * with the `getDynamicSamplingContext` method on the Transaction class ,this argument can also be `undefined`. If it is\n * `undefined` the function will return `undefined`.\n * @returns a baggage header, created from `dynamicSamplingContext`, or `undefined` either if `dynamicSamplingContext`\n * was `undefined`, or if `dynamicSamplingContext` didn't contain any values.\n */\nfunction dynamicSamplingContextToSentryBaggageHeader(\n  // this also takes undefined for convenience and bundle size in other places\n  dynamicSamplingContext,\n) {\n  // Prefix all DSC keys with \"sentry-\" and put them into a new object\n  var sentryPrefixedDSC = Object.entries(dynamicSamplingContext).reduce(\n    (acc, [dscKey, dscValue]) => {\n      if (dscValue) {\n        acc[`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`] = dscValue;\n      }\n      return acc;\n    },\n    {},\n  );\n\n  return objectToBaggageHeader(sentryPrefixedDSC);\n}\n\n/**\n * Will parse a baggage header, which is a simple key-value map, into a flat object.\n *\n * @param baggageHeader The baggage header to parse.\n * @returns a flat object containing all the key-value pairs from `baggageHeader`.\n */\nfunction baggageHeaderToObject(baggageHeader) {\n  return baggageHeader\n    .split(',')\n    .map(baggageEntry => baggageEntry.split('=').map(keyOrValue => decodeURIComponent(keyOrValue.trim())))\n    .reduce((acc, [key, value]) => {\n      acc[key] = value;\n      return acc;\n    }, {});\n}\n\n/**\n * Turns a flat object (key-value pairs) into a baggage header, which is also just key-value pairs.\n *\n * @param object The object to turn into a baggage header.\n * @returns a baggage header string, or `undefined` if the object didn't have any values, since an empty baggage header\n * is not spec compliant.\n */\nfunction objectToBaggageHeader(object) {\n  if (Object.keys(object).length === 0) {\n    // An empty baggage header is not spec compliant: We return undefined.\n    return undefined;\n  }\n\n  return Object.entries(object).reduce((baggageHeader, [objectKey, objectValue], currentIndex) => {\n    var baggageEntry = `${encodeURIComponent(objectKey)}=${encodeURIComponent(objectValue)}`;\n    var newBaggageHeader = currentIndex === 0 ? baggageEntry : `${baggageHeader},${baggageEntry}`;\n    if (newBaggageHeader.length > MAX_BAGGAGE_STRING_LENGTH) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        logger.warn(\n          `Not adding key: ${objectKey} with val: ${objectValue} to baggage header due to exceeding baggage size limits.`,\n        );\n      return baggageHeader;\n    } else {\n      return newBaggageHeader;\n    }\n  }, '');\n}\n\nexport { BAGGAGE_HEADER_NAME, MAX_BAGGAGE_STRING_LENGTH, SENTRY_BAGGAGE_KEY_PREFIX, SENTRY_BAGGAGE_KEY_PREFIX_REGEX, baggageHeaderToDynamicSamplingContext, dynamicSamplingContextToSentryBaggageHeader };\n//# sourceMappingURL=baggage.js.map\n","import { getGlobalObject, logger } from '@sentry/utils';\nimport { getActiveTransaction } from '../utils.js';\n\nvar global = getGlobalObject();\n\n/**\n * Add a listener that cancels and finishes a transaction when the global\n * document is hidden.\n */\nfunction registerBackgroundTabDetection() {\n  if (global && global.document) {\n    global.document.addEventListener('visibilitychange', () => {\n      var activeTransaction = getActiveTransaction() ;\n      if (global.document.hidden && activeTransaction) {\n        var statusType = 'cancelled';\n\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n          logger.log(\n            `[Tracing] Transaction: ${statusType} -> since tab moved to the background, op: ${activeTransaction.op}`,\n          );\n        // We should not set status if it is already set, this prevent important statuses like\n        // error or data loss from being overwritten on transaction.\n        if (!activeTransaction.status) {\n          activeTransaction.setStatus(statusType);\n        }\n        activeTransaction.setTag('visibilitychange', 'document.hidden');\n        activeTransaction.finish();\n      }\n    });\n  } else {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.warn('[Tracing] Could not set up background tab detection due to lack of global document');\n  }\n}\n\nexport { registerBackgroundTabDetection };\n//# sourceMappingURL=backgroundtab.js.map\n","var bindReporter = (\n  callback,\n  metric,\n  reportAllChanges,\n) => {\n  let prevValue;\n  return (forceReport) => {\n    if (metric.value >= 0) {\n      if (forceReport || reportAllChanges) {\n        metric.delta = metric.value - (prevValue || 0);\n\n        // Report the metric if there's a non-zero delta or if no previous\n        // value exists (which can happen in the case of the document becoming\n        // hidden when the metric value is 0).\n        // See: https://github.com/GoogleChrome/web-vitals/issues/14\n        if (metric.delta || prevValue === undefined) {\n          prevValue = metric.value;\n          callback(metric);\n        }\n      }\n    }\n  };\n};\n\nexport { bindReporter };\n//# sourceMappingURL=bindReporter.js.map\n","/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Performantly generate a unique, 30-char string by combining a version\n * number, the current timestamp with a 13-digit number integer.\n * @return {string}\n */\nvar generateUniqueID = () => {\n  return `v2-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`;\n};\n\nexport { generateUniqueID };\n//# sourceMappingURL=generateUniqueID.js.map\n","import { _nullishCoalesce } from '@sentry/utils/esm/buildPolyfills';\nimport { generateUniqueID } from './generateUniqueID.js';\n\nvar initMetric = (name, value) => {\n  return {\n    name,\n    value: _nullishCoalesce(value, () => ( -1)),\n    delta: 0,\n    entries: [],\n    id: generateUniqueID(),\n  };\n};\n\nexport { initMetric };\n//# sourceMappingURL=initMetric.js.map\n","/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Takes a performance entry type and a callback function, and creates a\n * `PerformanceObserver` instance that will observe the specified entry type\n * with buffering enabled and call the callback _for each entry_.\n *\n * This function also feature-detects entry support and wraps the logic in a\n * try/catch to avoid errors in unsupporting browsers.\n */\nvar observe = (type, callback) => {\n  try {\n    if (PerformanceObserver.supportedEntryTypes.includes(type)) {\n      // More extensive feature detect needed for Firefox due to:\n      // https://github.com/GoogleChrome/web-vitals/issues/142\n      if (type === 'first-input' && !('PerformanceEventTiming' in self)) {\n        return;\n      }\n\n      var po = new PerformanceObserver(l => l.getEntries().map(callback));\n\n      po.observe({ type, buffered: true });\n      return po;\n    }\n  } catch (e) {\n    // Do nothing.\n  }\n  return;\n};\n\nexport { observe };\n//# sourceMappingURL=observe.js.map\n","import { getGlobalObject } from '@sentry/utils';\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar onHidden = (cb, once) => {\n  var onHiddenOrPageHide = (event) => {\n    if (event.type === 'pagehide' || getGlobalObject().document.visibilityState === 'hidden') {\n      cb(event);\n      if (once) {\n        removeEventListener('visibilitychange', onHiddenOrPageHide, true);\n        removeEventListener('pagehide', onHiddenOrPageHide, true);\n      }\n    }\n  };\n  addEventListener('visibilitychange', onHiddenOrPageHide, true);\n  // Some browsers have buggy implementations of visibilitychange,\n  // so we use pagehide in addition, just to be safe.\n  addEventListener('pagehide', onHiddenOrPageHide, true);\n};\n\nexport { onHidden };\n//# sourceMappingURL=onHidden.js.map\n","import { bindReporter } from './lib/bindReporter.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { observe } from './lib/observe.js';\nimport { onHidden } from './lib/onHidden.js';\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// https://wicg.github.io/layout-instability/#sec-layout-shift\n\nvar getCLS = (onReport, reportAllChanges) => {\n  var metric = initMetric('CLS', 0);\n  let report;\n\n  let sessionValue = 0;\n  let sessionEntries = [];\n\n  var entryHandler = (entry) => {\n    // Only count layout shifts without recent user input.\n    // TODO: Figure out why entry can be undefined\n    if (entry && !entry.hadRecentInput) {\n      var firstSessionEntry = sessionEntries[0];\n      var lastSessionEntry = sessionEntries[sessionEntries.length - 1];\n\n      // If the entry occurred less than 1 second after the previous entry and\n      // less than 5 seconds after the first entry in the session, include the\n      // entry in the current session. Otherwise, start a new session.\n      if (\n        sessionValue &&\n        sessionEntries.length !== 0 &&\n        entry.startTime - lastSessionEntry.startTime < 1000 &&\n        entry.startTime - firstSessionEntry.startTime < 5000\n      ) {\n        sessionValue += entry.value;\n        sessionEntries.push(entry);\n      } else {\n        sessionValue = entry.value;\n        sessionEntries = [entry];\n      }\n\n      // If the current session value is larger than the current CLS value,\n      // update CLS and the entries contributing to it.\n      if (sessionValue > metric.value) {\n        metric.value = sessionValue;\n        metric.entries = sessionEntries;\n        if (report) {\n          report();\n        }\n      }\n    }\n  };\n\n  var po = observe('layout-shift', entryHandler );\n  if (po) {\n    report = bindReporter(onReport, metric, reportAllChanges);\n\n    onHidden(() => {\n      po.takeRecords().map(entryHandler );\n      report(true);\n    });\n  }\n};\n\nexport { getCLS };\n//# sourceMappingURL=getCLS.js.map\n","import { getGlobalObject } from '@sentry/utils';\nimport { onHidden } from './onHidden.js';\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nlet firstHiddenTime = -1;\n\nvar initHiddenTime = () => {\n  return getGlobalObject().document.visibilityState === 'hidden' ? 0 : Infinity;\n};\n\nvar trackChanges = () => {\n  // Update the time if/when the document becomes hidden.\n  onHidden(({ timeStamp }) => {\n    firstHiddenTime = timeStamp;\n  }, true);\n};\n\nvar getVisibilityWatcher = (\n\n) => {\n  if (firstHiddenTime < 0) {\n    // If the document is hidden when this code runs, assume it was hidden\n    // since navigation start. This isn't a perfect heuristic, but it's the\n    // best we can do until an API is available to support querying past\n    // visibilityState.\n    firstHiddenTime = initHiddenTime();\n    trackChanges();\n  }\n  return {\n    get firstHiddenTime() {\n      return firstHiddenTime;\n    },\n  };\n};\n\nexport { getVisibilityWatcher };\n//# sourceMappingURL=getVisibilityWatcher.js.map\n","import { bindReporter } from './lib/bindReporter.js';\nimport { getVisibilityWatcher } from './lib/getVisibilityWatcher.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { observe } from './lib/observe.js';\nimport { onHidden } from './lib/onHidden.js';\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar getFID = (onReport, reportAllChanges) => {\n  var visibilityWatcher = getVisibilityWatcher();\n  var metric = initMetric('FID');\n  let report;\n\n  var entryHandler = (entry) => {\n    // Only report if the page wasn't hidden prior to the first input.\n    if (report && entry.startTime < visibilityWatcher.firstHiddenTime) {\n      metric.value = entry.processingStart - entry.startTime;\n      metric.entries.push(entry);\n      report(true);\n    }\n  };\n\n  var po = observe('first-input', entryHandler );\n  if (po) {\n    report = bindReporter(onReport, metric, reportAllChanges);\n    onHidden(() => {\n      po.takeRecords().map(entryHandler );\n      po.disconnect();\n    }, true);\n  }\n};\n\nexport { getFID };\n//# sourceMappingURL=getFID.js.map\n","import { bindReporter } from './lib/bindReporter.js';\nimport { getVisibilityWatcher } from './lib/getVisibilityWatcher.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { observe } from './lib/observe.js';\nimport { onHidden } from './lib/onHidden.js';\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// https://wicg.github.io/largest-contentful-paint/#sec-largest-contentful-paint-interface\n\nvar reportedMetricIDs = {};\n\nvar getLCP = (onReport, reportAllChanges) => {\n  var visibilityWatcher = getVisibilityWatcher();\n  var metric = initMetric('LCP');\n  let report;\n\n  var entryHandler = (entry) => {\n    // The startTime attribute returns the value of the renderTime if it is not 0,\n    // and the value of the loadTime otherwise.\n    var value = entry.startTime;\n\n    // If the page was hidden prior to paint time of the entry,\n    // ignore it and mark the metric as final, otherwise add the entry.\n    if (value < visibilityWatcher.firstHiddenTime) {\n      metric.value = value;\n      metric.entries.push(entry);\n    }\n\n    if (report) {\n      report();\n    }\n  };\n\n  var po = observe('largest-contentful-paint', entryHandler);\n\n  if (po) {\n    report = bindReporter(onReport, metric, reportAllChanges);\n\n    var stopListening = () => {\n      if (!reportedMetricIDs[metric.id]) {\n        po.takeRecords().map(entryHandler );\n        po.disconnect();\n        reportedMetricIDs[metric.id] = true;\n        report(true);\n      }\n    };\n\n    // Stop listening after input. Note: while scrolling is an input that\n    // stop LCP observation, it's unreliable since it can be programmatically\n    // generated. See: https://github.com/GoogleChrome/web-vitals/issues/75\n    ['keydown', 'click'].forEach(type => {\n      addEventListener(type, stopListening, { once: true, capture: true });\n    });\n\n    onHidden(stopListening, true);\n  }\n};\n\nexport { getLCP };\n//# sourceMappingURL=getLCP.js.map\n","/**\n * Checks if a given value is a valid measurement value.\n */\nfunction isMeasurementValue(value) {\n  return typeof value === 'number' && isFinite(value);\n}\n\n/**\n * Helper function to start child on transactions. This function will make sure that the transaction will\n * use the start timestamp of the created child span if it is earlier than the transactions actual\n * start timestamp.\n */\nfunction _startChild(transaction, { startTimestamp, ...ctx }) {\n  if (startTimestamp && transaction.startTimestamp > startTimestamp) {\n    transaction.startTimestamp = startTimestamp;\n  }\n\n  return transaction.startChild({\n    startTimestamp,\n    ...ctx,\n  });\n}\n\nexport { _startChild, isMeasurementValue };\n//# sourceMappingURL=utils.js.map\n","import { _nullishCoalesce } from '@sentry/utils/esm/buildPolyfills';\nimport { getGlobalObject, browserPerformanceTimeOrigin, logger, htmlTreeAsString } from '@sentry/utils';\nimport { getActiveTransaction, msToSec } from '../../utils.js';\nimport { getCLS } from '../web-vitals/getCLS.js';\nimport { getFID } from '../web-vitals/getFID.js';\nimport { getLCP } from '../web-vitals/getLCP.js';\nimport { getVisibilityWatcher } from '../web-vitals/lib/getVisibilityWatcher.js';\nimport { observe } from '../web-vitals/lib/observe.js';\nimport { _startChild, isMeasurementValue } from './utils.js';\n\nvar global = getGlobalObject();\n\nfunction getBrowserPerformanceAPI() {\n  return global && global.addEventListener && global.performance;\n}\n\nlet _performanceCursor = 0;\n\nlet _measurements = {};\nlet _lcpEntry;\nlet _clsEntry;\n\n/**\n * Start tracking web vitals\n */\nfunction startTrackingWebVitals(reportAllChanges = false) {\n  var performance = getBrowserPerformanceAPI();\n  if (performance && browserPerformanceTimeOrigin) {\n    if (performance.mark) {\n      global.performance.mark('sentry-tracing-init');\n    }\n    _trackCLS();\n    _trackLCP(reportAllChanges);\n    _trackFID();\n  }\n}\n\n/**\n * Start tracking long tasks.\n */\nfunction startTrackingLongTasks() {\n  var entryHandler = (entry) => {\n    var transaction = getActiveTransaction() ;\n    if (!transaction) {\n      return;\n    }\n    var startTime = msToSec((browserPerformanceTimeOrigin ) + entry.startTime);\n    var duration = msToSec(entry.duration);\n    transaction.startChild({\n      description: 'Main UI thread blocked',\n      op: 'ui.long-task',\n      startTimestamp: startTime,\n      endTimestamp: startTime + duration,\n    });\n  };\n\n  observe('longtask', entryHandler);\n}\n\n/** Starts tracking the Cumulative Layout Shift on the current page. */\nfunction _trackCLS() {\n  // See:\n  // https://web.dev/evolving-cls/\n  // https://web.dev/cls-web-tooling/\n  getCLS(metric => {\n    var entry = metric.entries.pop();\n    if (!entry) {\n      return;\n    }\n\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Measurements] Adding CLS');\n    _measurements['cls'] = { value: metric.value, unit: '' };\n    _clsEntry = entry ;\n  });\n}\n\n/** Starts tracking the Largest Contentful Paint on the current page. */\nfunction _trackLCP(reportAllChanges) {\n  getLCP(metric => {\n    var entry = metric.entries.pop();\n    if (!entry) {\n      return;\n    }\n\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Measurements] Adding LCP');\n    _measurements['lcp'] = { value: metric.value, unit: 'millisecond' };\n    _lcpEntry = entry ;\n  }, reportAllChanges);\n}\n\n/** Starts tracking the First Input Delay on the current page. */\nfunction _trackFID() {\n  getFID(metric => {\n    var entry = metric.entries.pop();\n    if (!entry) {\n      return;\n    }\n\n    var timeOrigin = msToSec(browserPerformanceTimeOrigin );\n    var startTime = msToSec(entry.startTime);\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Measurements] Adding FID');\n    _measurements['fid'] = { value: metric.value, unit: 'millisecond' };\n    _measurements['mark.fid'] = { value: timeOrigin + startTime, unit: 'second' };\n  });\n}\n\n/** Add performance related spans to a transaction */\nfunction addPerformanceEntries(transaction) {\n  var performance = getBrowserPerformanceAPI();\n  if (!performance || !global.performance.getEntries || !browserPerformanceTimeOrigin) {\n    // Gatekeeper if performance API not available\n    return;\n  }\n\n  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] Adding & adjusting spans using Performance API');\n  var timeOrigin = msToSec(browserPerformanceTimeOrigin);\n\n  var performanceEntries = performance.getEntries();\n\n  let responseStartTimestamp;\n  let requestStartTimestamp;\n\n    performanceEntries.slice(_performanceCursor).forEach((entry) => {\n    var startTime = msToSec(entry.startTime);\n    var duration = msToSec(entry.duration);\n\n    if (transaction.op === 'navigation' && timeOrigin + startTime < transaction.startTimestamp) {\n      return;\n    }\n\n    switch (entry.entryType) {\n      case 'navigation': {\n        _addNavigationSpans(transaction, entry, timeOrigin);\n        responseStartTimestamp = timeOrigin + msToSec(entry.responseStart);\n        requestStartTimestamp = timeOrigin + msToSec(entry.requestStart);\n        break;\n      }\n      case 'mark':\n      case 'paint':\n      case 'measure': {\n        _addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);\n\n        // capture web vitals\n        var firstHidden = getVisibilityWatcher();\n        // Only report if the page wasn't hidden prior to the web vital.\n        var shouldRecord = entry.startTime < firstHidden.firstHiddenTime;\n\n        if (entry.name === 'first-paint' && shouldRecord) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Measurements] Adding FP');\n          _measurements['fp'] = { value: entry.startTime, unit: 'millisecond' };\n        }\n        if (entry.name === 'first-contentful-paint' && shouldRecord) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Measurements] Adding FCP');\n          _measurements['fcp'] = { value: entry.startTime, unit: 'millisecond' };\n        }\n        break;\n      }\n      case 'resource': {\n        var resourceName = (entry.name ).replace(global.location.origin, '');\n        _addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);\n        break;\n      }\n      default:\n      // Ignore other entry types.\n    }\n  });\n\n  _performanceCursor = Math.max(performanceEntries.length - 1, 0);\n\n  _trackNavigator(transaction);\n\n  // Measurements are only available for pageload transactions\n  if (transaction.op === 'pageload') {\n    // Generate TTFB (Time to First Byte), which measured as the time between the beginning of the transaction and the\n    // start of the response in milliseconds\n    if (typeof responseStartTimestamp === 'number') {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Measurements] Adding TTFB');\n      _measurements['ttfb'] = {\n        value: (responseStartTimestamp - transaction.startTimestamp) * 1000,\n        unit: 'millisecond',\n      };\n\n      if (typeof requestStartTimestamp === 'number' && requestStartTimestamp <= responseStartTimestamp) {\n        // Capture the time spent making the request and receiving the first byte of the response.\n        // This is the time between the start of the request and the start of the response in milliseconds.\n        _measurements['ttfb.requestTime'] = {\n          value: (responseStartTimestamp - requestStartTimestamp) * 1000,\n          unit: 'millisecond',\n        };\n      }\n    }\n\n    ['fcp', 'fp', 'lcp'].forEach(name => {\n      if (!_measurements[name] || timeOrigin >= transaction.startTimestamp) {\n        return;\n      }\n      // The web vitals, fcp, fp, lcp, and ttfb, all measure relative to timeOrigin.\n      // Unfortunately, timeOrigin is not captured within the transaction span data, so these web vitals will need\n      // to be adjusted to be relative to transaction.startTimestamp.\n      var oldValue = _measurements[name].value;\n      var measurementTimestamp = timeOrigin + msToSec(oldValue);\n\n      // normalizedValue should be in milliseconds\n      var normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1000);\n      var delta = normalizedValue - oldValue;\n\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        logger.log(`[Measurements] Normalized ${name} from ${oldValue} to ${normalizedValue} (${delta})`);\n      _measurements[name].value = normalizedValue;\n    });\n\n    var fidMark = _measurements['mark.fid'];\n    if (fidMark && _measurements['fid']) {\n      // create span for FID\n      _startChild(transaction, {\n        description: 'first input delay',\n        endTimestamp: fidMark.value + msToSec(_measurements['fid'].value),\n        op: 'web.vitals',\n        startTimestamp: fidMark.value,\n      });\n\n      // Delete mark.fid as we don't want it to be part of final payload\n      delete _measurements['mark.fid'];\n    }\n\n    // If FCP is not recorded we should not record the cls value\n    // according to the new definition of CLS.\n    if (!('fcp' in _measurements)) {\n      delete _measurements.cls;\n    }\n\n    Object.keys(_measurements).forEach(measurementName => {\n      transaction.setMeasurement(\n        measurementName,\n        _measurements[measurementName].value,\n        _measurements[measurementName].unit,\n      );\n    });\n\n    _tagMetricInfo(transaction);\n  }\n\n  _lcpEntry = undefined;\n  _clsEntry = undefined;\n  _measurements = {};\n}\n\n/** Create measure related spans */\nfunction _addMeasureSpans(\n  transaction,\n    entry,\n  startTime,\n  duration,\n  timeOrigin,\n) {\n  var measureStartTimestamp = timeOrigin + startTime;\n  var measureEndTimestamp = measureStartTimestamp + duration;\n\n  _startChild(transaction, {\n    description: entry.name ,\n    endTimestamp: measureEndTimestamp,\n    op: entry.entryType ,\n    startTimestamp: measureStartTimestamp,\n  });\n\n  return measureStartTimestamp;\n}\n\n/** Instrument navigation entries */\nfunction _addNavigationSpans(transaction, entry, timeOrigin) {\n  ['unloadEvent', 'redirect', 'domContentLoadedEvent', 'loadEvent', 'connect'].forEach(event => {\n    _addPerformanceNavigationTiming(transaction, entry, event, timeOrigin);\n  });\n  _addPerformanceNavigationTiming(transaction, entry, 'secureConnection', timeOrigin, 'TLS/SSL', 'connectEnd');\n  _addPerformanceNavigationTiming(transaction, entry, 'fetch', timeOrigin, 'cache', 'domainLookupStart');\n  _addPerformanceNavigationTiming(transaction, entry, 'domainLookup', timeOrigin, 'DNS');\n  _addRequest(transaction, entry, timeOrigin);\n}\n\n/** Create performance navigation related spans */\nfunction _addPerformanceNavigationTiming(\n  transaction,\n    entry,\n  event,\n  timeOrigin,\n  description,\n  eventEnd,\n) {\n  var end = eventEnd ? (entry[eventEnd] ) : (entry[`${event}End`] );\n  var start = entry[`${event}Start`] ;\n  if (!start || !end) {\n    return;\n  }\n  _startChild(transaction, {\n    op: 'browser',\n    description: _nullishCoalesce(description, () => ( event)),\n    startTimestamp: timeOrigin + msToSec(start),\n    endTimestamp: timeOrigin + msToSec(end),\n  });\n}\n\n/** Create request and response related spans */\nfunction _addRequest(transaction, entry, timeOrigin) {\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'request',\n    startTimestamp: timeOrigin + msToSec(entry.requestStart ),\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd ),\n  });\n\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'response',\n    startTimestamp: timeOrigin + msToSec(entry.responseStart ),\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd ),\n  });\n}\n\n/** Create resource-related spans */\nfunction _addResourceSpans(\n  transaction,\n  entry,\n  resourceName,\n  startTime,\n  duration,\n  timeOrigin,\n) {\n  // we already instrument based on fetch and xhr, so we don't need to\n  // duplicate spans here.\n  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {\n    return;\n  }\n\n    var data = {};\n  if ('transferSize' in entry) {\n    data['Transfer Size'] = entry.transferSize;\n  }\n  if ('encodedBodySize' in entry) {\n    data['Encoded Body Size'] = entry.encodedBodySize;\n  }\n  if ('decodedBodySize' in entry) {\n    data['Decoded Body Size'] = entry.decodedBodySize;\n  }\n\n  var startTimestamp = timeOrigin + startTime;\n  var endTimestamp = startTimestamp + duration;\n\n  _startChild(transaction, {\n    description: resourceName,\n    endTimestamp,\n    op: entry.initiatorType ? `resource.${entry.initiatorType}` : 'resource',\n    startTimestamp,\n    data,\n  });\n}\n\n/**\n * Capture the information of the user agent.\n */\nfunction _trackNavigator(transaction) {\n  var navigator = global.navigator ;\n  if (!navigator) {\n    return;\n  }\n\n  // track network connectivity\n  var connection = navigator.connection;\n  if (connection) {\n    if (connection.effectiveType) {\n      transaction.setTag('effectiveConnectionType', connection.effectiveType);\n    }\n\n    if (connection.type) {\n      transaction.setTag('connectionType', connection.type);\n    }\n\n    if (isMeasurementValue(connection.rtt)) {\n      _measurements['connection.rtt'] = { value: connection.rtt, unit: 'millisecond' };\n    }\n\n    if (isMeasurementValue(connection.downlink)) {\n      _measurements['connection.downlink'] = { value: connection.downlink, unit: '' }; // unit is empty string for now, while relay doesn't support download speed units\n    }\n  }\n\n  if (isMeasurementValue(navigator.deviceMemory)) {\n    transaction.setTag('deviceMemory', `${navigator.deviceMemory} GB`);\n  }\n\n  if (isMeasurementValue(navigator.hardwareConcurrency)) {\n    transaction.setTag('hardwareConcurrency', String(navigator.hardwareConcurrency));\n  }\n}\n\n/** Add LCP / CLS data to transaction to allow debugging */\nfunction _tagMetricInfo(transaction) {\n  if (_lcpEntry) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Measurements] Adding LCP Data');\n\n    // Capture Properties of the LCP element that contributes to the LCP.\n\n    if (_lcpEntry.element) {\n      transaction.setTag('lcp.element', htmlTreeAsString(_lcpEntry.element));\n    }\n\n    if (_lcpEntry.id) {\n      transaction.setTag('lcp.id', _lcpEntry.id);\n    }\n\n    if (_lcpEntry.url) {\n      // Trim URL to the first 200 characters.\n      transaction.setTag('lcp.url', _lcpEntry.url.trim().slice(0, 200));\n    }\n\n    transaction.setTag('lcp.size', _lcpEntry.size);\n  }\n\n  // See: https://developer.mozilla.org/en-US/docs/Web/API/LayoutShift\n  if (_clsEntry && _clsEntry.sources) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Measurements] Adding CLS Data');\n    _clsEntry.sources.forEach((source, index) =>\n      transaction.setTag(`cls.source.${index + 1}`, htmlTreeAsString(source.node)),\n    );\n  }\n}\n\nexport { _addMeasureSpans, _addResourceSpans, addPerformanceEntries, startTrackingLongTasks, startTrackingWebVitals };\n//# sourceMappingURL=index.js.map\n","import { isMatchingPattern, addInstrumentationHandler, dynamicSamplingContextToSentryBaggageHeader, isInstanceOf, BAGGAGE_HEADER_NAME } from '@sentry/utils';\nimport { hasTracingEnabled, getActiveTransaction } from '../utils.js';\n\nvar DEFAULT_TRACING_ORIGINS = ['localhost', /^\\//];\n\n/** Options for Request Instrumentation */\n\nvar defaultRequestInstrumentationOptions = {\n  traceFetch: true,\n  traceXHR: true,\n  tracingOrigins: DEFAULT_TRACING_ORIGINS,\n};\n\n/** Registers span creators for xhr and fetch requests  */\nfunction instrumentOutgoingRequests(_options) {\n    const { traceFetch, traceXHR, tracingOrigins, shouldCreateSpanForRequest } = {\n    ...defaultRequestInstrumentationOptions,\n    ..._options,\n  };\n\n  // We should cache url -> decision so that we don't have to compute\n  // regexp everytime we create a request.\n  var urlMap = {};\n\n  var defaultShouldCreateSpan = (url) => {\n    if (urlMap[url]) {\n      return urlMap[url];\n    }\n    var origins = tracingOrigins;\n    urlMap[url] =\n      origins.some((origin) => isMatchingPattern(url, origin)) &&\n      !isMatchingPattern(url, 'sentry_key');\n    return urlMap[url];\n  };\n\n  // We want that our users don't have to re-implement shouldCreateSpanForRequest themselves\n  // That's why we filter out already unwanted Spans from tracingOrigins\n  let shouldCreateSpan = defaultShouldCreateSpan;\n  if (typeof shouldCreateSpanForRequest === 'function') {\n    shouldCreateSpan = (url) => {\n      return defaultShouldCreateSpan(url) && shouldCreateSpanForRequest(url);\n    };\n  }\n\n  var spans = {};\n\n  if (traceFetch) {\n    addInstrumentationHandler('fetch', (handlerData) => {\n      fetchCallback(handlerData, shouldCreateSpan, spans);\n    });\n  }\n\n  if (traceXHR) {\n    addInstrumentationHandler('xhr', (handlerData) => {\n      xhrCallback(handlerData, shouldCreateSpan, spans);\n    });\n  }\n}\n\n/**\n * Create and track fetch request spans\n */\nfunction fetchCallback(\n  handlerData,\n  shouldCreateSpan,\n  spans,\n) {\n  if (!hasTracingEnabled() || !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) {\n    return;\n  }\n\n  if (handlerData.endTimestamp) {\n    var spanId = handlerData.fetchData.__span;\n    if (!spanId) return;\n\n    var span = spans[spanId];\n    if (span) {\n      if (handlerData.response) {\n        // TODO (kmclb) remove this once types PR goes through\n                span.setHttpStatus(handlerData.response.status);\n      } else if (handlerData.error) {\n        span.setStatus('internal_error');\n      }\n      span.finish();\n\n            delete spans[spanId];\n    }\n    return;\n  }\n\n  var activeTransaction = getActiveTransaction();\n  if (activeTransaction) {\n    var span = activeTransaction.startChild({\n      data: {\n        ...handlerData.fetchData,\n        type: 'fetch',\n      },\n      description: `${handlerData.fetchData.method} ${handlerData.fetchData.url}`,\n      op: 'http.client',\n    });\n\n    handlerData.fetchData.__span = span.spanId;\n    spans[span.spanId] = span;\n\n    var request = handlerData.args[0];\n\n    // In case the user hasn't set the second argument of a fetch call we default it to `{}`.\n    handlerData.args[1] = handlerData.args[1] || {};\n\n        var options = handlerData.args[1];\n\n    options.headers = addTracingHeadersToFetchRequest(\n      request,\n      activeTransaction.getDynamicSamplingContext(),\n      span,\n      options,\n    );\n\n    activeTransaction.metadata.propagations += 1;\n  }\n}\n\nfunction addTracingHeadersToFetchRequest(\n  request,\n  dynamicSamplingContext,\n  span,\n  options\n\n,\n) {\n  var sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);\n  var sentryTraceHeader = span.toTraceparent();\n\n  var headers =\n    typeof Request !== 'undefined' && isInstanceOf(request, Request) ? (request ).headers : options.headers;\n\n  if (!headers) {\n    return { 'sentry-trace': sentryTraceHeader, baggage: sentryBaggageHeader };\n  } else if (typeof Headers !== 'undefined' && isInstanceOf(headers, Headers)) {\n    var newHeaders = new Headers(headers );\n\n    newHeaders.append('sentry-trace', sentryTraceHeader);\n\n    if (sentryBaggageHeader) {\n      // If the same header is appended miultiple times the browser will merge the values into a single request header.\n      // Its therefore safe to simply push a \"baggage\" entry, even though there might already be another baggage header.\n      newHeaders.append(BAGGAGE_HEADER_NAME, sentryBaggageHeader);\n    }\n\n    return newHeaders ;\n  } else if (Array.isArray(headers)) {\n    var newHeaders = [...headers, ['sentry-trace', sentryTraceHeader]];\n\n    if (sentryBaggageHeader) {\n      // If there are multiple entries with the same key, the browser will merge the values into a single request header.\n      // Its therefore safe to simply push a \"baggage\" entry, even though there might already be another baggage header.\n      newHeaders.push([BAGGAGE_HEADER_NAME, sentryBaggageHeader]);\n    }\n\n    return newHeaders;\n  } else {\n    var existingBaggageHeader = 'baggage' in headers ? headers.baggage : undefined;\n    var newBaggageHeaders = [];\n\n    if (Array.isArray(existingBaggageHeader)) {\n      newBaggageHeaders.push(...existingBaggageHeader);\n    } else if (existingBaggageHeader) {\n      newBaggageHeaders.push(existingBaggageHeader);\n    }\n\n    if (sentryBaggageHeader) {\n      newBaggageHeaders.push(sentryBaggageHeader);\n    }\n\n    return {\n      ...(headers ),\n      'sentry-trace': sentryTraceHeader,\n      baggage: newBaggageHeaders.length > 0 ? newBaggageHeaders.join(',') : undefined,\n    };\n  }\n}\n\n/**\n * Create and track xhr request spans\n */\nfunction xhrCallback(\n  handlerData,\n  shouldCreateSpan,\n  spans,\n) {\n  if (\n    !hasTracingEnabled() ||\n    (handlerData.xhr && handlerData.xhr.__sentry_own_request__) ||\n    !(handlerData.xhr && handlerData.xhr.__sentry_xhr__ && shouldCreateSpan(handlerData.xhr.__sentry_xhr__.url))\n  ) {\n    return;\n  }\n\n  var xhr = handlerData.xhr.__sentry_xhr__;\n\n  // check first if the request has finished and is tracked by an existing span which should now end\n  if (handlerData.endTimestamp) {\n    var spanId = handlerData.xhr.__sentry_xhr_span_id__;\n    if (!spanId) return;\n\n    var span = spans[spanId];\n    if (span) {\n      span.setHttpStatus(xhr.status_code);\n      span.finish();\n\n            delete spans[spanId];\n    }\n    return;\n  }\n\n  // if not, create a new span to track it\n  var activeTransaction = getActiveTransaction();\n  if (activeTransaction) {\n    var span = activeTransaction.startChild({\n      data: {\n        ...xhr.data,\n        type: 'xhr',\n        method: xhr.method,\n        url: xhr.url,\n      },\n      description: `${xhr.method} ${xhr.url}`,\n      op: 'http.client',\n    });\n\n    handlerData.xhr.__sentry_xhr_span_id__ = span.spanId;\n    spans[handlerData.xhr.__sentry_xhr_span_id__] = span;\n\n    if (handlerData.xhr.setRequestHeader) {\n      try {\n        handlerData.xhr.setRequestHeader('sentry-trace', span.toTraceparent());\n\n        var dynamicSamplingContext = activeTransaction.getDynamicSamplingContext();\n        var sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);\n\n        if (sentryBaggageHeader) {\n          // From MDN: \"If this method is called several times with the same header, the values are merged into one single request header.\"\n          // We can therefore simply set a baggage header without checking what was there before\n          // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader\n          handlerData.xhr.setRequestHeader(BAGGAGE_HEADER_NAME, sentryBaggageHeader);\n        }\n\n        activeTransaction.metadata.propagations += 1;\n      } catch (_) {\n        // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n      }\n    }\n  }\n}\n\nexport { DEFAULT_TRACING_ORIGINS, defaultRequestInstrumentationOptions, fetchCallback, instrumentOutgoingRequests, xhrCallback };\n//# sourceMappingURL=request.js.map\n","import { getGlobalObject, logger, addInstrumentationHandler } from '@sentry/utils';\n\nvar global = getGlobalObject();\n\n/**\n * Default function implementing pageload and navigation transactions\n */\nfunction instrumentRoutingWithDefaults(\n  customStartTransaction,\n  startTransactionOnPageLoad = true,\n  startTransactionOnLocationChange = true,\n) {\n  if (!global || !global.location) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Could not initialize routing instrumentation due to invalid location');\n    return;\n  }\n\n  let startingUrl = global.location.href;\n\n  let activeTransaction;\n  if (startTransactionOnPageLoad) {\n    activeTransaction = customStartTransaction({\n      name: global.location.pathname,\n      op: 'pageload',\n      metadata: { source: 'url' },\n    });\n  }\n\n  if (startTransactionOnLocationChange) {\n    addInstrumentationHandler('history', ({ to, from }) => {\n      /**\n       * This early return is there to account for some cases where a navigation transaction starts right after\n       * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't\n       * create an uneccessary navigation transaction.\n       *\n       * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also\n       * only be caused in certain development environments where the usage of a hot module reloader is causing\n       * errors.\n       */\n      if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {\n        startingUrl = undefined;\n        return;\n      }\n\n      if (from !== to) {\n        startingUrl = undefined;\n        if (activeTransaction) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] Finishing current transaction with op: ${activeTransaction.op}`);\n          // If there's an open transaction on the scope, we need to finish it before creating an new one.\n          activeTransaction.finish();\n        }\n        activeTransaction = customStartTransaction({\n          name: global.location.pathname,\n          op: 'navigation',\n          metadata: { source: 'url' },\n        });\n      }\n    });\n  }\n}\n\nexport { instrumentRoutingWithDefaults };\n//# sourceMappingURL=router.js.map\n","import { _optionalChain } from '@sentry/utils/esm/buildPolyfills';\nimport { logger, extractTraceparentData, baggageHeaderToDynamicSamplingContext, getGlobalObject, getDomElement } from '@sentry/utils';\nimport { startIdleTransaction } from '../hubextensions.js';\nimport { DEFAULT_IDLE_TIMEOUT, DEFAULT_FINAL_TIMEOUT } from '../idletransaction.js';\nimport '../utils.js';\nimport { registerBackgroundTabDetection } from './backgroundtab.js';\nimport { startTrackingWebVitals, startTrackingLongTasks, addPerformanceEntries } from './metrics/index.js';\nimport { defaultRequestInstrumentationOptions, instrumentOutgoingRequests } from './request.js';\nimport { instrumentRoutingWithDefaults } from './router.js';\n\nvar BROWSER_TRACING_INTEGRATION_ID = 'BrowserTracing';\n\n/** Options for Browser Tracing integration */\n\nvar DEFAULT_BROWSER_TRACING_OPTIONS = {\n  idleTimeout: DEFAULT_IDLE_TIMEOUT,\n  finalTimeout: DEFAULT_FINAL_TIMEOUT,\n  markBackgroundTransactions: true,\n  routingInstrumentation: instrumentRoutingWithDefaults,\n  startTransactionOnLocationChange: true,\n  startTransactionOnPageLoad: true,\n  _experiments: { enableLongTask: true },\n  ...defaultRequestInstrumentationOptions,\n};\n\n/**\n * The Browser Tracing integration automatically instruments browser pageload/navigation\n * actions as transactions, and captures requests, metrics and errors as spans.\n *\n * The integration can be configured with a variety of options, and can be extended to use\n * any routing library. This integration uses {@see IdleTransaction} to create transactions.\n */\nclass BrowserTracing  {\n  // This class currently doesn't have a static `id` field like the other integration classes, because it prevented\n  // @sentry/tracing from being treeshaken. Tree shakers do not like static fields, because they behave like side effects.\n  // TODO: Come up with a better plan, than using static fields on integration classes, and use that plan on all\n  // integrations.\n\n  /** Browser Tracing integration options */\n  \n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = BROWSER_TRACING_INTEGRATION_ID;}\n\n   constructor(_options) {;BrowserTracing.prototype.__init.call(this);\n    let tracingOrigins = defaultRequestInstrumentationOptions.tracingOrigins;\n    // NOTE: Logger doesn't work in constructors, as it's initialized after integrations instances\n    if (_options) {\n      if (_options.tracingOrigins && Array.isArray(_options.tracingOrigins)) {\n        tracingOrigins = _options.tracingOrigins;\n      } else {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && (this._emitOptionsWarning = true);\n      }\n    }\n\n    this.options = {\n      ...DEFAULT_BROWSER_TRACING_OPTIONS,\n      ..._options,\n      tracingOrigins,\n    };\n\n    const { _metricOptions } = this.options;\n    startTrackingWebVitals(_metricOptions && _metricOptions._reportAllChanges);\n    if (_optionalChain([this, 'access', _2 => _2.options, 'access', _3 => _3._experiments, 'optionalAccess', _4 => _4.enableLongTask])) {\n      startTrackingLongTasks();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setupOnce(_, getCurrentHub) {\n    this._getCurrentHub = getCurrentHub;\n\n    if (this._emitOptionsWarning) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        logger.warn(\n          '[Tracing] You need to define `tracingOrigins` in the options. Set an array of urls or patterns to trace.',\n        );\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        logger.warn(\n          `[Tracing] We added a reasonable default for you: ${defaultRequestInstrumentationOptions.tracingOrigins}`,\n        );\n    }\n\n        const {\n      routingInstrumentation: instrumentRouting,\n      startTransactionOnLocationChange,\n      startTransactionOnPageLoad,\n      markBackgroundTransactions,\n      traceFetch,\n      traceXHR,\n      tracingOrigins,\n      shouldCreateSpanForRequest,\n    } = this.options;\n\n    instrumentRouting(\n      (context) => this._createRouteTransaction(context),\n      startTransactionOnPageLoad,\n      startTransactionOnLocationChange,\n    );\n\n    if (markBackgroundTransactions) {\n      registerBackgroundTabDetection();\n    }\n\n    instrumentOutgoingRequests({ traceFetch, traceXHR, tracingOrigins, shouldCreateSpanForRequest });\n  }\n\n  /** Create routing idle transaction. */\n   _createRouteTransaction(context) {\n    if (!this._getCurrentHub) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        logger.warn(`[Tracing] Did not create ${context.op} transaction because _getCurrentHub is invalid.`);\n      return undefined;\n    }\n\n        const { beforeNavigate, idleTimeout, finalTimeout } = this.options;\n\n    var isPageloadTransaction = context.op === 'pageload';\n\n    var sentryTraceMetaTagValue = isPageloadTransaction ? getMetaContent('sentry-trace') : null;\n    var baggageMetaTagValue = isPageloadTransaction ? getMetaContent('baggage') : null;\n\n    var traceParentData = sentryTraceMetaTagValue ? extractTraceparentData(sentryTraceMetaTagValue) : undefined;\n    var dynamicSamplingContext = baggageMetaTagValue\n      ? baggageHeaderToDynamicSamplingContext(baggageMetaTagValue)\n      : undefined;\n\n    var expandedContext = {\n      ...context,\n      ...traceParentData,\n      metadata: {\n        ...context.metadata,\n        dynamicSamplingContext: traceParentData && !dynamicSamplingContext ? {} : dynamicSamplingContext,\n      },\n      trimEnd: true,\n    };\n\n    var modifiedContext = typeof beforeNavigate === 'function' ? beforeNavigate(expandedContext) : expandedContext;\n\n    // For backwards compatibility reasons, beforeNavigate can return undefined to \"drop\" the transaction (prevent it\n    // from being sent to Sentry).\n    var finalContext = modifiedContext === undefined ? { ...expandedContext, sampled: false } : modifiedContext;\n\n    // If `beforeNavigate` set a custom name, record that fact\n    finalContext.metadata =\n      finalContext.name !== expandedContext.name\n        ? { ...finalContext.metadata, source: 'custom' }\n        : finalContext.metadata;\n\n    if (finalContext.sampled === false) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        logger.log(`[Tracing] Will not send ${finalContext.op} transaction because of beforeNavigate.`);\n    }\n\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] Starting ${finalContext.op} transaction on scope`);\n\n    var hub = this._getCurrentHub();\n    const { location } = getGlobalObject() ;\n\n    var idleTransaction = startIdleTransaction(\n      hub,\n      finalContext,\n      idleTimeout,\n      finalTimeout,\n      true,\n      { location }, // for use in the tracesSampler\n    );\n    idleTransaction.registerBeforeFinishCallback(transaction => {\n      addPerformanceEntries(transaction);\n      transaction.setTag(\n        'sentry_reportAllChanges',\n        Boolean(this.options._metricOptions && this.options._metricOptions._reportAllChanges),\n      );\n    });\n\n    return idleTransaction ;\n  }\n}\n\n/** Returns the value of a meta tag */\nfunction getMetaContent(metaName) {\n  // Can't specify generic to `getDomElement` because tracing can be used\n  // in a variety of environments, have to disable `no-unsafe-member-access`\n  // as a result.\n  var metaTag = getDomElement(`meta[name=${metaName}]`);\n    return metaTag ? metaTag.getAttribute('content') : null;\n}\n\nexport { BROWSER_TRACING_INTEGRATION_ID, BrowserTracing, getMetaContent };\n//# sourceMappingURL=browsertracing.js.map\n","import { addExtensionMethods } from './hubextensions.js';\nexport { addExtensionMethods, startIdleTransaction } from './hubextensions.js';\nimport * as index from './integrations/index.js';\nexport { index as Integrations };\nimport './browser/index.js';\nexport { Span, spanStatusfromHttpCode } from './span.js';\nexport { SpanStatus } from './spanstatus.js';\nexport { Transaction } from './transaction.js';\nexport { IdleTransaction } from './idletransaction.js';\nexport { getActiveTransaction, hasTracingEnabled } from './utils.js';\nexport { BROWSER_TRACING_INTEGRATION_ID, BrowserTracing } from './browser/browsertracing.js';\nexport { defaultRequestInstrumentationOptions, instrumentOutgoingRequests } from './browser/request.js';\nexport { TRACEPARENT_REGEXP, extractTraceparentData, stripUrlQueryAndFragment } from '@sentry/utils';\n\n;\n;\n\n// Treeshakable guard to remove all code related to tracing\n\n// Guard for tree\nif (typeof __SENTRY_TRACING__ === 'undefined' || __SENTRY_TRACING__) {\n  // We are patching the global object with our hub extension methods\n  addExtensionMethods();\n}\n//# sourceMappingURL=index.js.map\n","import { getCurrentHub } from '@sentry/hub';\nimport { getGlobalObject, logger, extractTraceparentData, baggageHeaderToDynamicSamplingContext, stripUrlQueryAndFragment } from '@sentry/utils';\nimport Router from 'next/router';\n\nvar global = getGlobalObject\n\n();\n\n/**\n * Every Next.js page (static and dynamic ones) comes with a script tag with the id \"__NEXT_DATA__\". This script tag\n * contains a JSON object with data that was either generated at build time for static pages (`getStaticProps`), or at\n * runtime with data fetchers like `getServerSideProps.`.\n *\n * We can use this information to:\n * - Always get the parameterized route we're in when loading a page.\n * - Send trace information (trace-id, baggage) from the server to the client.\n *\n * This function extracts this information.\n */\nfunction extractNextDataTagInformation() {\n  let nextData;\n  // Let's be on the safe side and actually check first if there is really a __NEXT_DATA__ script tag on the page.\n  // Theoretically this should always be the case though.\n  var nextDataTag = global.document.getElementById('__NEXT_DATA__');\n  if (nextDataTag && nextDataTag.innerHTML) {\n    try {\n      nextData = JSON.parse(nextDataTag.innerHTML);\n    } catch (e) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Could not extract __NEXT_DATA__');\n    }\n  }\n\n  if (!nextData) {\n    return {};\n  }\n\n  var nextDataTagInfo = {};\n\n  const { page, query, props } = nextData;\n\n  // `nextData.page` always contains the parameterized route - except for when an error occurs in a data fetching\n  // function, then it is \"/_error\", but that isn't a problem since users know which route threw by looking at the\n  // parent transaction\n  // TODO: Actually this is a problem (even though it is not that big), because the DSC and the transaction payload will contain\n  // a different transaction name. Maybe we can fix this. Idea: Also send transaction name via pageProps when available.\n  nextDataTagInfo.route = page;\n  nextDataTagInfo.params = query;\n\n  if (props && props.pageProps) {\n    if (props.pageProps._sentryBaggage) {\n      nextDataTagInfo.baggage = props.pageProps._sentryBaggage;\n    }\n\n    if (props.pageProps._sentryTraceData) {\n      nextDataTagInfo.traceParentData = extractTraceparentData(props.pageProps._sentryTraceData);\n    }\n  }\n\n  return nextDataTagInfo;\n}\n\nvar DEFAULT_TAGS = {\n  'routing.instrumentation': 'next-router',\n} ;\n\n// We keep track of the active transaction so we can finish it when we start a navigation transaction.\nlet activeTransaction = undefined;\n\n// We keep track of the previous location name so we can set the `from` field on navigation transactions.\n// This is either a route or a pathname.\nlet prevLocationName = undefined;\n\nvar client = getCurrentHub().getClient();\n\n/**\n * Creates routing instrumention for Next Router. Only supported for\n * client side routing. Works for Next >= 10.\n *\n * Leverages the SingletonRouter from the `next/router` to\n * generate pageload/navigation transactions and parameterize\n * transaction names.\n */\nfunction nextRouterInstrumentation(\n  startTransactionCb,\n  startTransactionOnPageLoad = true,\n  startTransactionOnLocationChange = true,\n) {\n  const { route, traceParentData, baggage, params } = extractNextDataTagInformation();\n  prevLocationName = route || global.location.pathname;\n\n  if (startTransactionOnPageLoad) {\n    var source = route ? 'route' : 'url';\n    var dynamicSamplingContext = baggageHeaderToDynamicSamplingContext(baggage);\n\n    activeTransaction = startTransactionCb({\n      name: prevLocationName,\n      op: 'pageload',\n      tags: DEFAULT_TAGS,\n      ...(params && client && client.getOptions().sendDefaultPii && { data: params }),\n      ...traceParentData,\n      metadata: {\n        source,\n        dynamicSamplingContext: traceParentData && !dynamicSamplingContext ? {} : dynamicSamplingContext,\n      },\n    });\n  }\n\n  if (startTransactionOnLocationChange) {\n    Router.events.on('routeChangeStart', (navigationTarget) => {\n      var matchedRoute = getNextRouteFromPathname(stripUrlQueryAndFragment(navigationTarget));\n\n      let transactionName;\n      let transactionSource;\n\n      if (matchedRoute) {\n        transactionName = matchedRoute;\n        transactionSource = 'route';\n      } else {\n        transactionName = navigationTarget;\n        transactionSource = 'url';\n      }\n\n      var tags = {\n        ...DEFAULT_TAGS,\n        from: prevLocationName,\n      };\n\n      prevLocationName = transactionName;\n\n      if (activeTransaction) {\n        activeTransaction.finish();\n      }\n\n      var navigationTransaction = startTransactionCb({\n        name: transactionName,\n        op: 'navigation',\n        tags,\n        metadata: { source: transactionSource },\n      });\n\n      if (navigationTransaction) {\n        // In addition to the navigation transaction we're also starting a span to mark Next.js's `routeChangeStart`\n        // and `routeChangeComplete` events.\n        // We don't want to finish the navigation transaction on `routeChangeComplete`, since users might want to attach\n        // spans to that transaction even after `routeChangeComplete` is fired (eg. HTTP requests in some useEffect\n        // hooks). Instead, we'll simply let the navigation transaction finish itself (it's an `IdleTransaction`).\n        var nextRouteChangeSpan = navigationTransaction.startChild({\n          op: 'ui.nextjs.route-change',\n          description: 'Next.js Route Change',\n        });\n\n        var finishRouteChangeSpan = () => {\n          nextRouteChangeSpan.finish();\n          Router.events.off('routeChangeComplete', finishRouteChangeSpan);\n        };\n\n        Router.events.on('routeChangeComplete', finishRouteChangeSpan);\n      }\n    });\n  }\n}\n\nfunction getNextRouteFromPathname(pathname) {\n  var pageRoutes = (global.__BUILD_MANIFEST || {}).sortedPages;\n\n  // Page route should in 99.999% of the cases be defined by now but just to be sure we make a check here\n  if (!pageRoutes) {\n    return;\n  }\n\n  return pageRoutes.find(route => {\n    var routeRegExp = convertNextRouteToRegExp(route);\n    return pathname.match(routeRegExp);\n  });\n}\n\n/**\n * Converts a Next.js style route to a regular expression that matches on pathnames (no query params or URL fragments).\n *\n * In general this involves replacing any instances of square brackets in a route with a wildcard:\n * e.g. \"/users/[id]/info\" becomes /\\/users\\/([^/]+?)\\/info/\n *\n * Some additional edgecases need to be considered:\n * - All routes have an optional slash at the end, meaning users can navigate to \"/users/[id]/info\" or\n *   \"/users/[id]/info/\" - both will be resolved to \"/users/[id]/info\".\n * - Non-optional \"catchall\"s at the end of a route must be considered when matching (e.g. \"/users/[...params]\").\n * - Optional \"catchall\"s at the end of a route must be considered when matching (e.g. \"/users/[[...params]]\").\n *\n * @param route A Next.js style route as it is found in `global.__BUILD_MANIFEST.sortedPages`\n */\nfunction convertNextRouteToRegExp(route) {\n  // We can assume a route is at least \"/\".\n  var routeParts = route.split('/');\n\n  let optionalCatchallWildcardRegex = '';\n  if (routeParts[routeParts.length - 1].match(/^\\[\\[\\.\\.\\..+\\]\\]$/)) {\n    // If last route part has pattern \"[[...xyz]]\" we pop the latest route part to get rid of the required trailing\n    // slash that would come before it if we didn't pop it.\n    routeParts.pop();\n    optionalCatchallWildcardRegex = '(?:/(.+?))?';\n  }\n\n  var rejoinedRouteParts = routeParts\n    .map(\n      routePart =>\n        routePart\n          .replace(/^\\[\\.\\.\\..+\\]$/, '(.+?)') // Replace catch all wildcard with regex wildcard\n          .replace(/^\\[.*\\]$/, '([^/]+?)'), // Replace route wildcards with lazy regex wildcards\n    )\n    .join('/');\n\n  return new RegExp(\n    `^${rejoinedRouteParts}${optionalCatchallWildcardRegex}(?:/)?$`, // optional slash at the end\n  );\n}\n\nexport { nextRouterInstrumentation };\n//# sourceMappingURL=client.js.map\n","import { SDK_VERSION } from '@sentry/core';\n\nvar PACKAGE_NAME_PREFIX = 'npm:@sentry/';\n\n/**\n * A builder for the SDK metadata in the options for the SDK initialization.\n * @param options sdk options object that gets mutated\n * @param names list of package names\n */\nfunction buildMetadata(options, names) {\n  options._metadata = options._metadata || {};\n  options._metadata.sdk =\n    options._metadata.sdk ||\n    ({\n      name: 'sentry.javascript.nextjs',\n      packages: names.map(name => ({\n        name: `${PACKAGE_NAME_PREFIX}${name}`,\n        version: SDK_VERSION,\n      })),\n      version: SDK_VERSION,\n    } );\n}\n\nexport { buildMetadata };\n//# sourceMappingURL=metadata.js.map\n","/**\n * Recursively traverses an object to update an existing nested key.\n * Note: The provided key path must include existing properties,\n * the function will not create objects while traversing.\n *\n * @param obj An object to update\n * @param value The value to update the nested key with\n * @param keyPath The path to the key to update ex. fizz.buzz.foo\n */\nfunction setNestedKey(obj, keyPath, value) {\n  // Ex. foo.bar.zoop will extract foo and bar.zoop\n  var match = keyPath.match(/([a-z_]+)\\.(.*)/i);\n  // The match will be null when there's no more recursing to do, i.e., when we've reached the right level of the object\n  if (match === null) {\n    obj[keyPath] = value;\n  } else {\n    // `match[1]` is the initial segment of the path, and `match[2]` is the remainder of the path\n    var innerObj = obj[match[1]];\n    setNestedKey(innerObj, match[2], value);\n  }\n}\n\n/**\n * Enforces inclusion of a given integration with specified options in an integration array originally determined by the\n * user, by either including the given default instance or by patching an existing user instance with the given options.\n *\n * Ideally this would happen when integrations are set up, but there isn't currently a mechanism there for merging\n * options from a default integration instance with those from a user-provided instance of the same integration, only\n * for allowing the user to override a default instance entirely. (TODO: Fix that.)\n *\n * @param defaultIntegrationInstance An instance of the integration with the correct options already set\n * @param userIntegrations Integrations defined by the user.\n * @param forcedOptions Options with which to patch an existing user-derived instance on the integration.\n * @returns A final integrations array.\n */\nfunction addOrUpdateIntegration(\n  defaultIntegrationInstance,\n  userIntegrations,\n  forcedOptions = {},\n) {\n  return Array.isArray(userIntegrations)\n    ? addOrUpdateIntegrationInArray(defaultIntegrationInstance, userIntegrations, forcedOptions)\n    : addOrUpdateIntegrationInFunction(defaultIntegrationInstance, userIntegrations, forcedOptions);\n}\n\nfunction addOrUpdateIntegrationInArray(\n  defaultIntegrationInstance,\n  userIntegrations,\n  forcedOptions,\n) {\n  var userInstance = userIntegrations.find(integration => integration.name === defaultIntegrationInstance.name);\n\n  if (userInstance) {\n    for (const [keyPath, value] of Object.entries(forcedOptions)) {\n      setNestedKey(userInstance, keyPath, value);\n    }\n\n    return userIntegrations;\n  }\n\n  return [...userIntegrations, defaultIntegrationInstance];\n}\n\nfunction addOrUpdateIntegrationInFunction(\n  defaultIntegrationInstance,\n  userIntegrationsFunc,\n  forcedOptions,\n) {\n  var wrapper = defaultIntegrations => {\n    var userFinalIntegrations = userIntegrationsFunc(defaultIntegrations);\n    return addOrUpdateIntegrationInArray(defaultIntegrationInstance, userFinalIntegrations, forcedOptions);\n  };\n  return wrapper;\n}\n\nexport { addOrUpdateIntegration };\n//# sourceMappingURL=userIntegrations.js.map\n","import { init as init$1, configureScope } from '@sentry/react';\nexport * from '@sentry/react';\nexport { Integrations } from '@sentry/react';\nimport { BrowserTracing, defaultRequestInstrumentationOptions } from '@sentry/tracing';\nexport { BrowserTracing } from '@sentry/tracing';\nimport { nextRouterInstrumentation } from './performance/client.js';\nexport { nextRouterInstrumentation } from './performance/client.js';\nimport { buildMetadata } from './utils/metadata.js';\nimport { addOrUpdateIntegration } from './utils/userIntegrations.js';\nexport { captureUnderscoreErrorException } from './utils/_error.js';\n\n// Treeshakable guard to remove all code related to tracing\n\n/** Inits the Sentry NextJS SDK on the browser with the React SDK. */\nfunction init(options) {\n  buildMetadata(options, ['nextjs', 'react']);\n  options.environment = options.environment || process.env.NODE_ENV;\n\n  let integrations = options.integrations;\n\n  // Guard below evaluates to true unless __SENTRY_TRACING__ is text-replaced with \"false\"\n  if (typeof __SENTRY_TRACING__ === 'undefined' || __SENTRY_TRACING__) {\n    // Only add BrowserTracing if a tracesSampleRate or tracesSampler is set\n    if (options.tracesSampleRate !== undefined || options.tracesSampler !== undefined) {\n      integrations = createClientIntegrations(options.integrations);\n    }\n  }\n\n  init$1({\n    ...options,\n    integrations,\n  });\n\n  configureScope(scope => {\n    scope.setTag('runtime', 'browser');\n    var filterTransactions = event =>\n      event.type === 'transaction' && event.transaction === '/404' ? null : event;\n    filterTransactions.id = 'NextClient404Filter';\n    scope.addEventProcessor(filterTransactions);\n  });\n}\n\nfunction createClientIntegrations(userIntegrations = []) {\n  var defaultBrowserTracingIntegration = new BrowserTracing({\n    tracingOrigins: [...defaultRequestInstrumentationOptions.tracingOrigins, /^(api\\/)/],\n    routingInstrumentation: nextRouterInstrumentation,\n  });\n\n  return addOrUpdateIntegration(defaultBrowserTracingIntegration, userIntegrations, {\n    'options.routingInstrumentation': nextRouterInstrumentation,\n  });\n}\n\nexport { init };\n//# sourceMappingURL=index.client.js.map\n","// This file configures the initialization of Sentry on the browser.\n// The config you add here will be used whenever a page is visited.\n// https://docs.sentry.io/platforms/javascript/guides/nextjs/\n\nimport * as Sentry from '@sentry/nextjs';\n\nconst SENTRY_DSN = process.env.SENTRY_DSN || process.env.NEXT_PUBLIC_SENTRY_DSN;\n\nSentry.init({\n  dsn:\n    SENTRY_DSN ||\n    'https://2becbe2880ce41ed8198fd63c2cd490f@o1381755.ingest.sentry.io/6695436',\n  // Adjust this value in production, or use tracesSampler for greater control\n  tracesSampleRate: 1.0,\n  attachStacktrace: true,\n  // ...\n  // Note: if you want to override the automatic release value, do not set a\n  // `release` value here - use the environment variable `SENTRY_RELEASE`, so\n  // that it will also get attached to your source maps\n});\n","(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();","module.exports = require('./dist/client/router')\n","(self[\"webpackChunk_N_E\"] = self[\"webpackChunk_N_E\"] || []).push([[888],{\n\n/***/ 2876:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$e\": function() { return /* binding */ withScope; },\n/* harmony export */   \"Tb\": function() { return /* binding */ captureException; },\n/* harmony export */   \"e\": function() { return /* binding */ configureScope; }\n/* harmony export */ });\n/* unused harmony exports addBreadcrumb, captureEvent, captureMessage, setContext, setExtra, setExtras, setTag, setTags, setUser, startTransaction */\n/* harmony import */ var _hub_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8641);\n\n\n// Note: All functions in this file are typed with a return value of `ReturnType<Hub[HUB_FUNCTION]>`,\n// where HUB_FUNCTION is some method on the Hub class.\n//\n// This is done to make sure the top level SDK methods stay in sync with the hub methods.\n// Although every method here has an explicit return type, some of them (that map to void returns) do not\n// contain `return` keywords. This is done to save on bundle size, as `return` is not minifiable.\n\n/**\n * Captures an exception event and sends it to Sentry.\n *\n * @param exception An exception-like object.\n * @param captureContext Additional scope data to apply to exception event.\n * @returns The generated eventId.\n */\nfunction captureException(exception, captureContext) {\n  return (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__/* .getCurrentHub */ .Gd)().captureException(exception, { captureContext });\n}\n\n/**\n * Captures a message event and sends it to Sentry.\n *\n * @param message The message to send to Sentry.\n * @param Severity Define the level of the message.\n * @returns The generated eventId.\n */\nfunction captureMessage(\n  message,\n    captureContext,\n) {\n  // This is necessary to provide explicit scopes upgrade, without changing the original\n  // arity of the `captureMessage(message, level)` method.\n  var level = typeof captureContext === 'string' ? captureContext : undefined;\n  var context = typeof captureContext !== 'string' ? { captureContext } : undefined;\n  return getCurrentHub().captureMessage(message, level, context);\n}\n\n/**\n * Captures a manually created event and sends it to Sentry.\n *\n * @param event The event to send to Sentry.\n * @returns The generated eventId.\n */\nfunction captureEvent(event, hint) {\n  return getCurrentHub().captureEvent(event, hint);\n}\n\n/**\n * Callback to set context information onto the scope.\n * @param callback Callback function that receives Scope.\n */\nfunction configureScope(callback) {\n  (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__/* .getCurrentHub */ .Gd)().configureScope(callback);\n}\n\n/**\n * Records a new breadcrumb which will be attached to future events.\n *\n * Breadcrumbs will be added to subsequent events to provide more context on\n * user's actions prior to an error or crash.\n *\n * @param breadcrumb The breadcrumb to record.\n */\nfunction addBreadcrumb(breadcrumb) {\n  getCurrentHub().addBreadcrumb(breadcrumb);\n}\n\n/**\n * Sets context data with the given name.\n * @param name of the context\n * @param context Any kind of data. This data will be normalized.\n */\nfunction setContext(name, context) {\n  getCurrentHub().setContext(name, context);\n}\n\n/**\n * Set an object that will be merged sent as extra data with the event.\n * @param extras Extras object to merge into current context.\n */\nfunction setExtras(extras) {\n  getCurrentHub().setExtras(extras);\n}\n\n/**\n * Set key:value that will be sent as extra data with the event.\n * @param key String of extra\n * @param extra Any kind of data. This data will be normalized.\n */\nfunction setExtra(key, extra) {\n  getCurrentHub().setExtra(key, extra);\n}\n\n/**\n * Set an object that will be merged sent as tags data with the event.\n * @param tags Tags context object to merge into current context.\n */\nfunction setTags(tags) {\n  getCurrentHub().setTags(tags);\n}\n\n/**\n * Set key:value that will be sent as tags data with the event.\n *\n * Can also be used to unset a tag, by passing `undefined`.\n *\n * @param key String key of tag\n * @param value Value of tag\n */\nfunction setTag(key, value) {\n  getCurrentHub().setTag(key, value);\n}\n\n/**\n * Updates user context information for future events.\n *\n * @param user User context object to be set in the current context. Pass `null` to unset the user.\n */\nfunction setUser(user) {\n  getCurrentHub().setUser(user);\n}\n\n/**\n * Creates a new scope with and executes the given operation within.\n * The scope is automatically removed once the operation\n * finishes or throws.\n *\n * This is essentially a convenience function for:\n *\n *     pushScope();\n *     callback();\n *     popScope();\n *\n * @param callback that will be enclosed into push/popScope.\n */\nfunction withScope(callback) {\n  (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__/* .getCurrentHub */ .Gd)().withScope(callback);\n}\n\n/**\n * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.\n *\n * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a\n * new child span within the transaction or any span, call the respective `.startChild()` method.\n *\n * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.\n *\n * The transaction must be finished with a call to its `.finish()` method, at which point the transaction with all its\n * finished child spans will be sent to Sentry.\n *\n * NOTE: This function should only be used for *manual* instrumentation. Auto-instrumentation should call\n * `startTransaction` directly on the hub.\n *\n * @param context Properties of the new `Transaction`.\n * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent\n * default values). See {@link Options.tracesSampler}.\n *\n * @returns The transaction which was just started\n */\nfunction startTransaction(\n  context,\n  customSamplingContext,\n) {\n  return getCurrentHub().startTransaction({ ...context }, customSamplingContext);\n}\n\n\n//# sourceMappingURL=exports.js.map\n\n\n/***/ }),\n\n/***/ 8641:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Gd\": function() { return /* binding */ getCurrentHub; },\n/* harmony export */   \"cu\": function() { return /* binding */ getMainCarrier; }\n/* harmony export */ });\n/* unused harmony exports API_VERSION, Hub, getHubFromCarrier, makeMain, setHubOnCarrier */\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2844);\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1170);\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2343);\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2991);\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2448);\n/* harmony import */ var _scope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6769);\n/* harmony import */ var _session_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5771);\n\n\n\n\n/**\n * API compatibility version of this hub.\n *\n * WARNING: This number should only be increased when the global interface\n * changes and new methods are introduced.\n *\n * @hidden\n */\nvar API_VERSION = 4;\n\n/**\n * Default maximum number of breadcrumbs added to an event. Can be overwritten\n * with {@link Options.maxBreadcrumbs}.\n */\nvar DEFAULT_BREADCRUMBS = 100;\n\n/**\n * A layer in the process stack.\n * @hidden\n */\n\n/**\n * @inheritDoc\n */\nclass Hub  {\n  /** Is a {@link Layer}[] containing the client and scope */\n    __init() {this._stack = [{}];}\n\n  /** Contains the last event id of a captured event.  */\n  \n\n  /**\n   * Creates a new instance of the hub, will push one {@link Layer} into the\n   * internal stack on creation.\n   *\n   * @param client bound to the hub.\n   * @param scope bound to the hub.\n   * @param version number, higher number means higher priority.\n   */\n   constructor(client, scope = new _scope_js__WEBPACK_IMPORTED_MODULE_0__/* .Scope */ .s(),   _version = API_VERSION) {;this._version = _version;Hub.prototype.__init.call(this);\n    this.getStackTop().scope = scope;\n    if (client) {\n      this.bindClient(client);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   isOlderThan(version) {\n    return this._version < version;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   bindClient(client) {\n    var top = this.getStackTop();\n    top.client = client;\n    if (client && client.setupIntegrations) {\n      client.setupIntegrations();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   pushScope() {\n    // We want to clone the content of prev scope\n    var scope = _scope_js__WEBPACK_IMPORTED_MODULE_0__/* .Scope.clone */ .s.clone(this.getScope());\n    this.getStack().push({\n      client: this.getClient(),\n      scope,\n    });\n    return scope;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   popScope() {\n    if (this.getStack().length <= 1) return false;\n    return !!this.getStack().pop();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   withScope(callback) {\n    var scope = this.pushScope();\n    try {\n      callback(scope);\n    } finally {\n      this.popScope();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getClient() {\n    return this.getStackTop().client ;\n  }\n\n  /** Returns the scope of the top stack. */\n   getScope() {\n    return this.getStackTop().scope;\n  }\n\n  /** Returns the scope stack for domains or the process. */\n   getStack() {\n    return this._stack;\n  }\n\n  /** Returns the topmost scope layer in the order domain > local > process. */\n   getStackTop() {\n    return this._stack[this._stack.length - 1];\n  }\n\n  /**\n   * @inheritDoc\n   */\n     captureException(exception, hint) {\n    var eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .uuid4 */ .DM)());\n    var syntheticException = new Error('Sentry syntheticException');\n    this._withClient((client, scope) => {\n      client.captureException(\n        exception,\n        {\n          originalException: exception,\n          syntheticException,\n          ...hint,\n          event_id: eventId,\n        },\n        scope,\n      );\n    });\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureMessage(\n    message,\n        level,\n    hint,\n  ) {\n    var eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .uuid4 */ .DM)());\n    var syntheticException = new Error(message);\n    this._withClient((client, scope) => {\n      client.captureMessage(\n        message,\n        level,\n        {\n          originalException: message,\n          syntheticException,\n          ...hint,\n          event_id: eventId,\n        },\n        scope,\n      );\n    });\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureEvent(event, hint) {\n    var eventId = hint && hint.event_id ? hint.event_id : (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .uuid4 */ .DM)();\n    if (event.type !== 'transaction') {\n      this._lastEventId = eventId;\n    }\n\n    this._withClient((client, scope) => {\n      client.captureEvent(event, { ...hint, event_id: eventId }, scope);\n    });\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   lastEventId() {\n    return this._lastEventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addBreadcrumb(breadcrumb, hint) {\n    const { scope, client } = this.getStackTop();\n\n    if (!scope || !client) return;\n\n        const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } =\n      (client.getOptions && client.getOptions()) || {};\n\n    if (maxBreadcrumbs <= 0) return;\n\n    var timestamp = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_2__/* .dateTimestampInSeconds */ .yW)();\n    var mergedBreadcrumb = { timestamp, ...breadcrumb };\n    var finalBreadcrumb = beforeBreadcrumb\n      ? ((0,_sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .consoleSandbox */ .Cf)(() => beforeBreadcrumb(mergedBreadcrumb, hint)) )\n      : mergedBreadcrumb;\n\n    if (finalBreadcrumb === null) return;\n\n    scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setUser(user) {\n    var scope = this.getScope();\n    if (scope) scope.setUser(user);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTags(tags) {\n    var scope = this.getScope();\n    if (scope) scope.setTags(tags);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setExtras(extras) {\n    var scope = this.getScope();\n    if (scope) scope.setExtras(extras);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTag(key, value) {\n    var scope = this.getScope();\n    if (scope) scope.setTag(key, value);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setExtra(key, extra) {\n    var scope = this.getScope();\n    if (scope) scope.setExtra(key, extra);\n  }\n\n  /**\n   * @inheritDoc\n   */\n     setContext(name, context) {\n    var scope = this.getScope();\n    if (scope) scope.setContext(name, context);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   configureScope(callback) {\n    const { scope, client } = this.getStackTop();\n    if (scope && client) {\n      callback(scope);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   run(callback) {\n    var oldHub = makeMain(this);\n    try {\n      callback(this);\n    } finally {\n      makeMain(oldHub);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getIntegration(integration) {\n    var client = this.getClient();\n    if (!client) return null;\n    try {\n      return client.getIntegration(integration);\n    } catch (_oO) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.warn */ .kg.warn(`Cannot retrieve integration ${integration.id} from the current Hub`);\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   startTransaction(context, customSamplingContext) {\n    return this._callExtensionMethod('startTransaction', context, customSamplingContext);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   traceHeaders() {\n    return this._callExtensionMethod('traceHeaders');\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureSession(endSession = false) {\n    // both send the update and pull the session from the scope\n    if (endSession) {\n      return this.endSession();\n    }\n\n    // only send the update\n    this._sendSessionUpdate();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   endSession() {\n    var layer = this.getStackTop();\n    var scope = layer && layer.scope;\n    var session = scope && scope.getSession();\n    if (session) {\n      (0,_session_js__WEBPACK_IMPORTED_MODULE_4__/* .closeSession */ .RJ)(session);\n    }\n    this._sendSessionUpdate();\n\n    // the session is over; take it off of the scope\n    if (scope) {\n      scope.setSession();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   startSession(context) {\n    const { scope, client } = this.getStackTop();\n    const { release, environment } = (client && client.getOptions()) || {};\n\n    // Will fetch userAgent if called from browser sdk\n    var global = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_5__/* .getGlobalObject */ .R)();\n    const { userAgent } = global.navigator || {};\n\n    var session = (0,_session_js__WEBPACK_IMPORTED_MODULE_4__/* .makeSession */ .Hv)({\n      release,\n      environment,\n      ...(scope && { user: scope.getUser() }),\n      ...(userAgent && { userAgent }),\n      ...context,\n    });\n\n    if (scope) {\n      // End existing session if there's one\n      var currentSession = scope.getSession && scope.getSession();\n      if (currentSession && currentSession.status === 'ok') {\n        (0,_session_js__WEBPACK_IMPORTED_MODULE_4__/* .updateSession */ .CT)(currentSession, { status: 'exited' });\n      }\n      this.endSession();\n\n      // Afterwards we set the new session on the scope\n      scope.setSession(session);\n    }\n\n    return session;\n  }\n\n  /**\n   * Returns if default PII should be sent to Sentry and propagated in ourgoing requests\n   * when Tracing is used.\n   */\n   shouldSendDefaultPii() {\n    var client = this.getClient();\n    var options = client && client.getOptions();\n    return Boolean(options && options.sendDefaultPii);\n  }\n\n  /**\n   * Sends the current Session on the scope\n   */\n   _sendSessionUpdate() {\n    const { scope, client } = this.getStackTop();\n    if (!scope) return;\n\n    var session = scope.getSession();\n    if (session) {\n      if (client && client.captureSession) {\n        client.captureSession(session);\n      }\n    }\n  }\n\n  /**\n   * Internal helper function to call a method on the top client if it exists.\n   *\n   * @param method The method to call on the client.\n   * @param args Arguments to pass to the client function.\n   */\n   _withClient(callback) {\n    const { scope, client } = this.getStackTop();\n    if (client) {\n      callback(client, scope);\n    }\n  }\n\n  /**\n   * Calls global extension method and binding current instance to the function call\n   */\n  // @ts-ignore Function lacks ending return statement and return type does not include 'undefined'. ts(2366)\n     _callExtensionMethod(method, ...args) {\n    var carrier = getMainCarrier();\n    var sentry = carrier.__SENTRY__;\n    if (sentry && sentry.extensions && typeof sentry.extensions[method] === 'function') {\n      return sentry.extensions[method].apply(this, args);\n    }\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.warn */ .kg.warn(`Extension method ${method} couldn't be found, doing nothing.`);\n  }\n}\n\n/**\n * Returns the global shim registry.\n *\n * FIXME: This function is problematic, because despite always returning a valid Carrier,\n * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check\n * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.\n **/\nfunction getMainCarrier() {\n  var carrier = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_5__/* .getGlobalObject */ .R)();\n  carrier.__SENTRY__ = carrier.__SENTRY__ || {\n    extensions: {},\n    hub: undefined,\n  };\n  return carrier;\n}\n\n/**\n * Replaces the current main hub with the passed one on the global object\n *\n * @returns The old replaced hub\n */\nfunction makeMain(hub) {\n  var registry = getMainCarrier();\n  var oldHub = getHubFromCarrier(registry);\n  setHubOnCarrier(registry, hub);\n  return oldHub;\n}\n\n/**\n * Returns the default hub instance.\n *\n * If a hub is already registered in the global carrier but this module\n * contains a more recent version, it replaces the registered version.\n * Otherwise, the currently registered hub will be returned.\n */\nfunction getCurrentHub() {\n  // Get main carrier (global for every environment)\n  var registry = getMainCarrier();\n\n  // If there's no hub, or its an old API, assign a new one\n  if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(API_VERSION)) {\n    setHubOnCarrier(registry, new Hub());\n  }\n\n  // Prefer domains over global if they are there (applicable only to Node environment)\n  if ((0,_sentry_utils__WEBPACK_IMPORTED_MODULE_6__/* .isNodeEnv */ .KV)()) {\n    return getHubFromActiveDomain(registry);\n  }\n  // Return hub that lives on a global object\n  return getHubFromCarrier(registry);\n}\n\n/**\n * Try to read the hub from an active domain, and fallback to the registry if one doesn't exist\n * @returns discovered hub\n */\nfunction getHubFromActiveDomain(registry) {\n  try {\n    var sentry = getMainCarrier().__SENTRY__;\n    var activeDomain = sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;\n\n    // If there's no active domain, just return global hub\n    if (!activeDomain) {\n      return getHubFromCarrier(registry);\n    }\n\n    // If there's no hub on current domain, or it's an old API, assign a new one\n    if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(API_VERSION)) {\n      var registryHubTopStack = getHubFromCarrier(registry).getStackTop();\n      setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, _scope_js__WEBPACK_IMPORTED_MODULE_0__/* .Scope.clone */ .s.clone(registryHubTopStack.scope)));\n    }\n\n    // Return hub that lives on a domain\n    return getHubFromCarrier(activeDomain);\n  } catch (_Oo) {\n    // Return hub that lives on a global object\n    return getHubFromCarrier(registry);\n  }\n}\n\n/**\n * This will tell whether a carrier has a hub on it or not\n * @param carrier object\n */\nfunction hasHubOnCarrier(carrier) {\n  return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);\n}\n\n/**\n * This will create a new {@link Hub} and add to the passed object on\n * __SENTRY__.hub.\n * @param carrier object\n * @hidden\n */\nfunction getHubFromCarrier(carrier) {\n  return (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_5__/* .getGlobalSingleton */ .Y)('hub', () => new Hub(), carrier);\n}\n\n/**\n * This will set passed {@link Hub} on the passed object's __SENTRY__.hub attribute\n * @param carrier object\n * @param hub Hub\n * @returns A boolean indicating success or failure\n */\nfunction setHubOnCarrier(carrier, hub) {\n  if (!carrier) return false;\n  var __SENTRY__ = (carrier.__SENTRY__ = carrier.__SENTRY__ || {});\n  __SENTRY__.hub = hub;\n  return true;\n}\n\n\n//# sourceMappingURL=hub.js.map\n\n\n/***/ }),\n\n/***/ 6769:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"c\": function() { return /* binding */ addGlobalEventProcessor; },\n/* harmony export */   \"s\": function() { return /* binding */ Scope; }\n/* harmony export */ });\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7597);\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1170);\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6893);\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2343);\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2844);\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2991);\n/* harmony import */ var _session_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5771);\n\n\n\n/**\n * Absolute maximum number of breadcrumbs added to an event.\n * The `maxBreadcrumbs` option cannot be higher than this value.\n */\nvar MAX_BREADCRUMBS = 100;\n\n/**\n * Holds additional event information. {@link Scope.applyToEvent} will be\n * called by the client before an event will be sent.\n */\nclass Scope  {\n  /** Flag if notifying is happening. */\n  \n\n  /** Callback for client to receive scope changes. */\n  \n\n  /** Callback list that will be called after {@link applyToEvent}. */\n  \n\n  /** Array of breadcrumbs. */\n  \n\n  /** User */\n  \n\n  /** Tags */\n  \n\n  /** Extra */\n  \n\n  /** Contexts */\n  \n\n  /** Attachments */\n  \n\n  /**\n   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get\n   * sent to Sentry\n   */\n  \n\n  /** Fingerprint */\n  \n\n  /** Severity */\n    \n\n  /** Transaction Name */\n  \n\n  /** Span */\n  \n\n  /** Session */\n  \n\n  /** Request Mode Session Status */\n  \n\n   constructor() {\n    this._notifyingListeners = false;\n    this._scopeListeners = [];\n    this._eventProcessors = [];\n    this._breadcrumbs = [];\n    this._attachments = [];\n    this._user = {};\n    this._tags = {};\n    this._extra = {};\n    this._contexts = {};\n    this._sdkProcessingMetadata = {};\n  }\n\n  /**\n   * Inherit values from the parent scope.\n   * @param scope to clone.\n   */\n   static clone(scope) {\n    var newScope = new Scope();\n    if (scope) {\n      newScope._breadcrumbs = [...scope._breadcrumbs];\n      newScope._tags = { ...scope._tags };\n      newScope._extra = { ...scope._extra };\n      newScope._contexts = { ...scope._contexts };\n      newScope._user = scope._user;\n      newScope._level = scope._level;\n      newScope._span = scope._span;\n      newScope._session = scope._session;\n      newScope._transactionName = scope._transactionName;\n      newScope._fingerprint = scope._fingerprint;\n      newScope._eventProcessors = [...scope._eventProcessors];\n      newScope._requestSession = scope._requestSession;\n      newScope._attachments = [...scope._attachments];\n    }\n    return newScope;\n  }\n\n  /**\n   * Add internal on change listener. Used for sub SDKs that need to store the scope.\n   * @hidden\n   */\n   addScopeListener(callback) {\n    this._scopeListeners.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addEventProcessor(callback) {\n    this._eventProcessors.push(callback);\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setUser(user) {\n    this._user = user || {};\n    if (this._session) {\n      (0,_session_js__WEBPACK_IMPORTED_MODULE_0__/* .updateSession */ .CT)(this._session, { user });\n    }\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getUser() {\n    return this._user;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getRequestSession() {\n    return this._requestSession;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setRequestSession(requestSession) {\n    this._requestSession = requestSession;\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTags(tags) {\n    this._tags = {\n      ...this._tags,\n      ...tags,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTag(key, value) {\n    this._tags = { ...this._tags, [key]: value };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setExtras(extras) {\n    this._extra = {\n      ...this._extra,\n      ...extras,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setExtra(key, extra) {\n    this._extra = { ...this._extra, [key]: extra };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setFingerprint(fingerprint) {\n    this._fingerprint = fingerprint;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setLevel(\n        level,\n  ) {\n    this._level = level;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTransactionName(name) {\n    this._transactionName = name;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setContext(key, context) {\n    if (context === null) {\n            delete this._contexts[key];\n    } else {\n      this._contexts = { ...this._contexts, [key]: context };\n    }\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setSpan(span) {\n    this._span = span;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getSpan() {\n    return this._span;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getTransaction() {\n    // Often, this span (if it exists at all) will be a transaction, but it's not guaranteed to be. Regardless, it will\n    // have a pointer to the currently-active transaction.\n    var span = this.getSpan();\n    return span && span.transaction;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setSession(session) {\n    if (!session) {\n      delete this._session;\n    } else {\n      this._session = session;\n    }\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getSession() {\n    return this._session;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   update(captureContext) {\n    if (!captureContext) {\n      return this;\n    }\n\n    if (typeof captureContext === 'function') {\n      var updatedScope = (captureContext )(this);\n      return updatedScope instanceof Scope ? updatedScope : this;\n    }\n\n    if (captureContext instanceof Scope) {\n      this._tags = { ...this._tags, ...captureContext._tags };\n      this._extra = { ...this._extra, ...captureContext._extra };\n      this._contexts = { ...this._contexts, ...captureContext._contexts };\n      if (captureContext._user && Object.keys(captureContext._user).length) {\n        this._user = captureContext._user;\n      }\n      if (captureContext._level) {\n        this._level = captureContext._level;\n      }\n      if (captureContext._fingerprint) {\n        this._fingerprint = captureContext._fingerprint;\n      }\n      if (captureContext._requestSession) {\n        this._requestSession = captureContext._requestSession;\n      }\n    } else if ((0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .isPlainObject */ .PO)(captureContext)) {\n            captureContext = captureContext ;\n      this._tags = { ...this._tags, ...captureContext.tags };\n      this._extra = { ...this._extra, ...captureContext.extra };\n      this._contexts = { ...this._contexts, ...captureContext.contexts };\n      if (captureContext.user) {\n        this._user = captureContext.user;\n      }\n      if (captureContext.level) {\n        this._level = captureContext.level;\n      }\n      if (captureContext.fingerprint) {\n        this._fingerprint = captureContext.fingerprint;\n      }\n      if (captureContext.requestSession) {\n        this._requestSession = captureContext.requestSession;\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   clear() {\n    this._breadcrumbs = [];\n    this._tags = {};\n    this._extra = {};\n    this._user = {};\n    this._contexts = {};\n    this._level = undefined;\n    this._transactionName = undefined;\n    this._fingerprint = undefined;\n    this._requestSession = undefined;\n    this._span = undefined;\n    this._session = undefined;\n    this._notifyScopeListeners();\n    this._attachments = [];\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addBreadcrumb(breadcrumb, maxBreadcrumbs) {\n    var maxCrumbs = typeof maxBreadcrumbs === 'number' ? Math.min(maxBreadcrumbs, MAX_BREADCRUMBS) : MAX_BREADCRUMBS;\n\n    // No data has been changed, so don't notify scope listeners\n    if (maxCrumbs <= 0) {\n      return this;\n    }\n\n    var mergedBreadcrumb = {\n      timestamp: (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_2__/* .dateTimestampInSeconds */ .yW)(),\n      ...breadcrumb,\n    };\n    this._breadcrumbs = [...this._breadcrumbs, mergedBreadcrumb].slice(-maxCrumbs);\n    this._notifyScopeListeners();\n\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   clearBreadcrumbs() {\n    this._breadcrumbs = [];\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addAttachment(attachment) {\n    this._attachments.push(attachment);\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getAttachments() {\n    return this._attachments;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   clearAttachments() {\n    this._attachments = [];\n    return this;\n  }\n\n  /**\n   * Applies data from the scope to the event and runs all event processors on it.\n   *\n   * @param event Event\n   * @param hint Object containing additional information about the original exception, for use by the event processors.\n   * @hidden\n   */\n   applyToEvent(event, hint = {}) {\n    if (this._extra && Object.keys(this._extra).length) {\n      event.extra = { ...this._extra, ...event.extra };\n    }\n    if (this._tags && Object.keys(this._tags).length) {\n      event.tags = { ...this._tags, ...event.tags };\n    }\n    if (this._user && Object.keys(this._user).length) {\n      event.user = { ...this._user, ...event.user };\n    }\n    if (this._contexts && Object.keys(this._contexts).length) {\n      event.contexts = { ...this._contexts, ...event.contexts };\n    }\n    if (this._level) {\n      event.level = this._level;\n    }\n    if (this._transactionName) {\n      event.transaction = this._transactionName;\n    }\n\n    // We want to set the trace context for normal events only if there isn't already\n    // a trace context on the event. There is a product feature in place where we link\n    // errors with transaction and it relies on that.\n    if (this._span) {\n      event.contexts = { trace: this._span.getTraceContext(), ...event.contexts };\n      var transactionName = this._span.transaction && this._span.transaction.name;\n      if (transactionName) {\n        event.tags = { transaction: transactionName, ...event.tags };\n      }\n    }\n\n    this._applyFingerprint(event);\n\n    event.breadcrumbs = [...(event.breadcrumbs || []), ...this._breadcrumbs];\n    event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : undefined;\n\n    event.sdkProcessingMetadata = { ...event.sdkProcessingMetadata, ...this._sdkProcessingMetadata };\n\n    return this._notifyEventProcessors([...getGlobalEventProcessors(), ...this._eventProcessors], event, hint);\n  }\n\n  /**\n   * Add data which will be accessible during event processing but won't get sent to Sentry\n   */\n   setSDKProcessingMetadata(newData) {\n    this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...newData };\n\n    return this;\n  }\n\n  /**\n   * This will be called after {@link applyToEvent} is finished.\n   */\n   _notifyEventProcessors(\n    processors,\n    event,\n    hint,\n    index = 0,\n  ) {\n    return new _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .SyncPromise */ .cW((resolve, reject) => {\n      var processor = processors[index];\n      if (event === null || typeof processor !== 'function') {\n        resolve(event);\n      } else {\n        var result = processor({ ...event }, hint) ;\n\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n          processor.id &&\n          result === null &&\n          _sentry_utils__WEBPACK_IMPORTED_MODULE_4__/* .logger.log */ .kg.log(`Event processor \"${processor.id}\" dropped event`);\n\n        if ((0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .isThenable */ .J8)(result)) {\n          void result\n            .then(final => this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve))\n            .then(null, reject);\n        } else {\n          void this._notifyEventProcessors(processors, result, hint, index + 1)\n            .then(resolve)\n            .then(null, reject);\n        }\n      }\n    });\n  }\n\n  /**\n   * This will be called on every set call.\n   */\n   _notifyScopeListeners() {\n    // We need this check for this._notifyingListeners to be able to work on scope during updates\n    // If this check is not here we'll produce endless recursion when something is done with the scope\n    // during the callback.\n    if (!this._notifyingListeners) {\n      this._notifyingListeners = true;\n      this._scopeListeners.forEach(callback => {\n        callback(this);\n      });\n      this._notifyingListeners = false;\n    }\n  }\n\n  /**\n   * Applies fingerprint from the scope to the event if there's one,\n   * uses message if there's one instead or get rid of empty fingerprint\n   */\n   _applyFingerprint(event) {\n    // Make sure it's an array first and we actually have something in place\n    event.fingerprint = event.fingerprint ? (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_5__/* .arrayify */ .lE)(event.fingerprint) : [];\n\n    // If we have something on the scope, then merge it with event\n    if (this._fingerprint) {\n      event.fingerprint = event.fingerprint.concat(this._fingerprint);\n    }\n\n    // If we have no data at all, remove empty array default\n    if (event.fingerprint && !event.fingerprint.length) {\n      delete event.fingerprint;\n    }\n  }\n}\n\n/**\n * Returns the global event processors.\n */\nfunction getGlobalEventProcessors() {\n  return (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_6__/* .getGlobalSingleton */ .Y)('globalEventProcessors', () => []);\n}\n\n/**\n * Add a EventProcessor to be kept globally.\n * @param callback EventProcessor to add\n */\nfunction addGlobalEventProcessor(callback) {\n  getGlobalEventProcessors().push(callback);\n}\n\n\n//# sourceMappingURL=scope.js.map\n\n\n/***/ }),\n\n/***/ 5771:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CT\": function() { return /* binding */ updateSession; },\n/* harmony export */   \"Hv\": function() { return /* binding */ makeSession; },\n/* harmony export */   \"RJ\": function() { return /* binding */ closeSession; }\n/* harmony export */ });\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1170);\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2844);\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(535);\n\n\n/**\n * Creates a new `Session` object by setting certain default parameters. If optional @param context\n * is passed, the passed properties are applied to the session object.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns a new `Session` object\n */\nfunction makeSession(context) {\n  // Both timestamp and started are in seconds since the UNIX epoch.\n  var startingTime = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_0__/* .timestampInSeconds */ .ph)();\n\n  var session = {\n    sid: (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .uuid4 */ .DM)(),\n    init: true,\n    timestamp: startingTime,\n    started: startingTime,\n    duration: 0,\n    status: 'ok',\n    errors: 0,\n    ignoreDuration: false,\n    toJSON: () => sessionToJSON(session),\n  };\n\n  if (context) {\n    updateSession(session, context);\n  }\n\n  return session;\n}\n\n/**\n * Updates a session object with the properties passed in the context.\n *\n * Note that this function mutates the passed object and returns void.\n * (Had to do this instead of returning a new and updated session because closing and sending a session\n * makes an update to the session after it was passed to the sending logic.\n * @see BaseClient.captureSession )\n *\n * @param session the `Session` to update\n * @param context the `SessionContext` holding the properties that should be updated in @param session\n */\nfunction updateSession(session, context = {}) {\n  if (context.user) {\n    if (!session.ipAddress && context.user.ip_address) {\n      session.ipAddress = context.user.ip_address;\n    }\n\n    if (!session.did && !context.did) {\n      session.did = context.user.id || context.user.email || context.user.username;\n    }\n  }\n\n  session.timestamp = context.timestamp || (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_0__/* .timestampInSeconds */ .ph)();\n\n  if (context.ignoreDuration) {\n    session.ignoreDuration = context.ignoreDuration;\n  }\n  if (context.sid) {\n    // Good enough uuid validation.  Kamil\n    session.sid = context.sid.length === 32 ? context.sid : (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .uuid4 */ .DM)();\n  }\n  if (context.init !== undefined) {\n    session.init = context.init;\n  }\n  if (!session.did && context.did) {\n    session.did = `${context.did}`;\n  }\n  if (typeof context.started === 'number') {\n    session.started = context.started;\n  }\n  if (session.ignoreDuration) {\n    session.duration = undefined;\n  } else if (typeof context.duration === 'number') {\n    session.duration = context.duration;\n  } else {\n    var duration = session.timestamp - session.started;\n    session.duration = duration >= 0 ? duration : 0;\n  }\n  if (context.release) {\n    session.release = context.release;\n  }\n  if (context.environment) {\n    session.environment = context.environment;\n  }\n  if (!session.ipAddress && context.ipAddress) {\n    session.ipAddress = context.ipAddress;\n  }\n  if (!session.userAgent && context.userAgent) {\n    session.userAgent = context.userAgent;\n  }\n  if (typeof context.errors === 'number') {\n    session.errors = context.errors;\n  }\n  if (context.status) {\n    session.status = context.status;\n  }\n}\n\n/**\n * Closes a session by setting its status and updating the session object with it.\n * Internally calls `updateSession` to update the passed session object.\n *\n * Note that this function mutates the passed session (@see updateSession for explanation).\n *\n * @param session the `Session` object to be closed\n * @param status the `SessionStatus` with which the session was closed. If you don't pass a status,\n *               this function will keep the previously set status, unless it was `'ok'` in which case\n *               it is changed to `'exited'`.\n */\nfunction closeSession(session, status) {\n  let context = {};\n  if (status) {\n    context = { status };\n  } else if (session.status === 'ok') {\n    context = { status: 'exited' };\n  }\n\n  updateSession(session, context);\n}\n\n/**\n * Serializes a passed session object to a JSON object with a slightly different structure.\n * This is necessary because the Sentry backend requires a slightly different schema of a session\n * than the one the JS SDKs use internally.\n *\n * @param session the session to be converted\n *\n * @returns a JSON object of the passed session\n */\nfunction sessionToJSON(session) {\n  return (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_2__/* .dropUndefinedKeys */ .Jr)({\n    sid: `${session.sid}`,\n    init: session.init,\n    // Make sure that sec is converted to ms for date constructor\n    started: new Date(session.started * 1000).toISOString(),\n    timestamp: new Date(session.timestamp * 1000).toISOString(),\n    status: session.status,\n    errors: session.errors,\n    did: typeof session.did === 'number' || typeof session.did === 'string' ? `${session.did}` : undefined,\n    duration: session.duration,\n    attrs: {\n      release: session.release,\n      environment: session.environment,\n      ip_address: session.ipAddress,\n      user_agent: session.userAgent,\n    },\n  });\n}\n\n\n//# sourceMappingURL=session.js.map\n\n\n/***/ }),\n\n/***/ 2758:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"ro\": function() { return /* binding */ addExtensionMethods; },\n  \"lb\": function() { return /* binding */ startIdleTransaction; }\n});\n\n// UNUSED EXPORTS: _addTracingExtensions\n\n// EXTERNAL MODULE: ./node_modules/@sentry/hub/esm/hub.js\nvar hub = __webpack_require__(8641);\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/logger.js\nvar logger = __webpack_require__(2343);\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/is.js\nvar is = __webpack_require__(7597);\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/node.js + 1 modules\nvar node = __webpack_require__(2448);\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/instrument.js\nvar instrument = __webpack_require__(9732);\n// EXTERNAL MODULE: ./node_modules/@sentry/tracing/esm/utils.js\nvar utils = __webpack_require__(3233);\n;// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/errors.js\n\n\n\n/**\n * Configures global error listeners\n */\nfunction registerErrorInstrumentation() {\n  (0,instrument/* addInstrumentationHandler */.o)('error', errorCallback);\n  (0,instrument/* addInstrumentationHandler */.o)('unhandledrejection', errorCallback);\n}\n\n/**\n * If an error or unhandled promise occurs, we mark the active transaction as failed\n */\nfunction errorCallback() {\n  var activeTransaction = (0,utils/* getActiveTransaction */.x1)();\n  if (activeTransaction) {\n    var status = 'internal_error';\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.log */.kg.log(`[Tracing] Transaction: ${status} -> Global error occured`);\n    activeTransaction.setStatus(status);\n  }\n}\n\n\n//# sourceMappingURL=errors.js.map\n\n// EXTERNAL MODULE: ./node_modules/@sentry/tracing/esm/idletransaction.js\nvar idletransaction = __webpack_require__(6458);\n// EXTERNAL MODULE: ./node_modules/@sentry/tracing/esm/transaction.js\nvar esm_transaction = __webpack_require__(3391);\n;// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/hubextensions.js\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\n\n\n\n\n\n/** Returns all trace headers that are currently on the top scope. */\nfunction traceHeaders() {\n  var scope = this.getScope();\n  if (scope) {\n    var span = scope.getSpan();\n    if (span) {\n      return {\n        'sentry-trace': span.toTraceparent(),\n      };\n    }\n  }\n  return {};\n}\n\n/**\n * Makes a sampling decision for the given transaction and stores it on the transaction.\n *\n * Called every time a transaction is created. Only transactions which emerge with a `sampled` value of `true` will be\n * sent to Sentry.\n *\n * @param transaction: The transaction needing a sampling decision\n * @param options: The current client's options, so we can access `tracesSampleRate` and/or `tracesSampler`\n * @param samplingContext: Default and user-provided data which may be used to help make the decision\n *\n * @returns The given transaction with its `sampled` value set\n */\nfunction sample(\n  transaction,\n  options,\n  samplingContext,\n) {\n  // nothing to do if tracing is not enabled\n  if (!(0,utils/* hasTracingEnabled */.zu)(options)) {\n    transaction.sampled = false;\n    return transaction;\n  }\n\n  // if the user has forced a sampling decision by passing a `sampled` value in their transaction context, go with that\n  if (transaction.sampled !== undefined) {\n    transaction.setMetadata({\n      transactionSampling: {\n        method: 'explicitly_set',\n        rate: Number(transaction.sampled),\n      },\n    });\n    return transaction;\n  }\n\n  // we would have bailed already if neither `tracesSampler` nor `tracesSampleRate` were defined, so one of these should\n  // work; prefer the hook if so\n  let sampleRate;\n  if (typeof options.tracesSampler === 'function') {\n    sampleRate = options.tracesSampler(samplingContext);\n    transaction.setMetadata({\n      transactionSampling: {\n        method: 'client_sampler',\n        // cast to number in case it's a boolean\n        rate: Number(sampleRate),\n      },\n    });\n  } else if (samplingContext.parentSampled !== undefined) {\n    sampleRate = samplingContext.parentSampled;\n    transaction.setMetadata({\n      transactionSampling: { method: 'inheritance' },\n    });\n  } else {\n    sampleRate = options.tracesSampleRate;\n    transaction.setMetadata({\n      transactionSampling: {\n        method: 'client_rate',\n        // cast to number in case it's a boolean\n        rate: Number(sampleRate),\n      },\n    });\n  }\n\n  // Since this is coming from the user (or from a function provided by the user), who knows what we might get. (The\n  // only valid values are booleans or numbers between 0 and 1.)\n  if (!isValidSampleRate(sampleRate)) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.warn */.kg.warn('[Tracing] Discarding transaction because of invalid sample rate.');\n    transaction.sampled = false;\n    return transaction;\n  }\n\n  // if the function returned 0 (or false), or if `tracesSampleRate` is 0, it's a sign the transaction should be dropped\n  if (!sampleRate) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger/* logger.log */.kg.log(\n        `[Tracing] Discarding transaction because ${\n          typeof options.tracesSampler === 'function'\n            ? 'tracesSampler returned 0 or false'\n            : 'a negative sampling decision was inherited or tracesSampleRate is set to 0'\n        }`,\n      );\n    transaction.sampled = false;\n    return transaction;\n  }\n\n  // Now we roll the dice. Math.random is inclusive of 0, but not of 1, so strict < is safe here. In case sampleRate is\n  // a boolean, the < comparison will cause it to be automatically cast to 1 if it's true and 0 if it's false.\n  transaction.sampled = Math.random() < (sampleRate );\n\n  // if we're not going to keep it, we're done\n  if (!transaction.sampled) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger/* logger.log */.kg.log(\n        `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(\n          sampleRate,\n        )})`,\n      );\n    return transaction;\n  }\n\n  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger/* logger.log */.kg.log(`[Tracing] starting ${transaction.op} transaction - ${transaction.name}`);\n  return transaction;\n}\n\n/**\n * Checks the given sample rate to make sure it is valid type and value (a boolean, or a number between 0 and 1).\n */\nfunction isValidSampleRate(rate) {\n  // we need to check NaN explicitly because it's of type 'number' and therefore wouldn't get caught by this typecheck\n    if ((0,is/* isNaN */.i2)(rate) || !(typeof rate === 'number' || typeof rate === 'boolean')) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger/* logger.warn */.kg.warn(\n        `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(\n          rate,\n        )} of type ${JSON.stringify(typeof rate)}.`,\n      );\n    return false;\n  }\n\n  // in case sampleRate is a boolean, it will get automatically cast to 1 if it's true and 0 if it's false\n  if (rate < 0 || rate > 1) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger/* logger.warn */.kg.warn(`[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got ${rate}.`);\n    return false;\n  }\n  return true;\n}\n\n/**\n * Creates a new transaction and adds a sampling decision if it doesn't yet have one.\n *\n * The Hub.startTransaction method delegates to this method to do its work, passing the Hub instance in as `this`, as if\n * it had been called on the hub directly. Exists as a separate function so that it can be injected into the class as an\n * \"extension method.\"\n *\n * @param this: The Hub starting the transaction\n * @param transactionContext: Data used to configure the transaction\n * @param CustomSamplingContext: Optional data to be provided to the `tracesSampler` function (if any)\n *\n * @returns The new transaction\n *\n * @see {@link Hub.startTransaction}\n */\nfunction _startTransaction(\n  \n  transactionContext,\n  customSamplingContext,\n) {\n  var client = this.getClient();\n  var options = (client && client.getOptions()) || {};\n\n  let transaction = new esm_transaction/* Transaction */.Y(transactionContext, this);\n  transaction = sample(transaction, options, {\n    parentSampled: transactionContext.parentSampled,\n    transactionContext,\n    ...customSamplingContext,\n  });\n  if (transaction.sampled) {\n    transaction.initSpanRecorder(options._experiments && (options._experiments.maxSpans ));\n  }\n  return transaction;\n}\n\n/**\n * Create new idle transaction.\n */\nfunction startIdleTransaction(\n  hub,\n  transactionContext,\n  idleTimeout,\n  finalTimeout,\n  onScope,\n  customSamplingContext,\n) {\n  var client = hub.getClient();\n  var options = (client && client.getOptions()) || {};\n\n  let transaction = new idletransaction/* IdleTransaction */.io(transactionContext, hub, idleTimeout, finalTimeout, onScope);\n  transaction = sample(transaction, options, {\n    parentSampled: transactionContext.parentSampled,\n    transactionContext,\n    ...customSamplingContext,\n  });\n  if (transaction.sampled) {\n    transaction.initSpanRecorder(options._experiments && (options._experiments.maxSpans ));\n  }\n  return transaction;\n}\n\n/**\n * @private\n */\nfunction _addTracingExtensions() {\n  var carrier = (0,hub/* getMainCarrier */.cu)();\n  if (!carrier.__SENTRY__) {\n    return;\n  }\n  carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};\n  if (!carrier.__SENTRY__.extensions.startTransaction) {\n    carrier.__SENTRY__.extensions.startTransaction = _startTransaction;\n  }\n  if (!carrier.__SENTRY__.extensions.traceHeaders) {\n    carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;\n  }\n}\n\n/**\n * @private\n */\nfunction _autoloadDatabaseIntegrations() {\n  var carrier = (0,hub/* getMainCarrier */.cu)();\n  if (!carrier.__SENTRY__) {\n    return;\n  }\n\n  var packageToIntegrationMapping = {\n    mongodb() {\n      var integration = (0,node/* dynamicRequire */.l$)(module, './integrations/node/mongo') \n\n;\n      return new integration.Mongo();\n    },\n    mongoose() {\n      var integration = (0,node/* dynamicRequire */.l$)(module, './integrations/node/mongo') \n\n;\n      return new integration.Mongo({ mongoose: true });\n    },\n    mysql() {\n      var integration = (0,node/* dynamicRequire */.l$)(module, './integrations/node/mysql') \n\n;\n      return new integration.Mysql();\n    },\n    pg() {\n      var integration = (0,node/* dynamicRequire */.l$)(module, './integrations/node/postgres') \n\n;\n      return new integration.Postgres();\n    },\n  };\n\n  var mappedPackages = Object.keys(packageToIntegrationMapping)\n    .filter(moduleName => !!(0,node/* loadModule */.$y)(moduleName))\n    .map(pkg => {\n      try {\n        return packageToIntegrationMapping[pkg]();\n      } catch (e) {\n        return undefined;\n      }\n    })\n    .filter(p => p) ;\n\n  if (mappedPackages.length > 0) {\n    carrier.__SENTRY__.integrations = [...(carrier.__SENTRY__.integrations || []), ...mappedPackages];\n  }\n}\n\n/**\n * This patches the global object and injects the Tracing extensions methods\n */\nfunction addExtensionMethods() {\n  _addTracingExtensions();\n\n  // Detect and automatically load specified integrations.\n  if ((0,node/* isNodeEnv */.KV)()) {\n    _autoloadDatabaseIntegrations();\n  }\n\n  // If an error happens globally, we should make sure transaction status is set to error.\n  registerErrorInstrumentation();\n}\n\n\n//# sourceMappingURL=hubextensions.js.map\n\n\n/***/ }),\n\n/***/ 6458:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"io\": function() { return /* binding */ IdleTransaction; },\n/* harmony export */   \"mg\": function() { return /* binding */ DEFAULT_FINAL_TIMEOUT; },\n/* harmony export */   \"nT\": function() { return /* binding */ DEFAULT_IDLE_TIMEOUT; }\n/* harmony export */ });\n/* unused harmony exports HEARTBEAT_INTERVAL, IdleTransactionSpanRecorder */\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1170);\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2343);\n/* harmony import */ var _span_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5334);\n/* harmony import */ var _transaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3391);\n\n\n\n\nvar DEFAULT_IDLE_TIMEOUT = 1000;\nvar DEFAULT_FINAL_TIMEOUT = 30000;\nvar HEARTBEAT_INTERVAL = 5000;\n\n/**\n * @inheritDoc\n */\nclass IdleTransactionSpanRecorder extends _span_js__WEBPACK_IMPORTED_MODULE_0__/* .SpanRecorder */ .gB {\n   constructor(\n      _pushActivity,\n      _popActivity,\n     transactionSpanId,\n    maxlen,\n  ) {\n    super(maxlen);this._pushActivity = _pushActivity;this._popActivity = _popActivity;this.transactionSpanId = transactionSpanId;;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   add(span) {\n    // We should make sure we do not push and pop activities for\n    // the transaction that this span recorder belongs to.\n    if (span.spanId !== this.transactionSpanId) {\n      // We patch span.finish() to pop an activity after setting an endTimestamp.\n      span.finish = (endTimestamp) => {\n        span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .timestampWithMs */ ._I)();\n        this._popActivity(span.spanId);\n      };\n\n      // We should only push new activities if the span does not have an end timestamp.\n      if (span.endTimestamp === undefined) {\n        this._pushActivity(span.spanId);\n      }\n    }\n\n    super.add(span);\n  }\n}\n\n/**\n * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.\n * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will\n * put itself on the scope on creation.\n */\nclass IdleTransaction extends _transaction_js__WEBPACK_IMPORTED_MODULE_2__/* .Transaction */ .Y {\n  // Activities store a list of active spans\n   __init() {this.activities = {};}\n\n  // Track state of activities in previous heartbeat\n  \n\n  // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.\n   __init2() {this._heartbeatCounter = 0;}\n\n  // We should not use heartbeat if we finished a transaction\n   __init3() {this._finished = false;}\n\n    __init4() {this._beforeFinishCallbacks = [];}\n\n  /**\n   * Timer that tracks Transaction idleTimeout\n   */\n  \n\n   constructor(\n    transactionContext,\n      _idleHub,\n    /**\n     * The time to wait in ms until the idle transaction will be finished. This timer is started each time\n     * there are no active spans on this transaction.\n     */\n      _idleTimeout = DEFAULT_IDLE_TIMEOUT,\n    /**\n     * The final value in ms that a transaction cannot exceed\n     */\n      _finalTimeout = DEFAULT_FINAL_TIMEOUT,\n    // Whether or not the transaction should put itself on the scope when it starts and pop itself off when it ends\n      _onScope = false,\n  ) {\n    super(transactionContext, _idleHub);this._idleHub = _idleHub;this._idleTimeout = _idleTimeout;this._finalTimeout = _finalTimeout;this._onScope = _onScope;IdleTransaction.prototype.__init.call(this);IdleTransaction.prototype.__init2.call(this);IdleTransaction.prototype.__init3.call(this);IdleTransaction.prototype.__init4.call(this);;\n\n    if (_onScope) {\n      // There should only be one active transaction on the scope\n      clearActiveTransaction(_idleHub);\n\n      // We set the transaction here on the scope so error events pick up the trace\n      // context and attach it to the error.\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log(`Setting idle transaction on scope. Span ID: ${this.spanId}`);\n      _idleHub.configureScope(scope => scope.setSpan(this));\n    }\n\n    this._startIdleTimeout();\n    setTimeout(() => {\n      if (!this._finished) {\n        this.setStatus('deadline_exceeded');\n        this.finish();\n      }\n    }, this._finalTimeout);\n  }\n\n  /** {@inheritDoc} */\n   finish(endTimestamp = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .timestampWithMs */ ._I)()) {\n    this._finished = true;\n    this.activities = {};\n\n    if (this.spanRecorder) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);\n\n      for (var callback of this._beforeFinishCallbacks) {\n        callback(this, endTimestamp);\n      }\n\n      this.spanRecorder.spans = this.spanRecorder.spans.filter((span) => {\n        // If we are dealing with the transaction itself, we just return it\n        if (span.spanId === this.spanId) {\n          return true;\n        }\n\n        // We cancel all pending spans with status \"cancelled\" to indicate the idle transaction was finished early\n        if (!span.endTimestamp) {\n          span.endTimestamp = endTimestamp;\n          span.setStatus('cancelled');\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n            _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));\n        }\n\n        var keepSpan = span.startTimestamp < endTimestamp;\n        if (!keepSpan) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n            _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log(\n              '[Tracing] discarding Span since it happened after Transaction was finished',\n              JSON.stringify(span, undefined, 2),\n            );\n        }\n        return keepSpan;\n      });\n\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log('[Tracing] flushing IdleTransaction');\n    } else {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log('[Tracing] No active IdleTransaction');\n    }\n\n    // if `this._onScope` is `true`, the transaction put itself on the scope when it started\n    if (this._onScope) {\n      clearActiveTransaction(this._idleHub);\n    }\n\n    return super.finish(endTimestamp);\n  }\n\n  /**\n   * Register a callback function that gets excecuted before the transaction finishes.\n   * Useful for cleanup or if you want to add any additional spans based on current context.\n   *\n   * This is exposed because users have no other way of running something before an idle transaction\n   * finishes.\n   */\n   registerBeforeFinishCallback(callback) {\n    this._beforeFinishCallbacks.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   initSpanRecorder(maxlen) {\n    if (!this.spanRecorder) {\n      var pushActivity = (id) => {\n        if (this._finished) {\n          return;\n        }\n        this._pushActivity(id);\n      };\n      var popActivity = (id) => {\n        if (this._finished) {\n          return;\n        }\n        this._popActivity(id);\n      };\n\n      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);\n\n      // Start heartbeat so that transactions do not run forever.\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log('Starting heartbeat');\n      this._pingHeartbeat();\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * Cancels the existing idletimeout, if there is one\n   */\n   _cancelIdleTimeout() {\n    if (this._idleTimeoutID) {\n      clearTimeout(this._idleTimeoutID);\n      this._idleTimeoutID = undefined;\n    }\n  }\n\n  /**\n   * Creates an idletimeout\n   */\n   _startIdleTimeout(endTimestamp) {\n    this._cancelIdleTimeout();\n    this._idleTimeoutID = setTimeout(() => {\n      if (!this._finished && Object.keys(this.activities).length === 0) {\n        this.finish(endTimestamp);\n      }\n    }, this._idleTimeout);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n   _pushActivity(spanId) {\n    this._cancelIdleTimeout();\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log(`[Tracing] pushActivity: ${spanId}`);\n    this.activities[spanId] = true;\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log('[Tracing] new activities count', Object.keys(this.activities).length);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n   _popActivity(spanId) {\n    if (this.activities[spanId]) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log(`[Tracing] popActivity ${spanId}`);\n            delete this.activities[spanId];\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log('[Tracing] new activities count', Object.keys(this.activities).length);\n    }\n\n    if (Object.keys(this.activities).length === 0) {\n      // We need to add the timeout here to have the real endtimestamp of the transaction\n      // Remember timestampWithMs is in seconds, timeout is in ms\n      var endTimestamp = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .timestampWithMs */ ._I)() + this._idleTimeout / 1000;\n      this._startIdleTimeout(endTimestamp);\n    }\n  }\n\n  /**\n   * Checks when entries of this.activities are not changing for 3 beats.\n   * If this occurs we finish the transaction.\n   */\n   _beat() {\n    // We should not be running heartbeat if the idle transaction is finished.\n    if (this._finished) {\n      return;\n    }\n\n    var heartbeatString = Object.keys(this.activities).join('');\n\n    if (heartbeatString === this._prevHeartbeatString) {\n      this._heartbeatCounter += 1;\n    } else {\n      this._heartbeatCounter = 1;\n    }\n\n    this._prevHeartbeatString = heartbeatString;\n\n    if (this._heartbeatCounter >= 3) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log('[Tracing] Transaction finished because of no change for 3 heart beats');\n      this.setStatus('deadline_exceeded');\n      this.finish();\n    } else {\n      this._pingHeartbeat();\n    }\n  }\n\n  /**\n   * Pings the heartbeat\n   */\n   _pingHeartbeat() {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);\n    setTimeout(() => {\n      this._beat();\n    }, HEARTBEAT_INTERVAL);\n  }\n}\n\n/**\n * Reset transaction on scope to `undefined`\n */\nfunction clearActiveTransaction(hub) {\n  var scope = hub.getScope();\n  if (scope) {\n    var transaction = scope.getTransaction();\n    if (transaction) {\n      scope.setSpan(undefined);\n    }\n  }\n}\n\n\n//# sourceMappingURL=idletransaction.js.map\n\n\n/***/ }),\n\n/***/ 5334:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Dr\": function() { return /* binding */ Span; },\n/* harmony export */   \"gB\": function() { return /* binding */ SpanRecorder; }\n/* harmony export */ });\n/* unused harmony export spanStatusfromHttpCode */\n/* harmony import */ var _sentry_utils_esm_buildPolyfills__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5375);\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2844);\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1170);\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2343);\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(535);\n\n\n\n/**\n * Keeps track of finished spans for a given transaction\n * @internal\n * @hideconstructor\n * @hidden\n */\nclass SpanRecorder {\n   __init() {this.spans = [];}\n\n   constructor(maxlen = 1000) {;SpanRecorder.prototype.__init.call(this);\n    this._maxlen = maxlen;\n  }\n\n  /**\n   * This is just so that we don't run out of memory while recording a lot\n   * of spans. At some point we just stop and flush out the start of the\n   * trace tree (i.e.the first n spans with the smallest\n   * start_timestamp).\n   */\n   add(span) {\n    if (this.spans.length > this._maxlen) {\n      span.spanRecorder = undefined;\n    } else {\n      this.spans.push(span);\n    }\n  }\n}\n\n/**\n * Span contains all data about a span\n */\nclass Span  {\n  /**\n   * @inheritDoc\n   */\n   __init2() {this.traceId = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_0__/* .uuid4 */ .DM)();}\n\n  /**\n   * @inheritDoc\n   */\n   __init3() {this.spanId = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_0__/* .uuid4 */ .DM)().substring(16);}\n\n  /**\n   * @inheritDoc\n   */\n  \n\n  /**\n   * Internal keeper of the status\n   */\n  \n\n  /**\n   * @inheritDoc\n   */\n  \n\n  /**\n   * Timestamp in seconds when the span was created.\n   */\n   __init4() {this.startTimestamp = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .timestampWithMs */ ._I)();}\n\n  /**\n   * Timestamp in seconds when the span ended.\n   */\n  \n\n  /**\n   * @inheritDoc\n   */\n  \n\n  /**\n   * @inheritDoc\n   */\n  \n\n  /**\n   * @inheritDoc\n   */\n   __init5() {this.tags = {};}\n\n  /**\n   * @inheritDoc\n   */\n     __init6() {this.data = {};}\n\n  /**\n   * List of spans that were finalized\n   */\n  \n\n  /**\n   * @inheritDoc\n   */\n  \n\n  /**\n   * You should never call the constructor manually, always use `Sentry.startTransaction()`\n   * or call `startChild()` on an existing span.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n   constructor(spanContext) {;Span.prototype.__init2.call(this);Span.prototype.__init3.call(this);Span.prototype.__init4.call(this);Span.prototype.__init5.call(this);Span.prototype.__init6.call(this);\n    if (!spanContext) {\n      return this;\n    }\n    if (spanContext.traceId) {\n      this.traceId = spanContext.traceId;\n    }\n    if (spanContext.spanId) {\n      this.spanId = spanContext.spanId;\n    }\n    if (spanContext.parentSpanId) {\n      this.parentSpanId = spanContext.parentSpanId;\n    }\n    // We want to include booleans as well here\n    if ('sampled' in spanContext) {\n      this.sampled = spanContext.sampled;\n    }\n    if (spanContext.op) {\n      this.op = spanContext.op;\n    }\n    if (spanContext.description) {\n      this.description = spanContext.description;\n    }\n    if (spanContext.data) {\n      this.data = spanContext.data;\n    }\n    if (spanContext.tags) {\n      this.tags = spanContext.tags;\n    }\n    if (spanContext.status) {\n      this.status = spanContext.status;\n    }\n    if (spanContext.startTimestamp) {\n      this.startTimestamp = spanContext.startTimestamp;\n    }\n    if (spanContext.endTimestamp) {\n      this.endTimestamp = spanContext.endTimestamp;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   startChild(\n    spanContext,\n  ) {\n    var childSpan = new Span({\n      ...spanContext,\n      parentSpanId: this.spanId,\n      sampled: this.sampled,\n      traceId: this.traceId,\n    });\n\n    childSpan.spanRecorder = this.spanRecorder;\n    if (childSpan.spanRecorder) {\n      childSpan.spanRecorder.add(childSpan);\n    }\n\n    childSpan.transaction = this.transaction;\n\n    if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && childSpan.transaction) {\n      var opStr = (spanContext && spanContext.op) || '< unknown op >';\n      var nameStr = childSpan.transaction.name || '< unknown name >';\n      var idStr = childSpan.transaction.spanId;\n\n      var logMessage = `[Tracing] Starting '${opStr}' span on transaction '${nameStr}' (${idStr}).`;\n      childSpan.transaction.metadata.spanMetadata[childSpan.spanId] = { logMessage };\n      _sentry_utils__WEBPACK_IMPORTED_MODULE_2__/* .logger.log */ .kg.log(logMessage);\n    }\n\n    return childSpan;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTag(key, value) {\n    this.tags = { ...this.tags, [key]: value };\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n     setData(key, value) {\n    this.data = { ...this.data, [key]: value };\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setStatus(value) {\n    this.status = value;\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setHttpStatus(httpStatus) {\n    this.setTag('http.status_code', String(httpStatus));\n    var spanStatus = spanStatusfromHttpCode(httpStatus);\n    if (spanStatus !== 'unknown_error') {\n      this.setStatus(spanStatus);\n    }\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   isSuccess() {\n    return this.status === 'ok';\n  }\n\n  /**\n   * @inheritDoc\n   */\n   finish(endTimestamp) {\n    if (\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      // Don't call this for transactions\n      this.transaction &&\n      this.transaction.spanId !== this.spanId\n    ) {\n      const { logMessage } = this.transaction.metadata.spanMetadata[this.spanId];\n      if (logMessage) {\n        _sentry_utils__WEBPACK_IMPORTED_MODULE_2__/* .logger.log */ .kg.log((logMessage ).replace('Starting', 'Finishing'));\n      }\n    }\n\n    this.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__/* .timestampWithMs */ ._I)();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   toTraceparent() {\n    let sampledString = '';\n    if (this.sampled !== undefined) {\n      sampledString = this.sampled ? '-1' : '-0';\n    }\n    return `${this.traceId}-${this.spanId}${sampledString}`;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   toContext() {\n    return (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .dropUndefinedKeys */ .Jr)({\n      data: this.data,\n      description: this.description,\n      endTimestamp: this.endTimestamp,\n      op: this.op,\n      parentSpanId: this.parentSpanId,\n      sampled: this.sampled,\n      spanId: this.spanId,\n      startTimestamp: this.startTimestamp,\n      status: this.status,\n      tags: this.tags,\n      traceId: this.traceId,\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n   updateWithContext(spanContext) {\n    this.data = (0,_sentry_utils_esm_buildPolyfills__WEBPACK_IMPORTED_MODULE_4__/* ._nullishCoalesce */ .h)(spanContext.data, () => ( {}));\n    this.description = spanContext.description;\n    this.endTimestamp = spanContext.endTimestamp;\n    this.op = spanContext.op;\n    this.parentSpanId = spanContext.parentSpanId;\n    this.sampled = spanContext.sampled;\n    this.spanId = (0,_sentry_utils_esm_buildPolyfills__WEBPACK_IMPORTED_MODULE_4__/* ._nullishCoalesce */ .h)(spanContext.spanId, () => ( this.spanId));\n    this.startTimestamp = (0,_sentry_utils_esm_buildPolyfills__WEBPACK_IMPORTED_MODULE_4__/* ._nullishCoalesce */ .h)(spanContext.startTimestamp, () => ( this.startTimestamp));\n    this.status = spanContext.status;\n    this.tags = (0,_sentry_utils_esm_buildPolyfills__WEBPACK_IMPORTED_MODULE_4__/* ._nullishCoalesce */ .h)(spanContext.tags, () => ( {}));\n    this.traceId = (0,_sentry_utils_esm_buildPolyfills__WEBPACK_IMPORTED_MODULE_4__/* ._nullishCoalesce */ .h)(spanContext.traceId, () => ( this.traceId));\n\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getTraceContext()\n\n {\n    return (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .dropUndefinedKeys */ .Jr)({\n      data: Object.keys(this.data).length > 0 ? this.data : undefined,\n      description: this.description,\n      op: this.op,\n      parent_span_id: this.parentSpanId,\n      span_id: this.spanId,\n      status: this.status,\n      tags: Object.keys(this.tags).length > 0 ? this.tags : undefined,\n      trace_id: this.traceId,\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n   toJSON()\n\n {\n    return (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .dropUndefinedKeys */ .Jr)({\n      data: Object.keys(this.data).length > 0 ? this.data : undefined,\n      description: this.description,\n      op: this.op,\n      parent_span_id: this.parentSpanId,\n      span_id: this.spanId,\n      start_timestamp: this.startTimestamp,\n      status: this.status,\n      tags: Object.keys(this.tags).length > 0 ? this.tags : undefined,\n      timestamp: this.endTimestamp,\n      trace_id: this.traceId,\n    });\n  }\n}\n\n/**\n * Converts a HTTP status code into a {@link SpanStatusType}.\n *\n * @param httpStatus The HTTP response status code.\n * @returns The span status or unknown_error.\n */\nfunction spanStatusfromHttpCode(httpStatus) {\n  if (httpStatus < 400 && httpStatus >= 100) {\n    return 'ok';\n  }\n\n  if (httpStatus >= 400 && httpStatus < 500) {\n    switch (httpStatus) {\n      case 401:\n        return 'unauthenticated';\n      case 403:\n        return 'permission_denied';\n      case 404:\n        return 'not_found';\n      case 409:\n        return 'already_exists';\n      case 413:\n        return 'failed_precondition';\n      case 429:\n        return 'resource_exhausted';\n      default:\n        return 'invalid_argument';\n    }\n  }\n\n  if (httpStatus >= 500 && httpStatus < 600) {\n    switch (httpStatus) {\n      case 501:\n        return 'unimplemented';\n      case 503:\n        return 'unavailable';\n      case 504:\n        return 'deadline_exceeded';\n      default:\n        return 'internal_error';\n    }\n  }\n\n  return 'unknown_error';\n}\n\n\n//# sourceMappingURL=span.js.map\n\n\n/***/ }),\n\n/***/ 3391:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Y\": function() { return /* binding */ Transaction; }\n/* harmony export */ });\n/* harmony import */ var _sentry_utils_esm_buildPolyfills__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5375);\n/* harmony import */ var _sentry_hub__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8641);\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1170);\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2343);\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(535);\n/* harmony import */ var _span_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5334);\n\n\n\n\n\n/** JSDoc */\nclass Transaction extends _span_js__WEBPACK_IMPORTED_MODULE_0__/* .Span */ .Dr  {\n  \n\n  /**\n   * The reference to the current hub.\n   */\n  \n\n   __init() {this._measurements = {};}\n\n   __init2() {this._frozenDynamicSamplingContext = undefined;}\n\n  /**\n   * This constructor should never be called manually. Those instrumenting tracing should use\n   * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n   constructor(transactionContext, hub) {\n    super(transactionContext);Transaction.prototype.__init.call(this);Transaction.prototype.__init2.call(this);;\n\n    this._hub = hub || (0,_sentry_hub__WEBPACK_IMPORTED_MODULE_1__/* .getCurrentHub */ .Gd)();\n\n    this._name = transactionContext.name || '';\n\n    this.metadata = {\n      source: 'custom',\n      ...transactionContext.metadata,\n      spanMetadata: {},\n      changes: [],\n      propagations: 0,\n    };\n\n    this._trimEnd = transactionContext.trimEnd;\n\n    // this is because transactions are also spans, and spans have a transaction pointer\n    this.transaction = this;\n\n    // If Dynamic Sampling Context is provided during the creation of the transaction, we freeze it as it usually means\n    // there is incoming Dynamic Sampling Context. (Either through an incoming request, a baggage meta-tag, or other means)\n    var incomingDynamicSamplingContext = this.metadata.dynamicSamplingContext;\n    if (incomingDynamicSamplingContext) {\n      // We shallow copy this in case anything writes to the original reference of the passed in `dynamicSamplingContext`\n      this._frozenDynamicSamplingContext = { ...incomingDynamicSamplingContext };\n    }\n  }\n\n  /** Getter for `name` property */\n   get name() {\n    return this._name;\n  }\n\n  /** Setter for `name` property, which also sets `source` as custom */\n   set name(newName) {\n    this.setName(newName);\n  }\n\n  /**\n   * JSDoc\n   */\n   setName(name, source = 'custom') {\n    // `source` could change without the name changing if we discover that an unparameterized route is actually\n    // parameterized by virtue of having no parameters in its path\n    if (name !== this.name || source !== this.metadata.source) {\n      this.metadata.changes.push({\n        // log previous source\n        source: this.metadata.source,\n        timestamp: (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_2__/* .timestampInSeconds */ .ph)(),\n        propagations: this.metadata.propagations,\n      });\n    }\n\n    this._name = name;\n    this.metadata.source = source;\n  }\n\n  /**\n   * Attaches SpanRecorder to the span itself\n   * @param maxlen maximum number of spans that can be recorded\n   */\n   initSpanRecorder(maxlen = 1000) {\n    if (!this.spanRecorder) {\n      this.spanRecorder = new _span_js__WEBPACK_IMPORTED_MODULE_0__/* .SpanRecorder */ .gB(maxlen);\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setMeasurement(name, value, unit = '') {\n    this._measurements[name] = { value, unit };\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setMetadata(newMetadata) {\n    this.metadata = { ...this.metadata, ...newMetadata };\n  }\n\n  /**\n   * @inheritDoc\n   */\n   finish(endTimestamp) {\n    // This transaction is already finished, so we should not flush it again.\n    if (this.endTimestamp !== undefined) {\n      return undefined;\n    }\n\n    if (!this.name) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.warn */ .kg.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');\n      this.name = '<unlabeled transaction>';\n    }\n\n    // just sets the end timestamp\n    super.finish(endTimestamp);\n\n    if (this.sampled !== true) {\n      // At this point if `sampled !== true` we want to discard the transaction.\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log('[Tracing] Discarding transaction because its trace was not chosen to be sampled.');\n\n      var client = this._hub.getClient();\n      if (client) {\n        client.recordDroppedEvent('sample_rate', 'transaction');\n      }\n\n      return undefined;\n    }\n\n    var finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(s => s !== this && s.endTimestamp) : [];\n\n    if (this._trimEnd && finishedSpans.length > 0) {\n      this.endTimestamp = finishedSpans.reduce((prev, current) => {\n        if (prev.endTimestamp && current.endTimestamp) {\n          return prev.endTimestamp > current.endTimestamp ? prev : current;\n        }\n        return prev;\n      }).endTimestamp;\n    }\n\n    var metadata = this.metadata;\n\n    var transaction = {\n      contexts: {\n        trace: this.getTraceContext(),\n      },\n      spans: finishedSpans,\n      start_timestamp: this.startTimestamp,\n      tags: this.tags,\n      timestamp: this.endTimestamp,\n      transaction: this.name,\n      type: 'transaction',\n      sdkProcessingMetadata: {\n        ...metadata,\n        dynamicSamplingContext: this.getDynamicSamplingContext(),\n      },\n      ...(metadata.source && {\n        transaction_info: {\n          source: metadata.source,\n          changes: metadata.changes,\n          propagations: metadata.propagations,\n        },\n      }),\n    };\n\n    var hasMeasurements = Object.keys(this._measurements).length > 0;\n\n    if (hasMeasurements) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log(\n          '[Measurements] Adding measurements to transaction',\n          JSON.stringify(this._measurements, undefined, 2),\n        );\n      transaction.measurements = this._measurements;\n    }\n\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__/* .logger.log */ .kg.log(`[Tracing] Finishing ${this.op} transaction: ${this.name}.`);\n\n    return this._hub.captureEvent(transaction);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   toContext() {\n    var spanContext = super.toContext();\n\n    return (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_4__/* .dropUndefinedKeys */ .Jr)({\n      ...spanContext,\n      name: this.name,\n      trimEnd: this._trimEnd,\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n   updateWithContext(transactionContext) {\n    super.updateWithContext(transactionContext);\n\n    this.name = (0,_sentry_utils_esm_buildPolyfills__WEBPACK_IMPORTED_MODULE_5__/* ._nullishCoalesce */ .h)(transactionContext.name, () => ( ''));\n\n    this._trimEnd = transactionContext.trimEnd;\n\n    return this;\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @experimental\n   */\n   getDynamicSamplingContext() {\n    if (this._frozenDynamicSamplingContext) {\n      return this._frozenDynamicSamplingContext;\n    }\n\n    var hub = this._hub || (0,_sentry_hub__WEBPACK_IMPORTED_MODULE_1__/* .getCurrentHub */ .Gd)();\n    var client = hub && hub.getClient();\n\n    if (!client) return {};\n\n    const { environment, release } = client.getOptions() || {};\n    const { publicKey: public_key } = client.getDsn() || {};\n\n    var maybeSampleRate = (this.metadata.transactionSampling || {}).rate;\n    var sample_rate = maybeSampleRate !== undefined ? maybeSampleRate.toString() : undefined;\n\n    var scope = hub.getScope();\n    const { segment: user_segment } = (scope && scope.getUser()) || {};\n\n    var source = this.metadata.source;\n\n    // We don't want to have a transaction name in the DSC if the source is \"url\" because URLs might contain PII\n    var transaction = source && source !== 'url' ? this.name : undefined;\n\n    var dsc = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_4__/* .dropUndefinedKeys */ .Jr)({\n      environment,\n      release,\n      transaction,\n      user_segment,\n      public_key,\n      trace_id: this.traceId,\n      sample_rate,\n    });\n\n    // Uncomment if we want to make DSC immutable\n    // this._frozenDynamicSamplingContext = dsc;\n\n    return dsc;\n  }\n}\n\n\n//# sourceMappingURL=transaction.js.map\n\n\n/***/ }),\n\n/***/ 3233:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XL\": function() { return /* binding */ msToSec; },\n/* harmony export */   \"x1\": function() { return /* binding */ getActiveTransaction; },\n/* harmony export */   \"zu\": function() { return /* binding */ hasTracingEnabled; }\n/* harmony export */ });\n/* unused harmony export secToMs */\n/* harmony import */ var _sentry_hub__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8641);\n\n\n\n/**\n * Determines if tracing is currently enabled.\n *\n * Tracing is enabled when at least one of `tracesSampleRate` and `tracesSampler` is defined in the SDK config.\n */\nfunction hasTracingEnabled(\n  maybeOptions,\n) {\n  var client = (0,_sentry_hub__WEBPACK_IMPORTED_MODULE_0__/* .getCurrentHub */ .Gd)().getClient();\n  var options = maybeOptions || (client && client.getOptions());\n  return !!options && ('tracesSampleRate' in options || 'tracesSampler' in options);\n}\n\n/** Grabs active transaction off scope, if any */\nfunction getActiveTransaction(maybeHub) {\n  var hub = maybeHub || (0,_sentry_hub__WEBPACK_IMPORTED_MODULE_0__/* .getCurrentHub */ .Gd)();\n  var scope = hub.getScope();\n  return scope && (scope.getTransaction() );\n}\n\n/**\n * Converts from milliseconds to seconds\n * @param time time in ms\n */\nfunction msToSec(time) {\n  return time / 1000;\n}\n\n/**\n * Converts from seconds to milliseconds\n * @param time time in seconds\n */\nfunction secToMs(time) {\n  return time * 1000;\n}\n\n\n//# sourceMappingURL=utils.js.map\n\n\n/***/ }),\n\n/***/ 8464:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Rt\": function() { return /* binding */ htmlTreeAsString; },\n/* harmony export */   \"l4\": function() { return /* binding */ getLocationHref; },\n/* harmony export */   \"qT\": function() { return /* binding */ getDomElement; }\n/* harmony export */ });\n/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2991);\n/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7597);\n\n\n\n/**\n * Given a child DOM element, returns a query-selector statement describing that\n * and its ancestors\n * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]\n * @returns generated DOM path\n */\nfunction htmlTreeAsString(elem, keyAttrs) {\n  \n\n  // try/catch both:\n  // - accessing event.target (see getsentry/raven-js#838, #768)\n  // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly\n  // - can throw an exception in some circumstances.\n  try {\n    let currentElem = elem ;\n    var MAX_TRAVERSE_HEIGHT = 5;\n    var MAX_OUTPUT_LEN = 80;\n    var out = [];\n    let height = 0;\n    let len = 0;\n    var separator = ' > ';\n    var sepLength = separator.length;\n    let nextStr;\n\n        while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {\n      nextStr = _htmlElementAsString(currentElem, keyAttrs);\n      // bail out if\n      // - nextStr is the 'html' element\n      // - the length of the string that would be created exceeds MAX_OUTPUT_LEN\n      //   (ignore this limit if we are on the first iteration)\n      if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)) {\n        break;\n      }\n\n      out.push(nextStr);\n\n      len += nextStr.length;\n      currentElem = currentElem.parentNode;\n    }\n\n    return out.reverse().join(separator);\n  } catch (_oO) {\n    return '<unknown>';\n  }\n}\n\n/**\n * Returns a simple, query-selector representation of a DOM element\n * e.g. [HTMLElement] => input#foo.btn[name=baz]\n * @returns generated DOM path\n */\nfunction _htmlElementAsString(el, keyAttrs) {\n  var elem = el \n\n;\n\n  var out = [];\n  let className;\n  let classes;\n  let key;\n  let attr;\n  let i;\n\n  if (!elem || !elem.tagName) {\n    return '';\n  }\n\n  out.push(elem.tagName.toLowerCase());\n\n  // Pairs of attribute keys defined in `serializeAttribute` and their values on element.\n  var keyAttrPairs =\n    keyAttrs && keyAttrs.length\n      ? keyAttrs.filter(keyAttr => elem.getAttribute(keyAttr)).map(keyAttr => [keyAttr, elem.getAttribute(keyAttr)])\n      : null;\n\n  if (keyAttrPairs && keyAttrPairs.length) {\n    keyAttrPairs.forEach(keyAttrPair => {\n      out.push(`[${keyAttrPair[0]}=\"${keyAttrPair[1]}\"]`);\n    });\n  } else {\n    if (elem.id) {\n      out.push(`#${elem.id}`);\n    }\n\n        className = elem.className;\n    if (className && (0,_is_js__WEBPACK_IMPORTED_MODULE_0__/* .isString */ .HD)(className)) {\n      classes = className.split(/\\s+/);\n      for (i = 0; i < classes.length; i++) {\n        out.push(`.${classes[i]}`);\n      }\n    }\n  }\n  var allowedAttrs = ['type', 'name', 'title', 'alt'];\n  for (i = 0; i < allowedAttrs.length; i++) {\n    key = allowedAttrs[i];\n    attr = elem.getAttribute(key);\n    if (attr) {\n      out.push(`[${key}=\"${attr}\"]`);\n    }\n  }\n  return out.join('');\n}\n\n/**\n * A safe form of location.href\n */\nfunction getLocationHref() {\n  var global = (0,_global_js__WEBPACK_IMPORTED_MODULE_1__/* .getGlobalObject */ .R)();\n  try {\n    return global.document.location.href;\n  } catch (oO) {\n    return '';\n  }\n}\n\n/**\n * Gets a DOM element by using document.querySelector.\n *\n * This wrapper will first check for the existance of the function before\n * actually calling it so that we don't have to take care of this check,\n * every time we want to access the DOM.\n *\n * Reason: DOM/querySelector is not available in all environments.\n *\n * We have to cast to any because utils can be consumed by a variety of environments,\n * and we don't want to break TS users. If you know what element will be selected by\n * `document.querySelector`, specify it as part of the generic call. For example,\n * `var element = getDomElement<Element>('selector');`\n *\n * @param selector the selector string passed on to document.querySelector\n */\nfunction getDomElement(selector) {\n  var global = (0,_global_js__WEBPACK_IMPORTED_MODULE_1__/* .getGlobalObject */ .R)();\n  if (global.document && global.document.querySelector) {\n    return global.document.querySelector(selector) ;\n  }\n  return null;\n}\n\n\n//# sourceMappingURL=browser.js.map\n\n\n/***/ }),\n\n/***/ 5375:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"h\": function() { return /* binding */ _nullishCoalesce; }\n/* harmony export */ });\n/**\n * Polyfill for the nullish coalescing operator (`??`).\n *\n * Note that the RHS is wrapped in a function so that if it's a computed value, that evaluation won't happen unless the\n * LHS evaluates to a nullish value, to mimic the operator's short-circuiting behavior.\n *\n * Adapted from Sucrase (https://github.com/alangpierce/sucrase)\n *\n * @param lhs The value of the expression to the left of the `??`\n * @param rhsFn A function returning the value of the expression to the right of the `??`\n * @returns The LHS value, unless it's `null` or `undefined`, in which case, the RHS value\n */\nfunction _nullishCoalesce(lhs, rhsFn) {\n  // by checking for loose equality to `null`, we catch both `null` and `undefined`\n  return lhs != null ? lhs : rhsFn();\n}\n\n// Sucrase version:\n// function _nullishCoalesce(lhs, rhsFn) {\n//   if (lhs != null) {\n//     return lhs;\n//   } else {\n//     return rhsFn();\n//   }\n// }\n\n\n//# sourceMappingURL=_nullishCoalesce.js.map\n\n\n/***/ }),\n\n/***/ 4307:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"x\": function() { return /* binding */ _optionalChain; }\n/* harmony export */ });\n/**\n * Polyfill for the optional chain operator, `?.`, given previous conversion of the expression into an array of values,\n * descriptors, and functions.\n *\n * Adapted from Sucrase (https://github.com/alangpierce/sucrase)\n * See https://github.com/alangpierce/sucrase/blob/265887868966917f3b924ce38dfad01fbab1329f/src/transformers/OptionalChainingNullishTransformer.ts#L15\n *\n * @param ops Array result of expression conversion\n * @returns The value of the expression\n */\nfunction _optionalChain(ops) {\n  let lastAccessLHS = undefined;\n  let value = ops[0];\n  let i = 1;\n  while (i < ops.length) {\n    var op = ops[i] ;\n    var fn = ops[i + 1] ;\n    i += 2;\n    // by checking for loose equality to `null`, we catch both `null` and `undefined`\n    if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n      // really we're meaning to return `undefined` as an actual value here, but it saves bytes not to write it\n      return;\n    }\n    if (op === 'access' || op === 'optionalAccess') {\n      lastAccessLHS = value;\n      value = fn(value);\n    } else if (op === 'call' || op === 'optionalCall') {\n      value = fn((...args) => (value ).call(lastAccessLHS, ...args));\n      lastAccessLHS = undefined;\n    }\n  }\n  return value;\n}\n\n// Sucrase version\n// function _optionalChain(ops) {\n//   let lastAccessLHS = undefined;\n//   let value = ops[0];\n//   let i = 1;\n//   while (i < ops.length) {\n//     var op = ops[i];\n//     var fn = ops[i + 1];\n//     i += 2;\n//     if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n//       return undefined;\n//     }\n//     if (op === 'access' || op === 'optionalAccess') {\n//       lastAccessLHS = value;\n//       value = fn(value);\n//     } else if (op === 'call' || op === 'optionalCall') {\n//       value = fn((...args) => value.call(lastAccessLHS, ...args));\n//       lastAccessLHS = undefined;\n//     }\n//   }\n//   return value;\n// }\n\n\n//# sourceMappingURL=_optionalChain.js.map\n\n\n/***/ }),\n\n/***/ 2991:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"R\": function() { return /* binding */ getGlobalObject; },\n/* harmony export */   \"Y\": function() { return /* binding */ getGlobalSingleton; }\n/* harmony export */ });\n/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2448);\n\n\n/** Internal */\n\nvar fallbackGlobalObject = {};\n\n/**\n * Safely get global scope object\n *\n * @returns Global scope object\n */\nfunction getGlobalObject() {\n  return (\n    (0,_node_js__WEBPACK_IMPORTED_MODULE_0__/* .isNodeEnv */ .KV)()\n      ? __webpack_require__.g\n      : typeof window !== 'undefined'       ? window       : typeof self !== 'undefined'\n      ? self\n      : fallbackGlobalObject\n  ) ;\n}\n\n/**\n * Returns a global singleton contained in the global `__SENTRY__` object.\n *\n * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory\n * function and added to the `__SENTRY__` object.\n *\n * @param name name of the global singleton on __SENTRY__\n * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`\n * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `getGlobalObject`'s return value\n * @returns the singleton\n */\nfunction getGlobalSingleton(name, creator, obj) {\n  var global = (obj || getGlobalObject()) ;\n  var __SENTRY__ = (global.__SENTRY__ = global.__SENTRY__ || {});\n  var singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());\n  return singleton;\n}\n\n\n//# sourceMappingURL=global.js.map\n\n\n/***/ }),\n\n/***/ 9732:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"o\": function() { return /* binding */ addInstrumentationHandler; }\n/* harmony export */ });\n/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2991);\n/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7597);\n/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2343);\n/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(535);\n/* harmony import */ var _stacktrace_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(360);\n/* harmony import */ var _supports_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8823);\n\n\n\n\n\n\n\nvar global = (0,_global_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalObject */ .R)();\n\n/**\n * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.\n *  - Console API\n *  - Fetch API\n *  - XHR API\n *  - History API\n *  - DOM API (click/typing)\n *  - Error API\n *  - UnhandledRejection API\n */\n\nvar handlers = {};\nvar instrumented = {};\n\n/** Instruments given API */\nfunction instrument(type) {\n  if (instrumented[type]) {\n    return;\n  }\n\n  instrumented[type] = true;\n\n  switch (type) {\n    case 'console':\n      instrumentConsole();\n      break;\n    case 'dom':\n      instrumentDOM();\n      break;\n    case 'xhr':\n      instrumentXHR();\n      break;\n    case 'fetch':\n      instrumentFetch();\n      break;\n    case 'history':\n      instrumentHistory();\n      break;\n    case 'error':\n      instrumentError();\n      break;\n    case 'unhandledrejection':\n      instrumentUnhandledRejection();\n      break;\n    default:\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .logger.warn */ .kg.warn('unknown instrumentation type:', type);\n      return;\n  }\n}\n\n/**\n * Add handler that will be called when given type of instrumentation triggers.\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addInstrumentationHandler(type, callback) {\n  handlers[type] = handlers[type] || [];\n  (handlers[type] ).push(callback);\n  instrument(type);\n}\n\n/** JSDoc */\nfunction triggerHandlers(type, data) {\n  if (!type || !handlers[type]) {\n    return;\n  }\n\n  for (var handler of handlers[type] || []) {\n    try {\n      handler(data);\n    } catch (e) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .logger.error */ .kg.error(\n          `Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${(0,_stacktrace_js__WEBPACK_IMPORTED_MODULE_2__/* .getFunctionName */ .$P)(handler)}\\nError:`,\n          e,\n        );\n    }\n  }\n}\n\n/** JSDoc */\nfunction instrumentConsole() {\n  if (!('console' in global)) {\n    return;\n  }\n\n  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .CONSOLE_LEVELS.forEach */ .RU.forEach(function (level) {\n    if (!(level in global.console)) {\n      return;\n    }\n\n    (0,_object_js__WEBPACK_IMPORTED_MODULE_3__/* .fill */ .hl)(global.console, level, function (originalConsoleMethod) {\n      return function (...args) {\n        triggerHandlers('console', { args, level });\n\n        // this fails for some browsers. :(\n        if (originalConsoleMethod) {\n          originalConsoleMethod.apply(global.console, args);\n        }\n      };\n    });\n  });\n}\n\n/** JSDoc */\nfunction instrumentFetch() {\n  if (!(0,_supports_js__WEBPACK_IMPORTED_MODULE_4__/* .supportsNativeFetch */ .t$)()) {\n    return;\n  }\n\n  (0,_object_js__WEBPACK_IMPORTED_MODULE_3__/* .fill */ .hl)(global, 'fetch', function (originalFetch) {\n    return function (...args) {\n      var handlerData = {\n        args,\n        fetchData: {\n          method: getFetchMethod(args),\n          url: getFetchUrl(args),\n        },\n        startTimestamp: Date.now(),\n      };\n\n      triggerHandlers('fetch', {\n        ...handlerData,\n      });\n\n            return originalFetch.apply(global, args).then(\n        (response) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            response,\n          });\n          return response;\n        },\n        (error) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            error,\n          });\n          // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n          //       it means the sentry.javascript SDK caught an error invoking your application code.\n          //       This is expected behavior and NOT indicative of a bug with sentry.javascript.\n          throw error;\n        },\n      );\n    };\n  });\n}\n\n/** Extract `method` from fetch call arguments */\nfunction getFetchMethod(fetchArgs = []) {\n  if ('Request' in global && (0,_is_js__WEBPACK_IMPORTED_MODULE_5__/* .isInstanceOf */ .V9)(fetchArgs[0], Request) && fetchArgs[0].method) {\n    return String(fetchArgs[0].method).toUpperCase();\n  }\n  if (fetchArgs[1] && fetchArgs[1].method) {\n    return String(fetchArgs[1].method).toUpperCase();\n  }\n  return 'GET';\n}\n\n/** Extract `url` from fetch call arguments */\nfunction getFetchUrl(fetchArgs = []) {\n  if (typeof fetchArgs[0] === 'string') {\n    return fetchArgs[0];\n  }\n  if ('Request' in global && (0,_is_js__WEBPACK_IMPORTED_MODULE_5__/* .isInstanceOf */ .V9)(fetchArgs[0], Request)) {\n    return fetchArgs[0].url;\n  }\n  return String(fetchArgs[0]);\n}\n\n/** JSDoc */\nfunction instrumentXHR() {\n  if (!('XMLHttpRequest' in global)) {\n    return;\n  }\n\n  var xhrproto = XMLHttpRequest.prototype;\n\n  (0,_object_js__WEBPACK_IMPORTED_MODULE_3__/* .fill */ .hl)(xhrproto, 'open', function (originalOpen) {\n    return function ( ...args) {\n            var xhr = this;\n      var url = args[1];\n      var xhrInfo = (xhr.__sentry_xhr__ = {\n                method: (0,_is_js__WEBPACK_IMPORTED_MODULE_5__/* .isString */ .HD)(args[0]) ? args[0].toUpperCase() : args[0],\n        url: args[1],\n      });\n\n      // if Sentry key appears in URL, don't capture it as a request\n            if ((0,_is_js__WEBPACK_IMPORTED_MODULE_5__/* .isString */ .HD)(url) && xhrInfo.method === 'POST' && url.match(/sentry_key/)) {\n        xhr.__sentry_own_request__ = true;\n      }\n\n      var onreadystatechangeHandler = function () {\n        if (xhr.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            xhrInfo.status_code = xhr.status;\n          } catch (e) {\n            /* do nothing */\n          }\n\n          triggerHandlers('xhr', {\n            args,\n            endTimestamp: Date.now(),\n            startTimestamp: Date.now(),\n            xhr,\n          });\n        }\n      };\n\n      if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {\n        (0,_object_js__WEBPACK_IMPORTED_MODULE_3__/* .fill */ .hl)(xhr, 'onreadystatechange', function (original) {\n          return function (...readyStateArgs) {\n            onreadystatechangeHandler();\n            return original.apply(xhr, readyStateArgs);\n          };\n        });\n      } else {\n        xhr.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      return originalOpen.apply(xhr, args);\n    };\n  });\n\n  (0,_object_js__WEBPACK_IMPORTED_MODULE_3__/* .fill */ .hl)(xhrproto, 'send', function (originalSend) {\n    return function ( ...args) {\n      if (this.__sentry_xhr__ && args[0] !== undefined) {\n        this.__sentry_xhr__.body = args[0];\n      }\n\n      triggerHandlers('xhr', {\n        args,\n        startTimestamp: Date.now(),\n        xhr: this,\n      });\n\n      return originalSend.apply(this, args);\n    };\n  });\n}\n\nlet lastHref;\n\n/** JSDoc */\nfunction instrumentHistory() {\n  if (!(0,_supports_js__WEBPACK_IMPORTED_MODULE_4__/* .supportsHistory */ .Bf)()) {\n    return;\n  }\n\n  var oldOnPopState = global.onpopstate;\n  global.onpopstate = function ( ...args) {\n    var to = global.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    var from = lastHref;\n    lastHref = to;\n    triggerHandlers('history', {\n      from,\n      to,\n    });\n    if (oldOnPopState) {\n      // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.\n      // https://github.com/getsentry/sentry-javascript/issues/3344\n      // https://github.com/bugsnag/bugsnag-js/issues/469\n      try {\n        return oldOnPopState.apply(this, args);\n      } catch (_oO) {\n        // no-empty\n      }\n    }\n  };\n\n  /** @hidden */\n  function historyReplacementFunction(originalHistoryFunction) {\n    return function ( ...args) {\n      var url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        var from = lastHref;\n        var to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        triggerHandlers('history', {\n          from,\n          to,\n        });\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n\n  (0,_object_js__WEBPACK_IMPORTED_MODULE_3__/* .fill */ .hl)(global.history, 'pushState', historyReplacementFunction);\n  (0,_object_js__WEBPACK_IMPORTED_MODULE_3__/* .fill */ .hl)(global.history, 'replaceState', historyReplacementFunction);\n}\n\nvar debounceDuration = 1000;\nlet debounceTimerID;\nlet lastCapturedEvent;\n\n/**\n * Decide whether the current event should finish the debounce of previously captured one.\n * @param previous previously captured event\n * @param current event to be captured\n */\nfunction shouldShortcircuitPreviousDebounce(previous, current) {\n  // If there was no previous event, it should always be swapped for the new one.\n  if (!previous) {\n    return true;\n  }\n\n  // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.\n  if (previous.type !== current.type) {\n    return true;\n  }\n\n  try {\n    // If both events have the same type, it's still possible that actions were performed on different targets.\n    // e.g. 2 clicks on different buttons.\n    if (previous.target !== current.target) {\n      return true;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_\n  // to which an event listener was attached), we treat them as the same action, as we want to capture\n  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.\n  return false;\n}\n\n/**\n * Decide whether an event should be captured.\n * @param event event to be captured\n */\nfunction shouldSkipDOMEvent(event) {\n  // We are only interested in filtering `keypress` events for now.\n  if (event.type !== 'keypress') {\n    return false;\n  }\n\n  try {\n    var target = event.target ;\n\n    if (!target || !target.tagName) {\n      return true;\n    }\n\n    // Only consider keypress events on actual input elements. This will disregard keypresses targeting body\n    // e.g.tabbing through elements, hotkeys, etc.\n    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n      return false;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  return true;\n}\n\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n * @param handler function that will be triggered\n * @param globalListener indicates whether event was captured by the global event listener\n * @returns wrapped breadcrumb events handler\n * @hidden\n */\nfunction makeDOMEventHandler(handler, globalListener = false) {\n  return (event) => {\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors).\n    // Ignore if we've already captured that event.\n    if (!event || lastCapturedEvent === event) {\n      return;\n    }\n\n    // We always want to skip _some_ events.\n    if (shouldSkipDOMEvent(event)) {\n      return;\n    }\n\n    var name = event.type === 'keypress' ? 'input' : event.type;\n\n    // If there is no debounce timer, it means that we can safely capture the new event and store it for future comparisons.\n    if (debounceTimerID === undefined) {\n      handler({\n        event: event,\n        name,\n        global: globalListener,\n      });\n      lastCapturedEvent = event;\n    }\n    // If there is a debounce awaiting, see if the new event is different enough to treat it as a unique one.\n    // If that's the case, emit the previous event and store locally the newly-captured DOM event.\n    else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {\n      handler({\n        event: event,\n        name,\n        global: globalListener,\n      });\n      lastCapturedEvent = event;\n    }\n\n    // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.\n    clearTimeout(debounceTimerID);\n    debounceTimerID = global.setTimeout(() => {\n      debounceTimerID = undefined;\n    }, debounceDuration);\n  };\n}\n\n/** JSDoc */\nfunction instrumentDOM() {\n  if (!('document' in global)) {\n    return;\n  }\n\n  // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom\n  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before\n  // we instrument `addEventListener` so that we don't end up attaching this handler twice.\n  var triggerDOMHandler = triggerHandlers.bind(null, 'dom');\n  var globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);\n  global.document.addEventListener('click', globalDOMEventHandler, false);\n  global.document.addEventListener('keypress', globalDOMEventHandler, false);\n\n  // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled\n  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That\n  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler\n  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still\n  // guaranteed to fire at least once.)\n  ['EventTarget', 'Node'].forEach((target) => {\n        var proto = (global )[target] && (global )[target].prototype;\n        if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n\n    (0,_object_js__WEBPACK_IMPORTED_MODULE_3__/* .fill */ .hl)(proto, 'addEventListener', function (originalAddEventListener) {\n      return function (\n        \n        type,\n        listener,\n        options,\n      ) {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            var el = this ;\n            var handlers = (el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {});\n            var handlerForType = (handlers[type] = handlers[type] || { refCount: 0 });\n\n            if (!handlerForType.handler) {\n              var handler = makeDOMEventHandler(triggerDOMHandler);\n              handlerForType.handler = handler;\n              originalAddEventListener.call(this, type, handler, options);\n            }\n\n            handlerForType.refCount += 1;\n          } catch (e) {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n          }\n        }\n\n        return originalAddEventListener.call(this, type, listener, options);\n      };\n    });\n\n    (0,_object_js__WEBPACK_IMPORTED_MODULE_3__/* .fill */ .hl)(\n      proto,\n      'removeEventListener',\n      function (originalRemoveEventListener) {\n        return function (\n          \n          type,\n          listener,\n          options,\n        ) {\n          if (type === 'click' || type == 'keypress') {\n            try {\n              var el = this ;\n              var handlers = el.__sentry_instrumentation_handlers__ || {};\n              var handlerForType = handlers[type];\n\n              if (handlerForType) {\n                handlerForType.refCount -= 1;\n                // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.\n                if (handlerForType.refCount <= 0) {\n                  originalRemoveEventListener.call(this, type, handlerForType.handler, options);\n                  handlerForType.handler = undefined;\n                  delete handlers[type];                 }\n\n                // If there are no longer any custom handlers of any type on this element, cleanup everything.\n                if (Object.keys(handlers).length === 0) {\n                  delete el.__sentry_instrumentation_handlers__;\n                }\n              }\n            } catch (e) {\n              // Accessing dom properties is always fragile.\n              // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n            }\n          }\n\n          return originalRemoveEventListener.call(this, type, listener, options);\n        };\n      },\n    );\n  });\n}\n\nlet _oldOnErrorHandler = null;\n/** JSDoc */\nfunction instrumentError() {\n  _oldOnErrorHandler = global.onerror;\n\n  global.onerror = function (msg, url, line, column, error) {\n    triggerHandlers('error', {\n      column,\n      error,\n      line,\n      msg,\n      url,\n    });\n\n    if (_oldOnErrorHandler) {\n            return _oldOnErrorHandler.apply(this, arguments);\n    }\n\n    return false;\n  };\n}\n\nlet _oldOnUnhandledRejectionHandler = null;\n/** JSDoc */\nfunction instrumentUnhandledRejection() {\n  _oldOnUnhandledRejectionHandler = global.onunhandledrejection;\n\n  global.onunhandledrejection = function (e) {\n    triggerHandlers('unhandledrejection', e);\n\n    if (_oldOnUnhandledRejectionHandler) {\n            return _oldOnUnhandledRejectionHandler.apply(this, arguments);\n    }\n\n    return true;\n  };\n}\n\n\n//# sourceMappingURL=instrument.js.map\n\n\n/***/ }),\n\n/***/ 7597:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Cy\": function() { return /* binding */ isSyntheticEvent; },\n/* harmony export */   \"HD\": function() { return /* binding */ isString; },\n/* harmony export */   \"J8\": function() { return /* binding */ isThenable; },\n/* harmony export */   \"Kj\": function() { return /* binding */ isRegExp; },\n/* harmony export */   \"PO\": function() { return /* binding */ isPlainObject; },\n/* harmony export */   \"TX\": function() { return /* binding */ isDOMError; },\n/* harmony export */   \"V9\": function() { return /* binding */ isInstanceOf; },\n/* harmony export */   \"VW\": function() { return /* binding */ isErrorEvent; },\n/* harmony export */   \"VZ\": function() { return /* binding */ isError; },\n/* harmony export */   \"cO\": function() { return /* binding */ isEvent; },\n/* harmony export */   \"fm\": function() { return /* binding */ isDOMException; },\n/* harmony export */   \"i2\": function() { return /* binding */ isNaN; },\n/* harmony export */   \"kK\": function() { return /* binding */ isElement; },\n/* harmony export */   \"pt\": function() { return /* binding */ isPrimitive; }\n/* harmony export */ });\nvar objectToString = Object.prototype.toString;\n\n/**\n * Checks whether given value's type is one of a few Error or Error-like\n * {@link isError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isError(wat) {\n  switch (objectToString.call(wat)) {\n    case '[object Error]':\n    case '[object Exception]':\n    case '[object DOMException]':\n      return true;\n    default:\n      return isInstanceOf(wat, Error);\n  }\n}\n/**\n * Checks whether given value is an instance of the given built-in class.\n *\n * @param wat The value to be checked\n * @param className\n * @returns A boolean representing the result.\n */\nfunction isBuiltin(wat, className) {\n  return objectToString.call(wat) === `[object ${className}]`;\n}\n\n/**\n * Checks whether given value's type is ErrorEvent\n * {@link isErrorEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isErrorEvent(wat) {\n  return isBuiltin(wat, 'ErrorEvent');\n}\n\n/**\n * Checks whether given value's type is DOMError\n * {@link isDOMError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isDOMError(wat) {\n  return isBuiltin(wat, 'DOMError');\n}\n\n/**\n * Checks whether given value's type is DOMException\n * {@link isDOMException}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isDOMException(wat) {\n  return isBuiltin(wat, 'DOMException');\n}\n\n/**\n * Checks whether given value's type is a string\n * {@link isString}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isString(wat) {\n  return isBuiltin(wat, 'String');\n}\n\n/**\n * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)\n * {@link isPrimitive}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isPrimitive(wat) {\n  return wat === null || (typeof wat !== 'object' && typeof wat !== 'function');\n}\n\n/**\n * Checks whether given value's type is an object literal\n * {@link isPlainObject}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isPlainObject(wat) {\n  return isBuiltin(wat, 'Object');\n}\n\n/**\n * Checks whether given value's type is an Event instance\n * {@link isEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isEvent(wat) {\n  return typeof Event !== 'undefined' && isInstanceOf(wat, Event);\n}\n\n/**\n * Checks whether given value's type is an Element instance\n * {@link isElement}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isElement(wat) {\n  return typeof Element !== 'undefined' && isInstanceOf(wat, Element);\n}\n\n/**\n * Checks whether given value's type is an regexp\n * {@link isRegExp}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isRegExp(wat) {\n  return isBuiltin(wat, 'RegExp');\n}\n\n/**\n * Checks whether given value has a then function.\n * @param wat A value to be checked.\n */\nfunction isThenable(wat) {\n    return Boolean(wat && wat.then && typeof wat.then === 'function');\n}\n\n/**\n * Checks whether given value's type is a SyntheticEvent\n * {@link isSyntheticEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isSyntheticEvent(wat) {\n  return isPlainObject(wat) && 'nativeEvent' in wat && 'preventDefault' in wat && 'stopPropagation' in wat;\n}\n\n/**\n * Checks whether given value is NaN\n * {@link isNaN}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isNaN(wat) {\n  return typeof wat === 'number' && wat !== wat;\n}\n\n/**\n * Checks whether given value's type is an instance of provided constructor.\n * {@link isInstanceOf}.\n *\n * @param wat A value to be checked.\n * @param base A constructor to be used in a check.\n * @returns A boolean representing the result.\n */\nfunction isInstanceOf(wat, base) {\n  try {\n    return wat instanceof base;\n  } catch (_e) {\n    return false;\n  }\n}\n\n\n//# sourceMappingURL=is.js.map\n\n\n/***/ }),\n\n/***/ 2343:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Cf\": function() { return /* binding */ consoleSandbox; },\n/* harmony export */   \"RU\": function() { return /* binding */ CONSOLE_LEVELS; },\n/* harmony export */   \"kg\": function() { return /* binding */ logger; }\n/* harmony export */ });\n/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2991);\n\n\n// TODO: Implement different loggers for different environments\nvar global = (0,_global_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalObject */ .R)();\n\n/** Prefix for logging strings */\nvar PREFIX = 'Sentry Logger ';\n\nvar CONSOLE_LEVELS = ['debug', 'info', 'warn', 'error', 'log', 'assert', 'trace'] ;\n\n/**\n * Temporarily disable sentry console instrumentations.\n *\n * @param callback The function to run against the original `console` messages\n * @returns The results of the callback\n */\nfunction consoleSandbox(callback) {\n  var global = (0,_global_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalObject */ .R)();\n\n  if (!('console' in global)) {\n    return callback();\n  }\n\n  var originalConsole = global.console ;\n  var wrappedLevels = {};\n\n  // Restore all wrapped console methods\n  CONSOLE_LEVELS.forEach(level => {\n    // TODO(v7): Remove this check as it's only needed for Node 6\n    var originalWrappedFunc =\n      originalConsole[level] && (originalConsole[level] ).__sentry_original__;\n    if (level in global.console && originalWrappedFunc) {\n      wrappedLevels[level] = originalConsole[level] ;\n      originalConsole[level] = originalWrappedFunc ;\n    }\n  });\n\n  try {\n    return callback();\n  } finally {\n    // Revert restoration to wrapped state\n    Object.keys(wrappedLevels).forEach(level => {\n      originalConsole[level] = wrappedLevels[level ];\n    });\n  }\n}\n\nfunction makeLogger() {\n  let enabled = false;\n  var logger = {\n    enable: () => {\n      enabled = true;\n    },\n    disable: () => {\n      enabled = false;\n    },\n  };\n\n  if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {\n    CONSOLE_LEVELS.forEach(name => {\n            logger[name] = (...args) => {\n        if (enabled) {\n          consoleSandbox(() => {\n            global.console[name](`${PREFIX}[${name}]:`, ...args);\n          });\n        }\n      };\n    });\n  } else {\n    CONSOLE_LEVELS.forEach(name => {\n      logger[name] = () => undefined;\n    });\n  }\n\n  return logger ;\n}\n\n// Ensure we only have a single logger instance, even if multiple versions of @sentry/utils are being used\nlet logger;\nif ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {\n  logger = (0,_global_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalSingleton */ .Y)('logger', makeLogger);\n} else {\n  logger = makeLogger();\n}\n\n\n//# sourceMappingURL=logger.js.map\n\n\n/***/ }),\n\n/***/ 2844:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DM\": function() { return /* binding */ uuid4; },\n/* harmony export */   \"Db\": function() { return /* binding */ addExceptionTypeValue; },\n/* harmony export */   \"EG\": function() { return /* binding */ addExceptionMechanism; },\n/* harmony export */   \"YO\": function() { return /* binding */ checkOrSetAlreadyCaught; },\n/* harmony export */   \"jH\": function() { return /* binding */ getEventDescription; },\n/* harmony export */   \"lE\": function() { return /* binding */ arrayify; }\n/* harmony export */ });\n/* unused harmony exports addContextToFrame, parseSemver */\n/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2991);\n/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(535);\n\n\n\n\n/**\n * Extended Window interface that allows for Crypto API usage in IE browsers\n */\n\n/**\n * UUID4 generator\n *\n * @returns string Generated UUID4.\n */\nfunction uuid4() {\n  var global = (0,_global_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalObject */ .R)() ;\n  var crypto = (global.crypto || global.msCrypto) ;\n\n  if (crypto && crypto.randomUUID) {\n    return crypto.randomUUID().replace(/-/g, '');\n  }\n\n  var getRandomByte =\n    crypto && crypto.getRandomValues ? () => crypto.getRandomValues(new Uint8Array(1))[0] : () => Math.random() * 16;\n\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n  // Concatenating the following numbers as strings results in '10000000100040008000100000000000'\n  return (([1e7] ) + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, c =>\n        ((c ) ^ ((getRandomByte() & 15) >> ((c ) / 4))).toString(16),\n  );\n}\n\nfunction getFirstException(event) {\n  return event.exception && event.exception.values ? event.exception.values[0] : undefined;\n}\n\n/**\n * Extracts either message or type+value from an event that can be used for user-facing logs\n * @returns event's description\n */\nfunction getEventDescription(event) {\n  const { message, event_id: eventId } = event;\n  if (message) {\n    return message;\n  }\n\n  var firstException = getFirstException(event);\n  if (firstException) {\n    if (firstException.type && firstException.value) {\n      return `${firstException.type}: ${firstException.value}`;\n    }\n    return firstException.type || firstException.value || eventId || '<unknown>';\n  }\n  return eventId || '<unknown>';\n}\n\n/**\n * Adds exception values, type and value to an synthetic Exception.\n * @param event The event to modify.\n * @param value Value of the exception.\n * @param type Type of the exception.\n * @hidden\n */\nfunction addExceptionTypeValue(event, value, type) {\n  var exception = (event.exception = event.exception || {});\n  var values = (exception.values = exception.values || []);\n  var firstException = (values[0] = values[0] || {});\n  if (!firstException.value) {\n    firstException.value = value || '';\n  }\n  if (!firstException.type) {\n    firstException.type = type || 'Error';\n  }\n}\n\n/**\n * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.\n *\n * @param event The event to modify.\n * @param newMechanism Mechanism data to add to the event.\n * @hidden\n */\nfunction addExceptionMechanism(event, newMechanism) {\n  var firstException = getFirstException(event);\n  if (!firstException) {\n    return;\n  }\n\n  var defaultMechanism = { type: 'generic', handled: true };\n  var currentMechanism = firstException.mechanism;\n  firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };\n\n  if (newMechanism && 'data' in newMechanism) {\n    var mergedData = { ...(currentMechanism && currentMechanism.data), ...newMechanism.data };\n    firstException.mechanism.data = mergedData;\n  }\n}\n\n// https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\nvar SEMVER_REGEXP =\n  /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$/;\n\n/**\n * Represents Semantic Versioning object\n */\n\n/**\n * Parses input into a SemVer interface\n * @param input string representation of a semver version\n */\nfunction parseSemver(input) {\n  var match = input.match(SEMVER_REGEXP) || [];\n  var major = parseInt(match[1], 10);\n  var minor = parseInt(match[2], 10);\n  var patch = parseInt(match[3], 10);\n  return {\n    buildmetadata: match[5],\n    major: isNaN(major) ? undefined : major,\n    minor: isNaN(minor) ? undefined : minor,\n    patch: isNaN(patch) ? undefined : patch,\n    prerelease: match[4],\n  };\n}\n\n/**\n * This function adds context (pre/post/line) lines to the provided frame\n *\n * @param lines string[] containing all lines\n * @param frame StackFrame that will be mutated\n * @param linesOfContext number of context lines we want to add pre/post\n */\nfunction addContextToFrame(lines, frame, linesOfContext = 5) {\n  var lineno = frame.lineno || 0;\n  var maxLines = lines.length;\n  var sourceLine = Math.max(Math.min(maxLines, lineno - 1), 0);\n\n  frame.pre_context = lines\n    .slice(Math.max(0, sourceLine - linesOfContext), sourceLine)\n    .map((line) => snipLine(line, 0));\n\n  frame.context_line = snipLine(lines[Math.min(maxLines - 1, sourceLine)], frame.colno || 0);\n\n  frame.post_context = lines\n    .slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext)\n    .map((line) => snipLine(line, 0));\n}\n\n/**\n * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object\n * in question), and marks it captured if not.\n *\n * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and\n * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so\n * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because\n * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not\n * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This\n * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we\n * see it.\n *\n * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on\n * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent\n * object wrapper forms so that this check will always work. However, because we need to flag the exact object which\n * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification\n * must be done before the exception captured.\n *\n * @param A thrown exception to check or flag as having been seen\n * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)\n */\nfunction checkOrSetAlreadyCaught(exception) {\n    if (exception && (exception ).__sentry_captured__) {\n    return true;\n  }\n\n  try {\n    // set it this way rather than by assignment so that it's not ennumerable and therefore isn't recorded by the\n    // `ExtraErrorData` integration\n    (0,_object_js__WEBPACK_IMPORTED_MODULE_1__/* .addNonEnumerableProperty */ .xp)(exception , '__sentry_captured__', true);\n  } catch (err) {\n    // `exception` is a primitive, so we can't mark it seen\n  }\n\n  return false;\n}\n\n/**\n * Checks whether the given input is already an array, and if it isn't, wraps it in one.\n *\n * @param maybeArray Input to turn into an array, if necessary\n * @returns The input, if already an array, or an array with the input as the only element, if not\n */\nfunction arrayify(maybeArray) {\n  return Array.isArray(maybeArray) ? maybeArray : [maybeArray];\n}\n\n\n//# sourceMappingURL=misc.js.map\n\n\n/***/ }),\n\n/***/ 2448:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"l$\": function() { return /* binding */ dynamicRequire; },\n  \"KV\": function() { return /* binding */ isNodeEnv; },\n  \"$y\": function() { return /* binding */ loadModule; }\n});\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/utils/esm/env.js\n/*\n * This module exists for optimizations in the build process through rollup and terser.  We define some global\n * constants, which can be overridden during build. By guarding certain pieces of code with functions that return these\n * constants, we can control whether or not they appear in the final bundle. (Any code guarded by a false condition will\n * never run, and will hence be dropped during treeshaking.) The two primary uses for this are stripping out calls to\n * `logger` and preventing node-related code from appearing in browser bundles.\n *\n * Attention:\n * This file should not be used to define constants/flags that are intended to be used for tree-shaking conducted by\n * users. These fags should live in their respective packages, as we identified user tooling (specifically webpack)\n * having issues tree-shaking these constants across package boundaries.\n * An example for this is the __SENTRY_DEBUG__ constant. It is declared in each package individually because we want\n * users to be able to shake away expressions that it guards.\n */\n\n/**\n * Figures out if we're building a browser bundle.\n *\n * @returns true if this is a browser bundle build.\n */\nfunction isBrowserBundle() {\n  return typeof __SENTRY_BROWSER_BUNDLE__ !== 'undefined' && !!__SENTRY_BROWSER_BUNDLE__;\n}\n\n\n//# sourceMappingURL=env.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/utils/esm/node.js\n/* module decorator */ module = __webpack_require__.hmd(module);\n/* provided dependency */ var process = __webpack_require__(3454);\n\n\n/**\n * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,\n * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.\n */\n\n/**\n * Checks whether we're in the Node.js or Browser environment\n *\n * @returns Answer to given question\n */\nfunction isNodeEnv() {\n  // explicitly check for browser bundles as those can be optimized statically\n  // by terser/rollup.\n  return (\n    !isBrowserBundle() &&\n    Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]'\n  );\n}\n\n/**\n * Requires a module which is protected against bundler minification.\n *\n * @param request The module path to resolve\n */\nfunction dynamicRequire(mod, request) {\n    return mod.require(request);\n}\n\n/**\n * Helper for dynamically loading module that should work with linked dependencies.\n * The problem is that we _should_ be using `require(require.resolve(moduleName, { paths: [cwd()] }))`\n * However it's _not possible_ to do that with Webpack, as it has to know all the dependencies during\n * build time. `require.resolve` is also not available in any other way, so we cannot create,\n * a fake helper like we do with `dynamicRequire`.\n *\n * We always prefer to use local package, thus the value is not returned early from each `try/catch` block.\n * That is to mimic the behavior of `require.resolve` exactly.\n *\n * @param moduleName module name to require\n * @returns possibly required module\n */\nfunction loadModule(moduleName) {\n  let mod;\n\n  try {\n    mod = dynamicRequire(module, moduleName);\n  } catch (e) {\n    // no-empty\n  }\n\n  try {\n    const { cwd } = dynamicRequire(module, 'process');\n    mod = dynamicRequire(module, `${cwd()}/node_modules/${moduleName}`) ;\n  } catch (e) {\n    // no-empty\n  }\n\n  return mod;\n}\n\n\n//# sourceMappingURL=node.js.map\n\n\n/***/ }),\n\n/***/ 4754:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Fv\": function() { return /* binding */ normalize; },\n  \"Qy\": function() { return /* binding */ normalizeToSize; }\n});\n\n// UNUSED EXPORTS: walk\n\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/is.js\nvar is = __webpack_require__(7597);\n;// CONCATENATED MODULE: ./node_modules/@sentry/utils/esm/memo.js\n/**\n * Helper to decycle json objects\n */\nfunction memoBuilder() {\n  var hasWeakSet = typeof WeakSet === 'function';\n  var inner = hasWeakSet ? new WeakSet() : [];\n  function memoize(obj) {\n    if (hasWeakSet) {\n      if (inner.has(obj)) {\n        return true;\n      }\n      inner.add(obj);\n      return false;\n    }\n        for (let i = 0; i < inner.length; i++) {\n      var value = inner[i];\n      if (value === obj) {\n        return true;\n      }\n    }\n    inner.push(obj);\n    return false;\n  }\n\n  function unmemoize(obj) {\n    if (hasWeakSet) {\n      inner.delete(obj);\n    } else {\n      for (let i = 0; i < inner.length; i++) {\n        if (inner[i] === obj) {\n          inner.splice(i, 1);\n          break;\n        }\n      }\n    }\n  }\n  return [memoize, unmemoize];\n}\n\n\n//# sourceMappingURL=memo.js.map\n\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/object.js\nvar object = __webpack_require__(535);\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/stacktrace.js\nvar stacktrace = __webpack_require__(360);\n;// CONCATENATED MODULE: ./node_modules/@sentry/utils/esm/normalize.js\n\n\n\n\n\n/**\n * Recursively normalizes the given object.\n *\n * - Creates a copy to prevent original input mutation\n * - Skips non-enumerable properties\n * - When stringifying, calls `toJSON` if implemented\n * - Removes circular references\n * - Translates non-serializable values (`undefined`/`NaN`/functions) to serializable format\n * - Translates known global objects/classes to a string representations\n * - Takes care of `Error` object serialization\n * - Optionally limits depth of final output\n * - Optionally limits number of properties/elements included in any single object/array\n *\n * @param input The object to be normalized.\n * @param depth The max depth to which to normalize the object. (Anything deeper stringified whole.)\n * @param maxProperties The max number of elements or properties to be included in any single array or\n * object in the normallized output.\n * @returns A normalized version of the object, or `\"**non-serializable**\"` if any errors are thrown during normalization.\n */\nfunction normalize(input, depth = +Infinity, maxProperties = +Infinity) {\n  try {\n    // since we're at the outermost level, we don't provide a key\n    return visit('', input, depth, maxProperties);\n  } catch (err) {\n    return { ERROR: `**non-serializable** (${err})` };\n  }\n}\n\n/** JSDoc */\nfunction normalizeToSize(\n    object,\n  // Default Node.js REPL depth\n  depth = 3,\n  // 100kB, as 200kB is max payload size, so half sounds reasonable\n  maxSize = 100 * 1024,\n) {\n  var normalized = normalize(object, depth);\n\n  if (jsonSize(normalized) > maxSize) {\n    return normalizeToSize(object, depth - 1, maxSize);\n  }\n\n  return normalized ;\n}\n\n/**\n * Visits a node to perform normalization on it\n *\n * @param key The key corresponding to the given node\n * @param value The node to be visited\n * @param depth Optional number indicating the maximum recursion depth\n * @param maxProperties Optional maximum number of properties/elements included in any single object/array\n * @param memo Optional Memo class handling decycling\n */\nfunction visit(\n  key,\n  value,\n  depth = +Infinity,\n  maxProperties = +Infinity,\n  memo = memoBuilder(),\n) {\n  const [memoize, unmemoize] = memo;\n\n  // Get the simple cases out of the way first\n  if (value === null || (['number', 'boolean', 'string'].includes(typeof value) && !(0,is/* isNaN */.i2)(value))) {\n    return value ;\n  }\n\n  var stringified = stringifyValue(key, value);\n\n  // Anything we could potentially dig into more (objects or arrays) will have come back as `\"[object XXXX]\"`.\n  // Everything else will have already been serialized, so if we don't see that pattern, we're done.\n  if (!stringified.startsWith('[object ')) {\n    return stringified;\n  }\n\n  // From here on, we can assert that `value` is either an object or an array.\n\n  // Do not normalize objects that we know have already been normalized. As a general rule, the\n  // \"__sentry_skip_normalization__\" property should only be used sparingly and only should only be set on objects that\n  // have already been normalized.\n  if ((value )['__sentry_skip_normalization__']) {\n    return value ;\n  }\n\n  // We're also done if we've reached the max depth\n  if (depth === 0) {\n    // At this point we know `serialized` is a string of the form `\"[object XXXX]\"`. Clean it up so it's just `\"[XXXX]\"`.\n    return stringified.replace('object ', '');\n  }\n\n  // If we've already visited this branch, bail out, as it's circular reference. If not, note that we're seeing it now.\n  if (memoize(value)) {\n    return '[Circular ~]';\n  }\n\n  // If the value has a `toJSON` method, we call it to extract more information\n  var valueWithToJSON = value ;\n  if (valueWithToJSON && typeof valueWithToJSON.toJSON === 'function') {\n    try {\n      var jsonValue = valueWithToJSON.toJSON();\n      // We need to normalize the return value of `.toJSON()` in case it has circular references\n      return visit('', jsonValue, depth - 1, maxProperties, memo);\n    } catch (err) {\n      // pass (The built-in `toJSON` failed, but we can still try to do it ourselves)\n    }\n  }\n\n  // At this point we know we either have an object or an array, we haven't seen it before, and we're going to recurse\n  // because we haven't yet reached the max depth. Create an accumulator to hold the results of visiting each\n  // property/entry, and keep track of the number of items we add to it.\n  var normalized = (Array.isArray(value) ? [] : {}) ;\n  let numAdded = 0;\n\n  // Before we begin, convert`Error` and`Event` instances into plain objects, since some of each of their relevant\n  // properties are non-enumerable and otherwise would get missed.\n  var visitable = (0,object/* convertToPlainObject */.Sh)(value );\n\n  for (var visitKey in visitable) {\n    // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.\n    if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {\n      continue;\n    }\n\n    if (numAdded >= maxProperties) {\n      normalized[visitKey] = '[MaxProperties ~]';\n      break;\n    }\n\n    // Recursively visit all the child nodes\n    var visitValue = visitable[visitKey];\n    normalized[visitKey] = visit(visitKey, visitValue, depth - 1, maxProperties, memo);\n\n    numAdded += 1;\n  }\n\n  // Once we've visited all the branches, remove the parent from memo storage\n  unmemoize(value);\n\n  // Return accumulated values\n  return normalized;\n}\n\n/**\n * Stringify the given value. Handles various known special values and types.\n *\n * Not meant to be used on simple primitives which already have a string representation, as it will, for example, turn\n * the number 1231 into \"[Object Number]\", nor on `null`, as it will throw.\n *\n * @param value The value to stringify\n * @returns A stringified representation of the given value\n */\nfunction stringifyValue(\n  key,\n  // this type is a tiny bit of a cheat, since this function does handle NaN (which is technically a number), but for\n  // our internal use, it'll do\n  value,\n) {\n  try {\n    if (key === 'domain' && value && typeof value === 'object' && (value )._events) {\n      return '[Domain]';\n    }\n\n    if (key === 'domainEmitter') {\n      return '[DomainEmitter]';\n    }\n\n    // It's safe to use `global`, `window`, and `document` here in this manner, as we are asserting using `typeof` first\n    // which won't throw if they are not present.\n\n    if (typeof __webpack_require__.g !== 'undefined' && value === __webpack_require__.g) {\n      return '[Global]';\n    }\n\n        if (typeof window !== 'undefined' && value === window) {\n      return '[Window]';\n    }\n\n        if (typeof document !== 'undefined' && value === document) {\n      return '[Document]';\n    }\n\n    // React's SyntheticEvent thingy\n    if ((0,is/* isSyntheticEvent */.Cy)(value)) {\n      return '[SyntheticEvent]';\n    }\n\n    if (typeof value === 'number' && value !== value) {\n      return '[NaN]';\n    }\n\n    // this catches `undefined` (but not `null`, which is a primitive and can be serialized on its own)\n    if (value === void 0) {\n      return '[undefined]';\n    }\n\n    if (typeof value === 'function') {\n      return `[Function: ${(0,stacktrace/* getFunctionName */.$P)(value)}]`;\n    }\n\n    if (typeof value === 'symbol') {\n      return `[${String(value)}]`;\n    }\n\n    // stringified BigInts are indistinguishable from regular numbers, so we need to label them to avoid confusion\n    if (typeof value === 'bigint') {\n      return `[BigInt: ${String(value)}]`;\n    }\n\n    // Now that we've knocked out all the special cases and the primitives, all we have left are objects. Simply casting\n    // them to strings means that instances of classes which haven't defined their `toStringTag` will just come out as\n    // `\"[object Object]\"`. If we instead look at the constructor's name (which is the same as the name of the class),\n    // we can make sure that only plain objects come out that way.\n    return `[object ${(Object.getPrototypeOf(value) ).constructor.name}]`;\n  } catch (err) {\n    return `**non-serializable** (${err})`;\n  }\n}\n\n/** Calculates bytes size of input string */\nfunction utf8Length(value) {\n    return ~-encodeURI(value).split(/%..|./).length;\n}\n\n/** Calculates bytes size of input object */\nfunction jsonSize(value) {\n  return utf8Length(JSON.stringify(value));\n}\n\n\n//# sourceMappingURL=normalize.js.map\n\n\n/***/ }),\n\n/***/ 535:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$Q\": function() { return /* binding */ markFunctionWrapped; },\n/* harmony export */   \"HK\": function() { return /* binding */ getOriginalFunction; },\n/* harmony export */   \"Jr\": function() { return /* binding */ dropUndefinedKeys; },\n/* harmony export */   \"Sh\": function() { return /* binding */ convertToPlainObject; },\n/* harmony export */   \"_j\": function() { return /* binding */ urlEncode; },\n/* harmony export */   \"hl\": function() { return /* binding */ fill; },\n/* harmony export */   \"xp\": function() { return /* binding */ addNonEnumerableProperty; },\n/* harmony export */   \"zf\": function() { return /* binding */ extractExceptionKeysForMessage; }\n/* harmony export */ });\n/* unused harmony export objectify */\n/* harmony import */ var _browser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8464);\n/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7597);\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7321);\n\n\n\n\n/**\n * Replace a method in an object with a wrapped version of itself.\n *\n * @param source An object that contains a method to be wrapped.\n * @param name The name of the method to be wrapped.\n * @param replacementFactory A higher-order function that takes the original version of the given method and returns a\n * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to\n * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other\n * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.\n * @returns void\n */\nfunction fill(source, name, replacementFactory) {\n  if (!(name in source)) {\n    return;\n  }\n\n  var original = source[name] ;\n  var wrapped = replacementFactory(original) ;\n\n  // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n  // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n  if (typeof wrapped === 'function') {\n    try {\n      markFunctionWrapped(wrapped, original);\n    } catch (_Oo) {\n      // This can throw if multiple fill happens on a global object like XMLHttpRequest\n      // Fixes https://github.com/getsentry/sentry-javascript/issues/2043\n    }\n  }\n\n  source[name] = wrapped;\n}\n\n/**\n * Defines a non-enumerable property on the given object.\n *\n * @param obj The object on which to set the property\n * @param name The name of the property to be set\n * @param value The value to which to set the property\n */\nfunction addNonEnumerableProperty(obj, name, value) {\n  Object.defineProperty(obj, name, {\n    // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it\n    value: value,\n    writable: true,\n    configurable: true,\n  });\n}\n\n/**\n * Remembers the original function on the wrapped function and\n * patches up the prototype.\n *\n * @param wrapped the wrapper function\n * @param original the original function that gets wrapped\n */\nfunction markFunctionWrapped(wrapped, original) {\n  var proto = original.prototype || {};\n  wrapped.prototype = original.prototype = proto;\n  addNonEnumerableProperty(wrapped, '__sentry_original__', original);\n}\n\n/**\n * This extracts the original function if available.  See\n * `markFunctionWrapped` for more information.\n *\n * @param func the function to unwrap\n * @returns the unwrapped version of the function if available.\n */\nfunction getOriginalFunction(func) {\n  return func.__sentry_original__;\n}\n\n/**\n * Encodes given object into url-friendly format\n *\n * @param object An object that contains serializable values\n * @returns string Encoded\n */\nfunction urlEncode(object) {\n  return Object.keys(object)\n    .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(object[key])}`)\n    .join('&');\n}\n\n/**\n * Transforms any `Error` or `Event` into a plain object with all of their enumerable properties, and some of their\n * non-enumerable properties attached.\n *\n * @param value Initial source that we have to transform in order for it to be usable by the serializer\n * @returns An Event or Error turned into an object - or the value argurment itself, when value is neither an Event nor\n *  an Error.\n */\nfunction convertToPlainObject(\n  value,\n)\n\n {\n  if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__/* .isError */ .VZ)(value)) {\n    return {\n      message: value.message,\n      name: value.name,\n      stack: value.stack,\n      ...getOwnProperties(value),\n    };\n  } else if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__/* .isEvent */ .cO)(value)) {\n    var newObj\n\n = {\n      type: value.type,\n      target: serializeEventTarget(value.target),\n      currentTarget: serializeEventTarget(value.currentTarget),\n      ...getOwnProperties(value),\n    };\n\n    if (typeof CustomEvent !== 'undefined' && (0,_is_js__WEBPACK_IMPORTED_MODULE_0__/* .isInstanceOf */ .V9)(value, CustomEvent)) {\n      newObj.detail = value.detail;\n    }\n\n    return newObj;\n  } else {\n    return value;\n  }\n}\n\n/** Creates a string representation of the target of an `Event` object */\nfunction serializeEventTarget(target) {\n  try {\n    return (0,_is_js__WEBPACK_IMPORTED_MODULE_0__/* .isElement */ .kK)(target) ? (0,_browser_js__WEBPACK_IMPORTED_MODULE_1__/* .htmlTreeAsString */ .Rt)(target) : Object.prototype.toString.call(target);\n  } catch (_oO) {\n    return '<unknown>';\n  }\n}\n\n/** Filters out all but an object's own properties */\nfunction getOwnProperties(obj) {\n  if (typeof obj === 'object' && obj !== null) {\n    var extractedProps = {};\n    for (var property in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, property)) {\n        extractedProps[property] = (obj )[property];\n      }\n    }\n    return extractedProps;\n  } else {\n    return {};\n  }\n}\n\n/**\n * Given any captured exception, extract its keys and create a sorted\n * and truncated list that will be used inside the event message.\n * eg. `Non-error exception captured with keys: foo, bar, baz`\n */\nfunction extractExceptionKeysForMessage(exception, maxLength = 40) {\n  var keys = Object.keys(convertToPlainObject(exception));\n  keys.sort();\n\n  if (!keys.length) {\n    return '[object has no keys]';\n  }\n\n  if (keys[0].length >= maxLength) {\n    return (0,_string_js__WEBPACK_IMPORTED_MODULE_2__/* .truncate */ .$G)(keys[0], maxLength);\n  }\n\n  for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {\n    var serialized = keys.slice(0, includedKeys).join(', ');\n    if (serialized.length > maxLength) {\n      continue;\n    }\n    if (includedKeys === keys.length) {\n      return serialized;\n    }\n    return (0,_string_js__WEBPACK_IMPORTED_MODULE_2__/* .truncate */ .$G)(serialized, maxLength);\n  }\n\n  return '';\n}\n\n/**\n * Given any object, return a new object having removed all fields whose value was `undefined`.\n * Works recursively on objects and arrays.\n *\n * Attention: This function keeps circular references in the returned object.\n */\nfunction dropUndefinedKeys(inputValue) {\n  // This map keeps track of what already visited nodes map to.\n  // Our Set - based memoBuilder doesn't work here because we want to the output object to have the same circular\n  // references as the input object.\n  var memoizationMap = new Map();\n\n  // This function just proxies `_dropUndefinedKeys` to keep the `memoBuilder` out of this function's API\n  return _dropUndefinedKeys(inputValue, memoizationMap);\n}\n\nfunction _dropUndefinedKeys(inputValue, memoizationMap) {\n  if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__/* .isPlainObject */ .PO)(inputValue)) {\n    // If this node has already been visited due to a circular reference, return the object it was mapped to in the new object\n    var memoVal = memoizationMap.get(inputValue);\n    if (memoVal !== undefined) {\n      return memoVal ;\n    }\n\n    var returnValue = {};\n    // Store the mapping of this value in case we visit it again, in case of circular data\n    memoizationMap.set(inputValue, returnValue);\n\n    for (var key of Object.keys(inputValue)) {\n      if (typeof inputValue[key] !== 'undefined') {\n        returnValue[key] = _dropUndefinedKeys(inputValue[key], memoizationMap);\n      }\n    }\n\n    return returnValue ;\n  }\n\n  if (Array.isArray(inputValue)) {\n    // If this node has already been visited due to a circular reference, return the array it was mapped to in the new object\n    var memoVal = memoizationMap.get(inputValue);\n    if (memoVal !== undefined) {\n      return memoVal ;\n    }\n\n    var returnValue = [];\n    // Store the mapping of this value in case we visit it again, in case of circular data\n    memoizationMap.set(inputValue, returnValue);\n\n    inputValue.forEach((item) => {\n      returnValue.push(_dropUndefinedKeys(item, memoizationMap));\n    });\n\n    return returnValue ;\n  }\n\n  return inputValue;\n}\n\n/**\n * Ensure that something is an object.\n *\n * Turns `undefined` and `null` into `String`s and all other primitives into instances of their respective wrapper\n * classes (String, Boolean, Number, etc.). Acts as the identity function on non-primitives.\n *\n * @param wat The subject of the objectification\n * @returns A version of `wat` which can safely be used with `Object` class methods\n */\nfunction objectify(wat) {\n  let objectified;\n  switch (true) {\n    case wat === undefined || wat === null:\n      objectified = new String(wat);\n      break;\n\n    // Though symbols and bigints do have wrapper classes (`Symbol` and `BigInt`, respectively), for whatever reason\n    // those classes don't have constructors which can be used with the `new` keyword. We therefore need to cast each as\n    // an object in order to wrap it.\n    case typeof wat === 'symbol' || typeof wat === 'bigint':\n      objectified = Object(wat);\n      break;\n\n    // this will catch the remaining primitives: `String`, `Number`, and `Boolean`\n    case isPrimitive(wat):\n            objectified = new (wat ).constructor(wat);\n      break;\n\n    // by process of elimination, at this point we know that `wat` must already be an object\n    default:\n      objectified = wat;\n      break;\n  }\n  return objectified;\n}\n\n\n//# sourceMappingURL=object.js.map\n\n\n/***/ }),\n\n/***/ 360:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$P\": function() { return /* binding */ getFunctionName; },\n/* harmony export */   \"Sq\": function() { return /* binding */ stackParserFromStackParserOptions; },\n/* harmony export */   \"pE\": function() { return /* binding */ createStackParser; }\n/* harmony export */ });\n/* unused harmony exports nodeStackLineParser, stripSentryFramesAndReverse */\n\n\nvar STACKTRACE_LIMIT = 50;\n\n/**\n * Creates a stack parser with the supplied line parsers\n *\n * StackFrames are returned in the correct order for Sentry Exception\n * frames and with Sentry SDK internal frames removed from the top and bottom\n *\n */\nfunction createStackParser(...parsers) {\n  var sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map(p => p[1]);\n\n  return (stack, skipFirst = 0) => {\n    var frames = [];\n\n    for (var line of stack.split('\\n').slice(skipFirst)) {\n      // https://github.com/getsentry/sentry-javascript/issues/5459\n      // Remove webpack (error: *) wrappers\n      var cleanedLine = line.replace(/\\(error: (.*)\\)/, '$1');\n\n      for (var parser of sortedParsers) {\n        var frame = parser(cleanedLine);\n\n        if (frame) {\n          frames.push(frame);\n          break;\n        }\n      }\n    }\n\n    return stripSentryFramesAndReverse(frames);\n  };\n}\n\n/**\n * Gets a stack parser implementation from Options.stackParser\n * @see Options\n *\n * If options contains an array of line parsers, it is converted into a parser\n */\nfunction stackParserFromStackParserOptions(stackParser) {\n  if (Array.isArray(stackParser)) {\n    return createStackParser(...stackParser);\n  }\n  return stackParser;\n}\n\n/**\n * @hidden\n */\nfunction stripSentryFramesAndReverse(stack) {\n  if (!stack.length) {\n    return [];\n  }\n\n  let localStack = stack;\n\n  var firstFrameFunction = localStack[0].function || '';\n  var lastFrameFunction = localStack[localStack.length - 1].function || '';\n\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {\n    localStack = localStack.slice(1);\n  }\n\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {\n    localStack = localStack.slice(0, -1);\n  }\n\n  // The frame where the crash happened, should be the last entry in the array\n  return localStack\n    .slice(0, STACKTRACE_LIMIT)\n    .map(frame => ({\n      ...frame,\n      filename: frame.filename || localStack[0].filename,\n      function: frame.function || '?',\n    }))\n    .reverse();\n}\n\nvar defaultFunctionName = '<anonymous>';\n\n/**\n * Safely extract function name from itself\n */\nfunction getFunctionName(fn) {\n  try {\n    if (!fn || typeof fn !== 'function') {\n      return defaultFunctionName;\n    }\n    return fn.name || defaultFunctionName;\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    return defaultFunctionName;\n  }\n}\n\nfunction node(getModule) {\n  var FILENAME_MATCH = /^\\s*[-]{4,}$/;\n  var FULL_MATCH = /at (?:async )?(?:(.+?)\\s+\\()?(?:(.+):(\\d+):(\\d+)?|([^)]+))\\)?/;\n\n    return (line) => {\n    if (line.match(FILENAME_MATCH)) {\n      return {\n        filename: line,\n      };\n    }\n\n    var lineMatch = line.match(FULL_MATCH);\n    if (!lineMatch) {\n      return undefined;\n    }\n\n    let object;\n    let method;\n    let functionName;\n    let typeName;\n    let methodName;\n\n    if (lineMatch[1]) {\n      functionName = lineMatch[1];\n\n      let methodStart = functionName.lastIndexOf('.');\n      if (functionName[methodStart - 1] === '.') {\n                methodStart--;\n      }\n\n      if (methodStart > 0) {\n        object = functionName.substr(0, methodStart);\n        method = functionName.substr(methodStart + 1);\n        var objectEnd = object.indexOf('.Module');\n        if (objectEnd > 0) {\n          functionName = functionName.substr(objectEnd + 1);\n          object = object.substr(0, objectEnd);\n        }\n      }\n      typeName = undefined;\n    }\n\n    if (method) {\n      typeName = object;\n      methodName = method;\n    }\n\n    if (method === '<anonymous>') {\n      methodName = undefined;\n      functionName = undefined;\n    }\n\n    if (functionName === undefined) {\n      methodName = methodName || '<anonymous>';\n      functionName = typeName ? `${typeName}.${methodName}` : methodName;\n    }\n\n    var filename = _optionalChain([lineMatch, 'access', _ => _[2], 'optionalAccess', _2 => _2.startsWith, 'call', _3 => _3('file://')]) ? lineMatch[2].substr(7) : lineMatch[2];\n    var isNative = lineMatch[5] === 'native';\n    var isInternal =\n      isNative || (filename && !filename.startsWith('/') && !filename.startsWith('.') && filename.indexOf(':\\\\') !== 1);\n\n    // in_app is all that's not an internal Node function or a module within node_modules\n    // note that isNative appears to return true even for node core libraries\n    // see https://github.com/getsentry/raven-node/issues/176\n    var in_app = !isInternal && filename !== undefined && !filename.includes('node_modules/');\n\n    return {\n      filename,\n      module: _optionalChain([getModule, 'optionalCall', _4 => _4(filename)]),\n      function: functionName,\n      lineno: parseInt(lineMatch[3], 10) || undefined,\n      colno: parseInt(lineMatch[4], 10) || undefined,\n      in_app,\n    };\n  };\n}\n\n/**\n * Node.js stack line parser\n *\n * This is in @sentry/utils so it can be used from the Electron SDK in the browser for when `nodeIntegration == true`.\n * This allows it to be used without referencing or importing any node specific code which causes bundlers to complain\n */\nfunction nodeStackLineParser(getModule) {\n  return [90, node(getModule)];\n}\n\n\n//# sourceMappingURL=stacktrace.js.map\n\n\n/***/ }),\n\n/***/ 7321:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$G\": function() { return /* binding */ truncate; },\n/* harmony export */   \"nK\": function() { return /* binding */ safeJoin; },\n/* harmony export */   \"zC\": function() { return /* binding */ isMatchingPattern; }\n/* harmony export */ });\n/* unused harmony exports escapeStringForRegex, snipLine */\n/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7597);\n\n\n/**\n * Truncates given string to the maximum characters count\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string (0 = unlimited)\n * @returns string Encoded\n */\nfunction truncate(str, max = 0) {\n  if (typeof str !== 'string' || max === 0) {\n    return str;\n  }\n  return str.length <= max ? str : `${str.substr(0, max)}...`;\n}\n\n/**\n * This is basically just `trim_line` from\n * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string\n * @returns string Encoded\n */\nfunction snipLine(line, colno) {\n  let newLine = line;\n  var lineLength = newLine.length;\n  if (lineLength <= 150) {\n    return newLine;\n  }\n  if (colno > lineLength) {\n        colno = lineLength;\n  }\n\n  let start = Math.max(colno - 60, 0);\n  if (start < 5) {\n    start = 0;\n  }\n\n  let end = Math.min(start + 140, lineLength);\n  if (end > lineLength - 5) {\n    end = lineLength;\n  }\n  if (end === lineLength) {\n    start = Math.max(end - 140, 0);\n  }\n\n  newLine = newLine.slice(start, end);\n  if (start > 0) {\n    newLine = `'{snip} ${newLine}`;\n  }\n  if (end < lineLength) {\n    newLine += ' {snip}';\n  }\n\n  return newLine;\n}\n\n/**\n * Join values in array\n * @param input array of values to be joined together\n * @param delimiter string to be placed in-between values\n * @returns Joined values\n */\nfunction safeJoin(input, delimiter) {\n  if (!Array.isArray(input)) {\n    return '';\n  }\n\n  var output = [];\n    for (let i = 0; i < input.length; i++) {\n    var value = input[i];\n    try {\n      output.push(String(value));\n    } catch (e) {\n      output.push('[value cannot be serialized]');\n    }\n  }\n\n  return output.join(delimiter);\n}\n\n/**\n * Checks if the value matches a regex or includes the string\n * @param value The string value to be checked against\n * @param pattern Either a regex or a string that must be contained in value\n */\nfunction isMatchingPattern(value, pattern) {\n  if (!(0,_is_js__WEBPACK_IMPORTED_MODULE_0__/* .isString */ .HD)(value)) {\n    return false;\n  }\n\n  if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__/* .isRegExp */ .Kj)(pattern)) {\n    return pattern.test(value);\n  }\n  if (typeof pattern === 'string') {\n    return value.indexOf(pattern) !== -1;\n  }\n  return false;\n}\n\n/**\n * Given a string, escape characters which have meaning in the regex grammar, such that the result is safe to feed to\n * `new RegExp()`.\n *\n * Based on https://github.com/sindresorhus/escape-string-regexp. Vendored to a) reduce the size by skipping the runtime\n * type-checking, and b) ensure it gets down-compiled for old versions of Node (the published package only supports Node\n * 12+).\n *\n * @param regexString The string to escape\n * @returns An version of the string with all special regex characters escaped\n */\nfunction escapeStringForRegex(regexString) {\n  // escape the hyphen separately so we can also replace it with a unicode literal hyphen, to avoid the problems\n  // discussed in https://github.com/sindresorhus/escape-string-regexp/issues/20.\n  return regexString.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d');\n}\n\n\n//# sourceMappingURL=string.js.map\n\n\n/***/ }),\n\n/***/ 8823:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Ak\": function() { return /* binding */ supportsFetch; },\n/* harmony export */   \"Bf\": function() { return /* binding */ supportsHistory; },\n/* harmony export */   \"Du\": function() { return /* binding */ isNativeFetch; },\n/* harmony export */   \"t$\": function() { return /* binding */ supportsNativeFetch; }\n/* harmony export */ });\n/* unused harmony exports supportsDOMError, supportsDOMException, supportsErrorEvent, supportsReferrerPolicy, supportsReportingObserver */\n/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2991);\n/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2343);\n\n\n\n/**\n * Tells whether current environment supports ErrorEvent objects\n * {@link supportsErrorEvent}.\n *\n * @returns Answer to the given question.\n */\nfunction supportsErrorEvent() {\n  try {\n    new ErrorEvent('');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports DOMError objects\n * {@link supportsDOMError}.\n *\n * @returns Answer to the given question.\n */\nfunction supportsDOMError() {\n  try {\n    // Chrome: VM89:1 Uncaught TypeError: Failed to construct 'DOMError':\n    // 1 argument required, but only 0 present.\n    // @ts-ignore It really needs 1 argument, not 0.\n    new DOMError('');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports DOMException objects\n * {@link supportsDOMException}.\n *\n * @returns Answer to the given question.\n */\nfunction supportsDOMException() {\n  try {\n    new DOMException('');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports Fetch API\n * {@link supportsFetch}.\n *\n * @returns Answer to the given question.\n */\nfunction supportsFetch() {\n  if (!('fetch' in (0,_global_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalObject */ .R)())) {\n    return false;\n  }\n\n  try {\n    new Headers();\n    new Request('http://www.example.com');\n    new Response();\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * isNativeFetch checks if the given function is a native implementation of fetch()\n */\nfunction isNativeFetch(func) {\n  return func && /^function fetch\\(\\)\\s+\\{\\s+\\[native code\\]\\s+\\}$/.test(func.toString());\n}\n\n/**\n * Tells whether current environment supports Fetch API natively\n * {@link supportsNativeFetch}.\n *\n * @returns true if `window.fetch` is natively implemented, false otherwise\n */\nfunction supportsNativeFetch() {\n  if (!supportsFetch()) {\n    return false;\n  }\n\n  var global = (0,_global_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalObject */ .R)();\n\n  // Fast path to avoid DOM I/O\n    if (isNativeFetch(global.fetch)) {\n    return true;\n  }\n\n  // window.fetch is implemented, but is polyfilled or already wrapped (e.g: by a chrome extension)\n  // so create a \"pure\" iframe to see if that has native fetch\n  let result = false;\n  var doc = global.document;\n    if (doc && typeof (doc.createElement ) === 'function') {\n    try {\n      var sandbox = doc.createElement('iframe');\n      sandbox.hidden = true;\n      doc.head.appendChild(sandbox);\n      if (sandbox.contentWindow && sandbox.contentWindow.fetch) {\n                result = isNativeFetch(sandbox.contentWindow.fetch);\n      }\n      doc.head.removeChild(sandbox);\n    } catch (err) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* .logger.warn */ .kg.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', err);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Tells whether current environment supports ReportingObserver API\n * {@link supportsReportingObserver}.\n *\n * @returns Answer to the given question.\n */\nfunction supportsReportingObserver() {\n  return 'ReportingObserver' in getGlobalObject();\n}\n\n/**\n * Tells whether current environment supports Referrer Policy API\n * {@link supportsReferrerPolicy}.\n *\n * @returns Answer to the given question.\n */\nfunction supportsReferrerPolicy() {\n  // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default'\n  // (see https://caniuse.com/#feat=referrer-policy),\n  // it doesn't. And it throws an exception instead of ignoring this parameter...\n  // REF: https://github.com/getsentry/raven-js/issues/1233\n\n  if (!supportsFetch()) {\n    return false;\n  }\n\n  try {\n    new Request('_', {\n      referrerPolicy: 'origin' ,\n    });\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports History API\n * {@link supportsHistory}.\n *\n * @returns Answer to the given question.\n */\nfunction supportsHistory() {\n  // NOTE: in Chrome App environment, touching history.pushState, *even inside\n  //       a try/catch block*, will cause Chrome to output an error to console.error\n  // borrowed from: https://github.com/angular/angular.js/pull/13945/files\n  var global = (0,_global_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalObject */ .R)();\n      var chrome = (global ).chrome;\n  var isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;\n    var hasHistoryApi = 'history' in global && !!global.history.pushState && !!global.history.replaceState;\n\n  return !isChromePackagedApp && hasHistoryApi;\n}\n\n\n//# sourceMappingURL=supports.js.map\n\n\n/***/ }),\n\n/***/ 6893:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$2\": function() { return /* binding */ rejectedSyncPromise; },\n/* harmony export */   \"WD\": function() { return /* binding */ resolvedSyncPromise; },\n/* harmony export */   \"cW\": function() { return /* binding */ SyncPromise; }\n/* harmony export */ });\n/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7597);\n\n\n/** SyncPromise internal states */\nvar States; (function (States) {\n  /** Pending */\n  var PENDING = 0; States[States[\"PENDING\"] = PENDING] = \"PENDING\";\n  /** Resolved / OK */\n  var RESOLVED = 1; States[States[\"RESOLVED\"] = RESOLVED] = \"RESOLVED\";\n  /** Rejected / Error */\n  var REJECTED = 2; States[States[\"REJECTED\"] = REJECTED] = \"REJECTED\";\n})(States || (States = {}));\n\n// Overloads so we can call resolvedSyncPromise without arguments and generic argument\n\n/**\n * Creates a resolved sync promise.\n *\n * @param value the value to resolve the promise with\n * @returns the resolved sync promise\n */\nfunction resolvedSyncPromise(value) {\n  return new SyncPromise(resolve => {\n    resolve(value);\n  });\n}\n\n/**\n * Creates a rejected sync promise.\n *\n * @param value the value to reject the promise with\n * @returns the rejected sync promise\n */\nfunction rejectedSyncPromise(reason) {\n  return new SyncPromise((_, reject) => {\n    reject(reason);\n  });\n}\n\n/**\n * Thenable class that behaves like a Promise and follows it's interface\n * but is not async internally\n */\nclass SyncPromise {\n   __init() {this._state = States.PENDING;}\n   __init2() {this._handlers = [];}\n  \n\n   constructor(\n    executor,\n  ) {;SyncPromise.prototype.__init.call(this);SyncPromise.prototype.__init2.call(this);SyncPromise.prototype.__init3.call(this);SyncPromise.prototype.__init4.call(this);SyncPromise.prototype.__init5.call(this);SyncPromise.prototype.__init6.call(this);\n    try {\n      executor(this._resolve, this._reject);\n    } catch (e) {\n      this._reject(e);\n    }\n  }\n\n  /** JSDoc */\n   then(\n    onfulfilled,\n    onrejected,\n  ) {\n    return new SyncPromise((resolve, reject) => {\n      this._handlers.push([\n        false,\n        result => {\n          if (!onfulfilled) {\n            // TODO: \\_()_/\n            // TODO: FIXME\n            resolve(result );\n          } else {\n            try {\n              resolve(onfulfilled(result));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n        reason => {\n          if (!onrejected) {\n            reject(reason);\n          } else {\n            try {\n              resolve(onrejected(reason));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n      ]);\n      this._executeHandlers();\n    });\n  }\n\n  /** JSDoc */\n   catch(\n    onrejected,\n  ) {\n    return this.then(val => val, onrejected);\n  }\n\n  /** JSDoc */\n   finally(onfinally) {\n    return new SyncPromise((resolve, reject) => {\n      let val;\n      let isRejected;\n\n      return this.then(\n        value => {\n          isRejected = false;\n          val = value;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n        reason => {\n          isRejected = true;\n          val = reason;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n      ).then(() => {\n        if (isRejected) {\n          reject(val);\n          return;\n        }\n\n        resolve(val );\n      });\n    });\n  }\n\n  /** JSDoc */\n    __init3() {this._resolve = (value) => {\n    this._setResult(States.RESOLVED, value);\n  };}\n\n  /** JSDoc */\n    __init4() {this._reject = (reason) => {\n    this._setResult(States.REJECTED, reason);\n  };}\n\n  /** JSDoc */\n    __init5() {this._setResult = (state, value) => {\n    if (this._state !== States.PENDING) {\n      return;\n    }\n\n    if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__/* .isThenable */ .J8)(value)) {\n      void (value ).then(this._resolve, this._reject);\n      return;\n    }\n\n    this._state = state;\n    this._value = value;\n\n    this._executeHandlers();\n  };}\n\n  /** JSDoc */\n    __init6() {this._executeHandlers = () => {\n    if (this._state === States.PENDING) {\n      return;\n    }\n\n    var cachedHandlers = this._handlers.slice();\n    this._handlers = [];\n\n    cachedHandlers.forEach(handler => {\n      if (handler[0]) {\n        return;\n      }\n\n      if (this._state === States.RESOLVED) {\n                handler[1](this._value );\n      }\n\n      if (this._state === States.REJECTED) {\n        handler[2](this._value);\n      }\n\n      handler[0] = true;\n    });\n  };}\n}\n\n\n//# sourceMappingURL=syncpromise.js.map\n\n\n/***/ }),\n\n/***/ 1170:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Z1\": function() { return /* binding */ browserPerformanceTimeOrigin; },\n/* harmony export */   \"_I\": function() { return /* binding */ timestampWithMs; },\n/* harmony export */   \"ph\": function() { return /* binding */ timestampInSeconds; },\n/* harmony export */   \"yW\": function() { return /* binding */ dateTimestampInSeconds; }\n/* harmony export */ });\n/* unused harmony exports _browserPerformanceTimeOriginMode, usingPerformanceAPI */\n/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2991);\n/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2448);\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\n\n/**\n * An object that can return the current timestamp in seconds since the UNIX epoch.\n */\n\n/**\n * A TimestampSource implementation for environments that do not support the Performance Web API natively.\n *\n * Note that this TimestampSource does not use a monotonic clock. A call to `nowSeconds` may return a timestamp earlier\n * than a previously returned value. We do not try to emulate a monotonic behavior in order to facilitate debugging. It\n * is more obvious to explain \"why does my span have negative duration\" than \"why my spans have zero duration\".\n */\nvar dateTimestampSource = {\n  nowSeconds: () => Date.now() / 1000,\n};\n\n/**\n * A partial definition of the [Performance Web API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance}\n * for accessing a high-resolution monotonic clock.\n */\n\n/**\n * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not\n * support the API.\n *\n * Wrapping the native API works around differences in behavior from different browsers.\n */\nfunction getBrowserPerformance() {\n  const { performance } = (0,_global_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalObject */ .R)();\n  if (!performance || !performance.now) {\n    return undefined;\n  }\n\n  // Replace performance.timeOrigin with our own timeOrigin based on Date.now().\n  //\n  // This is a partial workaround for browsers reporting performance.timeOrigin such that performance.timeOrigin +\n  // performance.now() gives a date arbitrarily in the past.\n  //\n  // Additionally, computing timeOrigin in this way fills the gap for browsers where performance.timeOrigin is\n  // undefined.\n  //\n  // The assumption that performance.timeOrigin + performance.now() ~= Date.now() is flawed, but we depend on it to\n  // interact with data coming out of performance entries.\n  //\n  // Note that despite recommendations against it in the spec, browsers implement the Performance API with a clock that\n  // might stop when the computer is asleep (and perhaps under other circumstances). Such behavior causes\n  // performance.timeOrigin + performance.now() to have an arbitrary skew over Date.now(). In laptop computers, we have\n  // observed skews that can be as long as days, weeks or months.\n  //\n  // See https://github.com/getsentry/sentry-javascript/issues/2590.\n  //\n  // BUG: despite our best intentions, this workaround has its limitations. It mostly addresses timings of pageload\n  // transactions, but ignores the skew built up over time that can aversely affect timestamps of navigation\n  // transactions of long-lived web pages.\n  var timeOrigin = Date.now() - performance.now();\n\n  return {\n    now: () => performance.now(),\n    timeOrigin,\n  };\n}\n\n/**\n * Returns the native Performance API implementation from Node.js. Returns undefined in old Node.js versions that don't\n * implement the API.\n */\nfunction getNodePerformance() {\n  try {\n    var perfHooks = (0,_node_js__WEBPACK_IMPORTED_MODULE_1__/* .dynamicRequire */ .l$)(module, 'perf_hooks') ;\n    return perfHooks.performance;\n  } catch (_) {\n    return undefined;\n  }\n}\n\n/**\n * The Performance API implementation for the current platform, if available.\n */\nvar platformPerformance = (0,_node_js__WEBPACK_IMPORTED_MODULE_1__/* .isNodeEnv */ .KV)() ? getNodePerformance() : getBrowserPerformance();\n\nvar timestampSource =\n  platformPerformance === undefined\n    ? dateTimestampSource\n    : {\n        nowSeconds: () => (platformPerformance.timeOrigin + platformPerformance.now()) / 1000,\n      };\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using the Date API.\n */\nvar dateTimestampInSeconds = dateTimestampSource.nowSeconds.bind(dateTimestampSource);\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the\n * availability of the Performance API.\n *\n * See `usingPerformanceAPI` to test whether the Performance API is used.\n *\n * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is\n * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The\n * skew can grow to arbitrary amounts like days, weeks or months.\n * See https://github.com/getsentry/sentry-javascript/issues/2590.\n */\nvar timestampInSeconds = timestampSource.nowSeconds.bind(timestampSource);\n\n// Re-exported with an old name for backwards-compatibility.\nvar timestampWithMs = timestampInSeconds;\n\n/**\n * A boolean that is true when timestampInSeconds uses the Performance API to produce monotonic timestamps.\n */\nvar usingPerformanceAPI = platformPerformance !== undefined;\n\n/**\n * Internal helper to store what is the source of browserPerformanceTimeOrigin below. For debugging only.\n */\nlet _browserPerformanceTimeOriginMode;\n\n/**\n * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the\n * performance API is available.\n */\nvar browserPerformanceTimeOrigin = (() => {\n  // Unfortunately browsers may report an inaccurate time origin data, through either performance.timeOrigin or\n  // performance.timing.navigationStart, which results in poor results in performance data. We only treat time origin\n  // data as reliable if they are within a reasonable threshold of the current time.\n\n  const { performance } = (0,_global_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalObject */ .R)();\n  if (!performance || !performance.now) {\n    _browserPerformanceTimeOriginMode = 'none';\n    return undefined;\n  }\n\n  var threshold = 3600 * 1000;\n  var performanceNow = performance.now();\n  var dateNow = Date.now();\n\n  // if timeOrigin isn't available set delta to threshold so it isn't used\n  var timeOriginDelta = performance.timeOrigin\n    ? Math.abs(performance.timeOrigin + performanceNow - dateNow)\n    : threshold;\n  var timeOriginIsReliable = timeOriginDelta < threshold;\n\n  // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin\n  // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.\n  // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always\n  // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the\n  // Date API.\n    var navigationStart = performance.timing && performance.timing.navigationStart;\n  var hasNavigationStart = typeof navigationStart === 'number';\n  // if navigationStart isn't available set delta to threshold so it isn't used\n  var navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;\n  var navigationStartIsReliable = navigationStartDelta < threshold;\n\n  if (timeOriginIsReliable || navigationStartIsReliable) {\n    // Use the more reliable time origin\n    if (timeOriginDelta <= navigationStartDelta) {\n      _browserPerformanceTimeOriginMode = 'timeOrigin';\n      return performance.timeOrigin;\n    } else {\n      _browserPerformanceTimeOriginMode = 'navigationStart';\n      return navigationStart;\n    }\n  }\n\n  // Either both timeOrigin and navigationStart are skewed or neither is available, fallback to Date.\n  _browserPerformanceTimeOriginMode = 'dateNow';\n  return dateNow;\n})();\n\n\n//# sourceMappingURL=time.js.map\n\n\n/***/ }),\n\n/***/ 6956:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"en\": function() { return /* binding */ parseUrl; },\n/* harmony export */   \"rt\": function() { return /* binding */ stripUrlQueryAndFragment; }\n/* harmony export */ });\n/* unused harmony export getNumberOfUrlSegments */\n/**\n * Parses string form of URL into an object\n * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B\n * // intentionally using regex and not <a/> href parsing trick because React Native and other\n * // environments where DOM might not be available\n * @returns parsed URL object\n */\nfunction parseUrl(url)\n\n {\n  if (!url) {\n    return {};\n  }\n\n  var match = url.match(/^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/);\n\n  if (!match) {\n    return {};\n  }\n\n  // coerce to undefined values to empty string so we don't get 'undefined'\n  var query = match[6] || '';\n  var fragment = match[8] || '';\n  return {\n    host: match[4],\n    path: match[5],\n    protocol: match[2],\n    relative: match[5] + query + fragment, // everything minus origin\n  };\n}\n\n/**\n * Strip the query string and fragment off of a given URL or path (if present)\n *\n * @param urlPath Full URL or path, including possible query string and/or fragment\n * @returns URL or path without query string or fragment\n */\nfunction stripUrlQueryAndFragment(urlPath) {\n    return urlPath.split(/[\\?#]/, 1)[0];\n}\n\n/**\n * Returns number of URL segments of a passed string URL.\n */\nfunction getNumberOfUrlSegments(url) {\n  // split at '/' or at '\\/' to split regex urls correctly\n  return url.split(/\\\\?\\//).filter(s => s.length > 0 && s !== ',').length;\n}\n\n\n//# sourceMappingURL=url.js.map\n\n\n/***/ }),\n\n/***/ 9484:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\nvar _global = (typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {}); _global.SENTRY_RELEASE={id:\"SKJ_I6npCnjx16Vr40v84\"};\n\n/***/ }),\n\n/***/ 3454:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ref, ref1;\nmodule.exports = ((ref = __webpack_require__.g.process) == null ? void 0 : ref.env) && typeof ((ref1 = __webpack_require__.g.process) == null ? void 0 : ref1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(7663);\n\n//# sourceMappingURL=process.js.map\n\n/***/ }),\n\n/***/ 1597:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_app\",\n      function () {\n        return __webpack_require__(6029);\n      }\n    ]);\n    if(false) {}\n  \n\n/***/ }),\n\n/***/ 5627:\n/***/ (function(__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/core/esm/version.js\nvar SDK_VERSION = '7.13.0';\n\n\n//# sourceMappingURL=version.js.map\n\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/logger.js\nvar esm_logger = __webpack_require__(2343);\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/misc.js\nvar misc = __webpack_require__(2844);\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/string.js\nvar string = __webpack_require__(7321);\n;// CONCATENATED MODULE: ./node_modules/@sentry/core/esm/integrations/inboundfilters.js\n\n\n// \"Script error.\" is hard coded into browsers for errors that it can't read.\n// this is the result of a script being pulled in from an external domain and CORS.\nvar DEFAULT_IGNORE_ERRORS = [/^Script error\\.?$/, /^Javascript error: Script error\\.? on line 0$/];\n\n/** Options for the InboundFilters integration */\n\n/** Inbound filters configurable by the user */\nclass InboundFilters  {\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'InboundFilters';}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = InboundFilters.id;}\n\n   constructor(  _options = {}) {;this._options = _options;InboundFilters.prototype.__init.call(this);}\n\n  /**\n   * @inheritDoc\n   */\n   setupOnce(addGlobalEventProcessor, getCurrentHub) {\n    var eventProcess = (event) => {\n      var hub = getCurrentHub();\n      if (hub) {\n        var self = hub.getIntegration(InboundFilters);\n        if (self) {\n          var client = hub.getClient();\n          var clientOptions = client ? client.getOptions() : {};\n          var options = _mergeOptions(self._options, clientOptions);\n          return _shouldDropEvent(event, options) ? null : event;\n        }\n      }\n      return event;\n    };\n\n    eventProcess.id = this.name;\n    addGlobalEventProcessor(eventProcess);\n  }\n} InboundFilters.__initStatic();\n\n/** JSDoc */\nfunction _mergeOptions(\n  internalOptions = {},\n  clientOptions = {},\n) {\n  return {\n    allowUrls: [...(internalOptions.allowUrls || []), ...(clientOptions.allowUrls || [])],\n    denyUrls: [...(internalOptions.denyUrls || []), ...(clientOptions.denyUrls || [])],\n    ignoreErrors: [\n      ...(internalOptions.ignoreErrors || []),\n      ...(clientOptions.ignoreErrors || []),\n      ...DEFAULT_IGNORE_ERRORS,\n    ],\n    ignoreInternal: internalOptions.ignoreInternal !== undefined ? internalOptions.ignoreInternal : true,\n  };\n}\n\n/** JSDoc */\nfunction _shouldDropEvent(event, options) {\n  if (options.ignoreInternal && _isSentryError(event)) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      esm_logger/* logger.warn */.kg.warn(`Event dropped due to being internal Sentry Error.\\nEvent: ${(0,misc/* getEventDescription */.jH)(event)}`);\n    return true;\n  }\n  if (_isIgnoredError(event, options.ignoreErrors)) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      esm_logger/* logger.warn */.kg.warn(\n        `Event dropped due to being matched by \\`ignoreErrors\\` option.\\nEvent: ${(0,misc/* getEventDescription */.jH)(event)}`,\n      );\n    return true;\n  }\n  if (_isDeniedUrl(event, options.denyUrls)) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      esm_logger/* logger.warn */.kg.warn(\n        `Event dropped due to being matched by \\`denyUrls\\` option.\\nEvent: ${(0,misc/* getEventDescription */.jH)(\n          event,\n        )}.\\nUrl: ${_getEventFilterUrl(event)}`,\n      );\n    return true;\n  }\n  if (!_isAllowedUrl(event, options.allowUrls)) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      esm_logger/* logger.warn */.kg.warn(\n        `Event dropped due to not being matched by \\`allowUrls\\` option.\\nEvent: ${(0,misc/* getEventDescription */.jH)(\n          event,\n        )}.\\nUrl: ${_getEventFilterUrl(event)}`,\n      );\n    return true;\n  }\n  return false;\n}\n\nfunction _isIgnoredError(event, ignoreErrors) {\n  if (!ignoreErrors || !ignoreErrors.length) {\n    return false;\n  }\n\n  return _getPossibleEventMessages(event).some(message =>\n    ignoreErrors.some(pattern => (0,string/* isMatchingPattern */.zC)(message, pattern)),\n  );\n}\n\nfunction _isDeniedUrl(event, denyUrls) {\n  // TODO: Use Glob instead?\n  if (!denyUrls || !denyUrls.length) {\n    return false;\n  }\n  var url = _getEventFilterUrl(event);\n  return !url ? false : denyUrls.some(pattern => (0,string/* isMatchingPattern */.zC)(url, pattern));\n}\n\nfunction _isAllowedUrl(event, allowUrls) {\n  // TODO: Use Glob instead?\n  if (!allowUrls || !allowUrls.length) {\n    return true;\n  }\n  var url = _getEventFilterUrl(event);\n  return !url ? true : allowUrls.some(pattern => (0,string/* isMatchingPattern */.zC)(url, pattern));\n}\n\nfunction _getPossibleEventMessages(event) {\n  if (event.message) {\n    return [event.message];\n  }\n  if (event.exception) {\n    try {\n      const { type = '', value = '' } = (event.exception.values && event.exception.values[0]) || {};\n      return [`${value}`, `${type}: ${value}`];\n    } catch (oO) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.error */.kg.error(`Cannot extract message for event ${(0,misc/* getEventDescription */.jH)(event)}`);\n      return [];\n    }\n  }\n  return [];\n}\n\nfunction _isSentryError(event) {\n  try {\n    // @ts-ignore can't be a sentry error if undefined\n        return event.exception.values[0].type === 'SentryError';\n  } catch (e) {\n    // ignore\n  }\n  return false;\n}\n\nfunction _getLastValidUrl(frames = []) {\n  for (let i = frames.length - 1; i >= 0; i--) {\n    var frame = frames[i];\n\n    if (frame && frame.filename !== '<anonymous>' && frame.filename !== '[native code]') {\n      return frame.filename || null;\n    }\n  }\n\n  return null;\n}\n\nfunction _getEventFilterUrl(event) {\n  try {\n    let frames;\n    try {\n      // @ts-ignore we only care about frames if the whole thing here is defined\n      frames = event.exception.values[0].stacktrace.frames;\n    } catch (e) {\n      // ignore\n    }\n    return frames ? _getLastValidUrl(frames) : null;\n  } catch (oO) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.error */.kg.error(`Cannot extract url for event ${(0,misc/* getEventDescription */.jH)(event)}`);\n    return null;\n  }\n}\n\n\n//# sourceMappingURL=inboundfilters.js.map\n\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/object.js\nvar object = __webpack_require__(535);\n;// CONCATENATED MODULE: ./node_modules/@sentry/core/esm/integrations/functiontostring.js\n\n\nlet originalFunctionToString;\n\n/** Patch toString calls to return proper name for wrapped functions */\nclass FunctionToString  {constructor() { FunctionToString.prototype.__init.call(this); }\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'FunctionToString';}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = FunctionToString.id;}\n\n  /**\n   * @inheritDoc\n   */\n   setupOnce() {\n        originalFunctionToString = Function.prototype.toString;\n\n        Function.prototype.toString = function ( ...args) {\n      var context = (0,object/* getOriginalFunction */.HK)(this) || this;\n      return originalFunctionToString.apply(context, args);\n    };\n  }\n} FunctionToString.__initStatic();\n\n\n//# sourceMappingURL=functiontostring.js.map\n\n// EXTERNAL MODULE: ./node_modules/@sentry/hub/esm/scope.js\nvar esm_scope = __webpack_require__(6769);\n// EXTERNAL MODULE: ./node_modules/@sentry/hub/esm/hub.js\nvar esm_hub = __webpack_require__(8641);\n;// CONCATENATED MODULE: ./node_modules/@sentry/core/esm/integration.js\n\n\n\nvar installedIntegrations = [];\n\n/** Map of integrations assigned to a client */\n\n/**\n * Remove duplicates from the given array, preferring the last instance of any duplicate. Not guaranteed to\n * preseve the order of integrations in the array.\n *\n * @private\n */\nfunction filterDuplicates(integrations) {\n  var integrationsByName = {};\n\n  integrations.forEach(currentInstance => {\n    const { name } = currentInstance;\n\n    var existingInstance = integrationsByName[name];\n\n    // We want integrations later in the array to overwrite earlier ones of the same type, except that we never want a\n    // default instance to overwrite an existing user instance\n    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {\n      return;\n    }\n\n    integrationsByName[name] = currentInstance;\n  });\n\n  return Object.values(integrationsByName);\n}\n\n/** Gets integrations to install */\nfunction getIntegrationsToSetup(options) {\n  var defaultIntegrations = options.defaultIntegrations || [];\n  var userIntegrations = options.integrations;\n\n  // We flag default instances, so that later we can tell them apart from any user-created instances of the same class\n  defaultIntegrations.forEach(integration => {\n    integration.isDefaultInstance = true;\n  });\n\n  let integrations;\n\n  if (Array.isArray(userIntegrations)) {\n    integrations = [...defaultIntegrations, ...userIntegrations];\n  } else if (typeof userIntegrations === 'function') {\n    integrations = (0,misc/* arrayify */.lE)(userIntegrations(defaultIntegrations));\n  } else {\n    integrations = defaultIntegrations;\n  }\n\n  var finalIntegrations = filterDuplicates(integrations);\n\n  // The `Debug` integration prints copies of the `event` and `hint` which will be passed to `beforeSend`. It therefore\n  // has to run after all other integrations, so that the changes of all event processors will be reflected in the\n  // printed values. For lack of a more elegant way to guarantee that, we therefore locate it and, assuming it exists,\n  // pop it out of its current spot and shove it onto the end of the array.\n  var debugIndex = finalIntegrations.findIndex(integration => integration.name === 'Debug');\n  if (debugIndex !== -1) {\n    const [debugInstance] = finalIntegrations.splice(debugIndex, 1);\n    finalIntegrations.push(debugInstance);\n  }\n\n  return finalIntegrations;\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nfunction setupIntegrations(integrations) {\n  var integrationIndex = {};\n\n  integrations.forEach(integration => {\n    integrationIndex[integration.name] = integration;\n\n    if (installedIntegrations.indexOf(integration.name) === -1) {\n      integration.setupOnce(esm_scope/* addGlobalEventProcessor */.c, esm_hub/* getCurrentHub */.Gd);\n      installedIntegrations.push(integration.name);\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.log */.kg.log(`Integration installed: ${integration.name}`);\n    }\n  });\n\n  return integrationIndex;\n}\n\n\n//# sourceMappingURL=integration.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/core/esm/sdk.js\n\n\n\n/** A class object that can instantiate Client objects. */\n\n/**\n * Internal function to create a new SDK client instance. The client is\n * installed and then bound to the current scope.\n *\n * @param clientClass The client class to instantiate.\n * @param options Options to pass to the client.\n */\nfunction initAndBind(\n  clientClass,\n  options,\n) {\n  if (options.debug === true) {\n    if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {\n      esm_logger/* logger.enable */.kg.enable();\n    } else {\n      // use `console.warn` rather than `logger.warn` since by non-debug bundles have all `logger.x` statements stripped\n            console.warn('[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.');\n    }\n  }\n  var hub = (0,esm_hub/* getCurrentHub */.Gd)();\n  var scope = hub.getScope();\n  if (scope) {\n    scope.update(options.initialScope);\n  }\n\n  var client = new clientClass(options);\n  hub.bindClient(client);\n}\n\n\n//# sourceMappingURL=sdk.js.map\n\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/global.js\nvar esm_global = __webpack_require__(2991);\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/stacktrace.js\nvar stacktrace = __webpack_require__(360);\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/supports.js\nvar supports = __webpack_require__(8823);\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/instrument.js\nvar instrument = __webpack_require__(9732);\n// EXTERNAL MODULE: ./node_modules/@sentry/hub/esm/session.js\nvar esm_session = __webpack_require__(5771);\n;// CONCATENATED MODULE: ./node_modules/@sentry/utils/esm/error.js\n/** An error emitted by Sentry SDKs and related utilities. */\nclass SentryError extends Error {\n  /** Display name of this error instance. */\n  \n\n   constructor( message, logLevel = 'warn') {\n    super(message);this.message = message;;\n\n    this.name = new.target.prototype.constructor.name;\n    // This sets the prototype to be `Error`, not `SentryError`. It's unclear why we do this, but commenting this line\n    // out causes various (seemingly totally unrelated) playwright tests consistently time out. FYI, this makes\n    // instances of `SentryError` fail `obj instanceof SentryError` checks.\n    Object.setPrototypeOf(this, new.target.prototype);\n    this.logLevel = logLevel;\n  }\n}\n\n\n//# sourceMappingURL=error.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/utils/esm/dsn.js\n\n\n/** Regular expression used to parse a Dsn. */\nvar DSN_REGEX = /^(?:(\\w+):)\\/\\/(?:(\\w+)(?::(\\w+))?@)([\\w.-]+)(?::(\\d+))?\\/(.+)/;\n\nfunction isValidProtocol(protocol) {\n  return protocol === 'http' || protocol === 'https';\n}\n\n/**\n * Renders the string representation of this Dsn.\n *\n * By default, this will render the public representation without the password\n * component. To get the deprecated private representation, set `withPassword`\n * to true.\n *\n * @param withPassword When set to true, the password will be included.\n */\nfunction dsn_dsnToString(dsn, withPassword = false) {\n  const { host, path, pass, port, projectId, protocol, publicKey } = dsn;\n  return (\n    `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ''}` +\n    `@${host}${port ? `:${port}` : ''}/${path ? `${path}/` : path}${projectId}`\n  );\n}\n\n/**\n * Parses a Dsn from a given string.\n *\n * @param str A Dsn as string\n * @returns Dsn as DsnComponents\n */\nfunction dsnFromString(str) {\n  var match = DSN_REGEX.exec(str);\n\n  if (!match) {\n    throw new SentryError(`Invalid Sentry Dsn: ${str}`);\n  }\n\n  const [protocol, publicKey, pass = '', host, port = '', lastPath] = match.slice(1);\n  let path = '';\n  let projectId = lastPath;\n\n  var split = projectId.split('/');\n  if (split.length > 1) {\n    path = split.slice(0, -1).join('/');\n    projectId = split.pop() ;\n  }\n\n  if (projectId) {\n    var projectMatch = projectId.match(/^\\d+/);\n    if (projectMatch) {\n      projectId = projectMatch[0];\n    }\n  }\n\n  return dsnFromComponents({ host, pass, path, projectId, port, protocol: protocol , publicKey });\n}\n\nfunction dsnFromComponents(components) {\n  return {\n    protocol: components.protocol,\n    publicKey: components.publicKey || '',\n    pass: components.pass || '',\n    host: components.host,\n    port: components.port || '',\n    path: components.path || '',\n    projectId: components.projectId,\n  };\n}\n\nfunction validateDsn(dsn) {\n  if (!(typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {\n    return;\n  }\n\n  const { port, projectId, protocol } = dsn;\n\n  var requiredComponents = ['protocol', 'publicKey', 'host', 'projectId'];\n  requiredComponents.forEach(component => {\n    if (!dsn[component]) {\n      throw new SentryError(`Invalid Sentry Dsn: ${component} missing`);\n    }\n  });\n\n  if (!projectId.match(/^\\d+$/)) {\n    throw new SentryError(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);\n  }\n\n  if (!isValidProtocol(protocol)) {\n    throw new SentryError(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);\n  }\n\n  if (port && isNaN(parseInt(port, 10))) {\n    throw new SentryError(`Invalid Sentry Dsn: Invalid port ${port}`);\n  }\n\n  return true;\n}\n\n/** The Sentry Dsn, identifying a Sentry instance and project. */\nfunction dsn_makeDsn(from) {\n  var components = typeof from === 'string' ? dsnFromString(from) : dsnFromComponents(from);\n  validateDsn(components);\n  return components;\n}\n\n\n//# sourceMappingURL=dsn.js.map\n\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/is.js\nvar is = __webpack_require__(7597);\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/syncpromise.js\nvar syncpromise = __webpack_require__(6893);\n;// CONCATENATED MODULE: ./node_modules/@sentry/utils/esm/envelope.js\n\n\n/**\n * Creates an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nfunction createEnvelope(headers, items = []) {\n  return [headers, items] ;\n}\n\n/**\n * Add an item to an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nfunction addItemToEnvelope(envelope, newItem) {\n  const [headers, items] = envelope;\n  return [headers, [...items, newItem]] ;\n}\n\n/**\n * Convenience function to loop through the items and item types of an envelope.\n * (This function was mostly created because working with envelope types is painful at the moment)\n */\nfunction forEachEnvelopeItem(\n  envelope,\n  callback,\n) {\n  var envelopeItems = envelope[1];\n  envelopeItems.forEach((envelopeItem) => {\n    var envelopeItemType = envelopeItem[0].type;\n    callback(envelopeItem, envelopeItemType);\n  });\n}\n\nfunction encodeUTF8(input, textEncoder) {\n  var utf8 = textEncoder || new TextEncoder();\n  return utf8.encode(input);\n}\n\n/**\n * Serializes an envelope.\n */\nfunction serializeEnvelope(envelope, textEncoder) {\n  const [envHeaders, items] = envelope;\n\n  // Initially we construct our envelope as a string and only convert to binary chunks if we encounter binary data\n  let parts = JSON.stringify(envHeaders);\n\n  function append(next) {\n    if (typeof parts === 'string') {\n      parts = typeof next === 'string' ? parts + next : [encodeUTF8(parts, textEncoder), next];\n    } else {\n      parts.push(typeof next === 'string' ? encodeUTF8(next, textEncoder) : next);\n    }\n  }\n\n  for (var item of items) {\n    const [itemHeaders, payload] = item ;\n    append(`\\n${JSON.stringify(itemHeaders)}\\n`);\n    append(typeof payload === 'string' || payload instanceof Uint8Array ? payload : JSON.stringify(payload));\n  }\n\n  return typeof parts === 'string' ? parts : concatBuffers(parts);\n}\n\nfunction concatBuffers(buffers) {\n  var totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);\n\n  var merged = new Uint8Array(totalLength);\n  let offset = 0;\n  for (var buffer of buffers) {\n    merged.set(buffer, offset);\n    offset += buffer.length;\n  }\n\n  return merged;\n}\n\n/**\n * Creates attachment envelope items\n */\nfunction createAttachmentEnvelopeItem(\n  attachment,\n  textEncoder,\n) {\n  var buffer = typeof attachment.data === 'string' ? encodeUTF8(attachment.data, textEncoder) : attachment.data;\n\n  return [\n    (0,object/* dropUndefinedKeys */.Jr)({\n      type: 'attachment',\n      length: buffer.length,\n      filename: attachment.filename,\n      content_type: attachment.contentType,\n      attachment_type: attachment.attachmentType,\n    }),\n    buffer,\n  ];\n}\n\nvar ITEM_TYPE_TO_DATA_CATEGORY_MAP = {\n  session: 'session',\n  sessions: 'session',\n  attachment: 'attachment',\n  transaction: 'transaction',\n  event: 'error',\n  client_report: 'internal',\n  user_report: 'default',\n};\n\n/**\n * Maps the type of an envelope item to a data category.\n */\nfunction envelopeItemTypeToDataCategory(type) {\n  return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];\n}\n\n\n//# sourceMappingURL=envelope.js.map\n\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/time.js\nvar time = __webpack_require__(1170);\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/normalize.js + 1 modules\nvar normalize = __webpack_require__(4754);\n;// CONCATENATED MODULE: ./node_modules/@sentry/core/esm/api.js\n\n\nvar SENTRY_API_VERSION = '7';\n\n/** Returns the prefix to construct Sentry ingestion API endpoints. */\nfunction getBaseApiEndpoint(dsn) {\n  var protocol = dsn.protocol ? `${dsn.protocol}:` : '';\n  var port = dsn.port ? `:${dsn.port}` : '';\n  return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ''}/api/`;\n}\n\n/** Returns the ingest API endpoint for target. */\nfunction _getIngestEndpoint(dsn) {\n  return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/envelope/`;\n}\n\n/** Returns a URL-encoded string with auth config suitable for a query string. */\nfunction _encodedAuth(dsn, sdkInfo) {\n  return (0,object/* urlEncode */._j)({\n    // We send only the minimum set of required information. See\n    // https://github.com/getsentry/sentry-javascript/issues/2572.\n    sentry_key: dsn.publicKey,\n    sentry_version: SENTRY_API_VERSION,\n    ...(sdkInfo && { sentry_client: `${sdkInfo.name}/${sdkInfo.version}` }),\n  });\n}\n\n/**\n * Returns the envelope endpoint URL with auth in the query string.\n *\n * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.\n */\nfunction getEnvelopeEndpointWithUrlEncodedAuth(\n  dsn,\n  // TODO (v8): Remove `tunnelOrOptions` in favor of `options`, and use the substitute code below\n  // options: ClientOptions = {} as ClientOptions,\n  tunnelOrOptions = {} ,\n) {\n  // TODO (v8): Use this code instead\n  // const { tunnel, _metadata = {} } = options;\n  // return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, _metadata.sdk)}`;\n\n  var tunnel = typeof tunnelOrOptions === 'string' ? tunnelOrOptions : tunnelOrOptions.tunnel;\n  var sdkInfo =\n    typeof tunnelOrOptions === 'string' || !tunnelOrOptions._metadata ? undefined : tunnelOrOptions._metadata.sdk;\n\n  return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, sdkInfo)}`;\n}\n\n/** Returns the url to the report dialog endpoint. */\nfunction api_getReportDialogEndpoint(\n  dsnLike,\n  dialogOptions\n\n,\n) {\n  var dsn = makeDsn(dsnLike);\n  var endpoint = `${getBaseApiEndpoint(dsn)}embed/error-page/`;\n\n  let encodedOptions = `dsn=${dsnToString(dsn)}`;\n  for (var key in dialogOptions) {\n    if (key === 'dsn') {\n      continue;\n    }\n\n    if (key === 'user') {\n      var user = dialogOptions.user;\n      if (!user) {\n        continue;\n      }\n      if (user.name) {\n        encodedOptions += `&name=${encodeURIComponent(user.name)}`;\n      }\n      if (user.email) {\n        encodedOptions += `&email=${encodeURIComponent(user.email)}`;\n      }\n    } else {\n      encodedOptions += `&${encodeURIComponent(key)}=${encodeURIComponent(dialogOptions[key] )}`;\n    }\n  }\n\n  return `${endpoint}?${encodedOptions}`;\n}\n\n\n//# sourceMappingURL=api.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/core/esm/envelope.js\n\n\n/** Extract sdk info from from the API metadata */\nfunction getSdkMetadataForEnvelopeHeader(metadata) {\n  if (!metadata || !metadata.sdk) {\n    return;\n  }\n  const { name, version } = metadata.sdk;\n  return { name, version };\n}\n\n/**\n * Apply SdkInfo (name, version, packages, integrations) to the corresponding event key.\n * Merge with existing data if any.\n **/\nfunction enhanceEventWithSdkInfo(event, sdkInfo) {\n  if (!sdkInfo) {\n    return event;\n  }\n  event.sdk = event.sdk || {};\n  event.sdk.name = event.sdk.name || sdkInfo.name;\n  event.sdk.version = event.sdk.version || sdkInfo.version;\n  event.sdk.integrations = [...(event.sdk.integrations || []), ...(sdkInfo.integrations || [])];\n  event.sdk.packages = [...(event.sdk.packages || []), ...(sdkInfo.packages || [])];\n  return event;\n}\n\n/** Creates an envelope from a Session */\nfunction createSessionEnvelope(\n  session,\n  dsn,\n  metadata,\n  tunnel,\n) {\n  var sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);\n  var envelopeHeaders = {\n    sent_at: new Date().toISOString(),\n    ...(sdkInfo && { sdk: sdkInfo }),\n    ...(!!tunnel && { dsn: dsn_dsnToString(dsn) }),\n  };\n\n  var envelopeItem =\n    'aggregates' in session ? [{ type: 'sessions' }, session] : [{ type: 'session' }, session];\n\n  return createEnvelope(envelopeHeaders, [envelopeItem]);\n}\n\n/**\n * Create an Envelope from an event.\n */\nfunction createEventEnvelope(\n  event,\n  dsn,\n  metadata,\n  tunnel,\n) {\n  var sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);\n  var eventType = event.type || 'event';\n\n  const { transactionSampling } = event.sdkProcessingMetadata || {};\n  const { method: samplingMethod, rate: sampleRate } = transactionSampling || {};\n\n  enhanceEventWithSdkInfo(event, metadata && metadata.sdk);\n\n  var envelopeHeaders = createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);\n\n  // Prevent this data (which, if it exists, was used in earlier steps in the processing pipeline) from being sent to\n  // sentry. (Note: Our use of this property comes and goes with whatever we might be debugging, whatever hacks we may\n  // have temporarily added, etc. Even if we don't happen to be using it at some point in the future, let's not get rid\n  // of this `delete`, lest we miss putting it back in the next time the property is in use.)\n  delete event.sdkProcessingMetadata;\n\n  var eventItem = [\n    {\n      type: eventType,\n      sample_rates: [{ id: samplingMethod, rate: sampleRate }],\n    },\n    event,\n  ];\n  return createEnvelope(envelopeHeaders, [eventItem]);\n}\n\nfunction createEventEnvelopeHeaders(\n  event,\n  sdkInfo,\n  tunnel,\n  dsn,\n) {\n  var dynamicSamplingContext = event.sdkProcessingMetadata && event.sdkProcessingMetadata.dynamicSamplingContext;\n\n  return {\n    event_id: event.event_id ,\n    sent_at: new Date().toISOString(),\n    ...(sdkInfo && { sdk: sdkInfo }),\n    ...(!!tunnel && { dsn: dsn_dsnToString(dsn) }),\n    ...(event.type === 'transaction' &&\n      dynamicSamplingContext && {\n        trace: (0,object/* dropUndefinedKeys */.Jr)({ ...dynamicSamplingContext }),\n      }),\n  };\n}\n\n\n//# sourceMappingURL=envelope.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/core/esm/baseclient.js\n\n\n\n\n\n\nvar ALREADY_SEEN_ERROR = \"Not capturing exception because it's already been captured.\";\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event, it is passed through\n * {@link BaseClient._prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(options);\n *   }\n *\n *   // ...\n * }\n */\nclass BaseClient {\n  /** Options passed to the SDK. */\n  \n\n  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n  \n\n  /** Array of set up integrations. */\n   __init() {this._integrations = {};}\n\n  /** Indicates whether this client's integrations have been set up. */\n   __init2() {this._integrationsInitialized = false;}\n\n  /** Number of calls being processed */\n   __init3() {this._numProcessing = 0;}\n\n  /** Holds flushable  */\n   __init4() {this._outcomes = {};}\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param options Options for the client.\n   */\n   constructor(options) {;BaseClient.prototype.__init.call(this);BaseClient.prototype.__init2.call(this);BaseClient.prototype.__init3.call(this);BaseClient.prototype.__init4.call(this);\n    this._options = options;\n    if (options.dsn) {\n      this._dsn = dsn_makeDsn(options.dsn);\n      var url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options);\n      this._transport = options.transport({\n        recordDroppedEvent: this.recordDroppedEvent.bind(this),\n        ...options.transportOptions,\n        url,\n      });\n    } else {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.warn */.kg.warn('No DSN provided, client will not do anything.');\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n     captureException(exception, hint, scope) {\n    // ensure we haven't captured this very object before\n    if ((0,misc/* checkOrSetAlreadyCaught */.YO)(exception)) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.log */.kg.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n\n    let eventId = hint && hint.event_id;\n\n    this._process(\n      this.eventFromException(exception, hint)\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureMessage(\n    message,\n        level,\n    hint,\n    scope,\n  ) {\n    let eventId = hint && hint.event_id;\n\n    var promisedEvent = (0,is/* isPrimitive */.pt)(message)\n      ? this.eventFromMessage(String(message), level, hint)\n      : this.eventFromException(message, hint);\n\n    this._process(\n      promisedEvent\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureEvent(event, hint, scope) {\n    // ensure we haven't captured this very object before\n    if (hint && hint.originalException && (0,misc/* checkOrSetAlreadyCaught */.YO)(hint.originalException)) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.log */.kg.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n\n    let eventId = hint && hint.event_id;\n\n    this._process(\n      this._captureEvent(event, hint, scope).then(result => {\n        eventId = result;\n      }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureSession(session) {\n    if (!this._isEnabled()) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.warn */.kg.warn('SDK not enabled, will not capture session.');\n      return;\n    }\n\n    if (!(typeof session.release === 'string')) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.warn */.kg.warn('Discarded session because of missing or non-string release');\n    } else {\n      this.sendSession(session);\n      // After sending, we set init false to indicate it's not the first occurrence\n      (0,esm_session/* updateSession */.CT)(session, { init: false });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getDsn() {\n    return this._dsn;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getOptions() {\n    return this._options;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getTransport() {\n    return this._transport;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   flush(timeout) {\n    var transport = this._transport;\n    if (transport) {\n      return this._isClientDoneProcessing(timeout).then(clientFinished => {\n        return transport.flush(timeout).then(transportFlushed => clientFinished && transportFlushed);\n      });\n    } else {\n      return (0,syncpromise/* resolvedSyncPromise */.WD)(true);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   close(timeout) {\n    return this.flush(timeout).then(result => {\n      this.getOptions().enabled = false;\n      return result;\n    });\n  }\n\n  /**\n   * Sets up the integrations\n   */\n   setupIntegrations() {\n    if (this._isEnabled() && !this._integrationsInitialized) {\n      this._integrations = setupIntegrations(this._options.integrations);\n      this._integrationsInitialized = true;\n    }\n  }\n\n  /**\n   * Gets an installed integration by its `id`.\n   *\n   * @returns The installed integration or `undefined` if no integration with that `id` was installed.\n   */\n   getIntegrationById(integrationId) {\n    return this._integrations[integrationId];\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getIntegration(integration) {\n    try {\n      return (this._integrations[integration.id] ) || null;\n    } catch (_oO) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.warn */.kg.warn(`Cannot retrieve integration ${integration.id} from the current Client`);\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   sendEvent(event, hint = {}) {\n    if (this._dsn) {\n      let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);\n\n      for (var attachment of hint.attachments || []) {\n        env = addItemToEnvelope(\n          env,\n          createAttachmentEnvelopeItem(\n            attachment,\n            this._options.transportOptions && this._options.transportOptions.textEncoder,\n          ),\n        );\n      }\n\n      this._sendEnvelope(env);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   sendSession(session) {\n    if (this._dsn) {\n      var env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);\n      this._sendEnvelope(env);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   recordDroppedEvent(reason, category) {\n    if (this._options.sendClientReports) {\n      // We want to track each category (error, transaction, session) separately\n      // but still keep the distinction between different type of outcomes.\n      // We could use nested maps, but it's much easier to read and type this way.\n      // A correct type for map-based implementation if we want to go that route\n      // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n      // With typescript 4.1 we could even use template literal types\n      var key = `${reason}:${category}`;\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.log */.kg.log(`Adding outcome: \"${key}\"`);\n\n      // The following works because undefined + 1 === NaN and NaN is falsy\n      this._outcomes[key] = this._outcomes[key] + 1 || 1;\n    }\n  }\n\n  /** Updates existing session based on the provided event */\n   _updateSessionFromEvent(session, event) {\n    let crashed = false;\n    let errored = false;\n    var exceptions = event.exception && event.exception.values;\n\n    if (exceptions) {\n      errored = true;\n\n      for (var ex of exceptions) {\n        var mechanism = ex.mechanism;\n        if (mechanism && mechanism.handled === false) {\n          crashed = true;\n          break;\n        }\n      }\n    }\n\n    // A session is updated and that session update is sent in only one of the two following scenarios:\n    // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update\n    // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update\n    var sessionNonTerminal = session.status === 'ok';\n    var shouldUpdateAndSend = (sessionNonTerminal && session.errors === 0) || (sessionNonTerminal && crashed);\n\n    if (shouldUpdateAndSend) {\n      (0,esm_session/* updateSession */.CT)(session, {\n        ...(crashed && { status: 'crashed' }),\n        errors: session.errors || Number(errored || crashed),\n      });\n      this.captureSession(session);\n    }\n  }\n\n  /**\n   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying\n   * \"no\" (resolving to `false`) in order to give the client a chance to potentially finish first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not\n   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and\n   * `false` otherwise\n   */\n   _isClientDoneProcessing(timeout) {\n    return new syncpromise/* SyncPromise */.cW(resolve => {\n      let ticked = 0;\n      var tick = 1;\n\n      var interval = setInterval(() => {\n        if (this._numProcessing == 0) {\n          clearInterval(interval);\n          resolve(true);\n        } else {\n          ticked += tick;\n          if (timeout && ticked >= timeout) {\n            clearInterval(interval);\n            resolve(false);\n          }\n        }\n      }, tick);\n    });\n  }\n\n  /** Determines whether this SDK is enabled and a valid Dsn is present. */\n   _isEnabled() {\n    return this.getOptions().enabled !== false && this._dsn !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n   _prepareEvent(event, hint, scope) {\n    const { normalizeDepth = 3, normalizeMaxBreadth = 1000 } = this.getOptions();\n    var prepared = {\n      ...event,\n      event_id: event.event_id || hint.event_id || (0,misc/* uuid4 */.DM)(),\n      timestamp: event.timestamp || (0,time/* dateTimestampInSeconds */.yW)(),\n    };\n\n    this._applyClientOptions(prepared);\n    this._applyIntegrationsMetadata(prepared);\n\n    // If we have scope given to us, use it as the base for further modifications.\n    // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n    let finalScope = scope;\n    if (hint.captureContext) {\n      finalScope = esm_scope/* Scope.clone */.s.clone(finalScope).update(hint.captureContext);\n    }\n\n    // We prepare the result here with a resolved Event.\n    let result = (0,syncpromise/* resolvedSyncPromise */.WD)(prepared);\n\n    // This should be the last thing called, since we want that\n    // {@link Hub.addEventProcessor} gets the finished prepared event.\n    if (finalScope) {\n      // Collect attachments from the hint and scope\n      var attachments = [...(hint.attachments || []), ...finalScope.getAttachments()];\n\n      if (attachments.length) {\n        hint.attachments = attachments;\n      }\n\n      // In case we have a hub we reassign it.\n      result = finalScope.applyToEvent(prepared, hint);\n    }\n\n    return result.then(evt => {\n      if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n        return this._normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n      }\n      return evt;\n    });\n  }\n\n  /**\n   * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n   * Normalized keys:\n   * - `breadcrumbs.data`\n   * - `user`\n   * - `contexts`\n   * - `extra`\n   * @param event Event\n   * @returns Normalized event\n   */\n   _normalizeEvent(event, depth, maxBreadth) {\n    if (!event) {\n      return null;\n    }\n\n    var normalized = {\n      ...event,\n      ...(event.breadcrumbs && {\n        breadcrumbs: event.breadcrumbs.map(b => ({\n          ...b,\n          ...(b.data && {\n            data: (0,normalize/* normalize */.Fv)(b.data, depth, maxBreadth),\n          }),\n        })),\n      }),\n      ...(event.user && {\n        user: (0,normalize/* normalize */.Fv)(event.user, depth, maxBreadth),\n      }),\n      ...(event.contexts && {\n        contexts: (0,normalize/* normalize */.Fv)(event.contexts, depth, maxBreadth),\n      }),\n      ...(event.extra && {\n        extra: (0,normalize/* normalize */.Fv)(event.extra, depth, maxBreadth),\n      }),\n    };\n\n    // event.contexts.trace stores information about a Transaction. Similarly,\n    // event.spans[] stores information about child Spans. Given that a\n    // Transaction is conceptually a Span, normalization should apply to both\n    // Transactions and Spans consistently.\n    // For now the decision is to skip normalization of Transactions and Spans,\n    // so this block overwrites the normalized event to add back the original\n    // Transaction information prior to normalization.\n    if (event.contexts && event.contexts.trace && normalized.contexts) {\n      normalized.contexts.trace = event.contexts.trace;\n\n      // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n      if (event.contexts.trace.data) {\n        normalized.contexts.trace.data = (0,normalize/* normalize */.Fv)(event.contexts.trace.data, depth, maxBreadth);\n      }\n    }\n\n    // event.spans[].data may contain circular/dangerous data so we need to normalize it\n    if (event.spans) {\n      normalized.spans = event.spans.map(span => {\n        // We cannot use the spread operator here because `toJSON` on `span` is non-enumerable\n        if (span.data) {\n          span.data = (0,normalize/* normalize */.Fv)(span.data, depth, maxBreadth);\n        }\n        return span;\n      });\n    }\n\n    return normalized;\n  }\n\n  /**\n   *  Enhances event using the client configuration.\n   *  It takes care of all \"static\" values like environment, release and `dist`,\n   *  as well as truncating overly long values.\n   * @param event event instance to be enhanced\n   */\n   _applyClientOptions(event) {\n    var options = this.getOptions();\n    const { environment, release, dist, maxValueLength = 250 } = options;\n\n    if (!('environment' in event)) {\n      event.environment = 'environment' in options ? environment : 'production';\n    }\n\n    if (event.release === undefined && release !== undefined) {\n      event.release = release;\n    }\n\n    if (event.dist === undefined && dist !== undefined) {\n      event.dist = dist;\n    }\n\n    if (event.message) {\n      event.message = (0,string/* truncate */.$G)(event.message, maxValueLength);\n    }\n\n    var exception = event.exception && event.exception.values && event.exception.values[0];\n    if (exception && exception.value) {\n      exception.value = (0,string/* truncate */.$G)(exception.value, maxValueLength);\n    }\n\n    var request = event.request;\n    if (request && request.url) {\n      request.url = (0,string/* truncate */.$G)(request.url, maxValueLength);\n    }\n  }\n\n  /**\n   * This function adds all used integrations to the SDK info in the event.\n   * @param event The event that will be filled with all integrations.\n   */\n   _applyIntegrationsMetadata(event) {\n    var integrationsArray = Object.keys(this._integrations);\n    if (integrationsArray.length > 0) {\n      event.sdk = event.sdk || {};\n      event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationsArray];\n    }\n  }\n\n  /**\n   * Processes the event and logs an error in case of rejection\n   * @param event\n   * @param hint\n   * @param scope\n   */\n   _captureEvent(event, hint = {}, scope) {\n    return this._processEvent(event, hint, scope).then(\n      finalEvent => {\n        return finalEvent.event_id;\n      },\n      reason => {\n        if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {\n          // If something's gone wrong, log the error as a warning. If it's just us having used a `SentryError` for\n          // control flow, log just the message (no stack) as a log-level log.\n          var sentryError = reason ;\n          if (sentryError.logLevel === 'log') {\n            esm_logger/* logger.log */.kg.log(sentryError.message);\n          } else {\n            esm_logger/* logger.warn */.kg.warn(sentryError);\n          }\n        }\n        return undefined;\n      },\n    );\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n   _processEvent(event, hint, scope) {\n    const { beforeSend, sampleRate } = this.getOptions();\n\n    if (!this._isEnabled()) {\n      return (0,syncpromise/* rejectedSyncPromise */.$2)(new SentryError('SDK not enabled, will not capture event.', 'log'));\n    }\n\n    var isTransaction = event.type === 'transaction';\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n    if (!isTransaction && typeof sampleRate === 'number' && Math.random() > sampleRate) {\n      this.recordDroppedEvent('sample_rate', 'error');\n      return (0,syncpromise/* rejectedSyncPromise */.$2)(\n        new SentryError(\n          `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,\n          'log',\n        ),\n      );\n    }\n\n    return this._prepareEvent(event, hint, scope)\n      .then(prepared => {\n        if (prepared === null) {\n          this.recordDroppedEvent('event_processor', event.type || 'error');\n          throw new SentryError('An event processor returned null, will not send event.', 'log');\n        }\n\n        var isInternalException = hint.data && (hint.data ).__sentry__ === true;\n        if (isInternalException || isTransaction || !beforeSend) {\n          return prepared;\n        }\n\n        var beforeSendResult = beforeSend(prepared, hint);\n        return _ensureBeforeSendRv(beforeSendResult);\n      })\n      .then(processedEvent => {\n        if (processedEvent === null) {\n          this.recordDroppedEvent('before_send', event.type || 'error');\n          throw new SentryError('`beforeSend` returned `null`, will not send event.', 'log');\n        }\n\n        var session = scope && scope.getSession();\n        if (!isTransaction && session) {\n          this._updateSessionFromEvent(session, processedEvent);\n        }\n\n        // None of the Sentry built event processor will update transaction name,\n        // so if the transaction name has been changed by an event processor, we know\n        // it has to come from custom event processor added by a user\n        var transactionInfo = processedEvent.transaction_info;\n        if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {\n          var source = 'custom';\n          processedEvent.transaction_info = {\n            ...transactionInfo,\n            source,\n            changes: [\n              ...transactionInfo.changes,\n              {\n                source,\n                // use the same timestamp as the processed event.\n                timestamp: processedEvent.timestamp ,\n                propagations: transactionInfo.propagations,\n              },\n            ],\n          };\n        }\n\n        this.sendEvent(processedEvent, hint);\n        return processedEvent;\n      })\n      .then(null, reason => {\n        if (reason instanceof SentryError) {\n          throw reason;\n        }\n\n        this.captureException(reason, {\n          data: {\n            __sentry__: true,\n          },\n          originalException: reason ,\n        });\n        throw new SentryError(\n          `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: ${reason}`,\n        );\n      });\n  }\n\n  /**\n   * Occupies the client with processing and event\n   */\n   _process(promise) {\n    this._numProcessing += 1;\n    void promise.then(\n      value => {\n        this._numProcessing -= 1;\n        return value;\n      },\n      reason => {\n        this._numProcessing -= 1;\n        return reason;\n      },\n    );\n  }\n\n  /**\n   * @inheritdoc\n   */\n   _sendEnvelope(envelope) {\n    if (this._transport && this._dsn) {\n      this._transport.send(envelope).then(null, reason => {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.error */.kg.error('Error while sending event:', reason);\n      });\n    } else {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.error */.kg.error('Transport disabled');\n    }\n  }\n\n  /**\n   * Clears outcomes on this client and returns them.\n   */\n   _clearOutcomes() {\n    var outcomes = this._outcomes;\n    this._outcomes = {};\n    return Object.keys(outcomes).map(key => {\n      const [reason, category] = key.split(':') ;\n      return {\n        reason,\n        category,\n        quantity: outcomes[key],\n      };\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n    \n\n}\n\n/**\n * Verifies that return value of configured `beforeSend` is of expected type.\n */\nfunction _ensureBeforeSendRv(rv) {\n  var nullErr = '`beforeSend` method has to return `null` or a valid event.';\n  if ((0,is/* isThenable */.J8)(rv)) {\n    return rv.then(\n      event => {\n        if (!((0,is/* isPlainObject */.PO)(event) || event === null)) {\n          throw new SentryError(nullErr);\n        }\n        return event;\n      },\n      e => {\n        throw new SentryError(`beforeSend rejected with ${e}`);\n      },\n    );\n  } else if (!((0,is/* isPlainObject */.PO)(rv) || rv === null)) {\n    throw new SentryError(nullErr);\n  }\n  return rv;\n}\n\n\n//# sourceMappingURL=baseclient.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/utils/esm/clientreport.js\n\n\n\n/**\n * Creates client report envelope\n * @param discarded_events An array of discard events\n * @param dsn A DSN that can be set on the header. Optional.\n */\nfunction createClientReportEnvelope(\n  discarded_events,\n  dsn,\n  timestamp,\n) {\n  var clientReportItem = [\n    { type: 'client_report' },\n    {\n      timestamp: timestamp || (0,time/* dateTimestampInSeconds */.yW)(),\n      discarded_events,\n    },\n  ];\n  return createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);\n}\n\n\n//# sourceMappingURL=clientreport.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/browser/esm/eventbuilder.js\n\n\n\n/**\n * This function creates an exception from a JavaScript Error\n */\nfunction exceptionFromError(stackParser, ex) {\n  // Get the frames first since Opera can lose the stack if we touch anything else first\n  var frames = parseStackFrames(stackParser, ex);\n\n  var exception = {\n    type: ex && ex.name,\n    value: extractMessage(ex),\n  };\n\n  if (frames.length) {\n    exception.stacktrace = { frames };\n  }\n\n  if (exception.type === undefined && exception.value === '') {\n    exception.value = 'Unrecoverable error caught';\n  }\n\n  return exception;\n}\n\n/**\n * @hidden\n */\nfunction eventFromPlainObject(\n  stackParser,\n  exception,\n  syntheticException,\n  isUnhandledRejection,\n) {\n  var hub = (0,esm_hub/* getCurrentHub */.Gd)();\n  var client = hub.getClient();\n  var normalizeDepth = client && client.getOptions().normalizeDepth;\n\n  var event = {\n    exception: {\n      values: [\n        {\n          type: (0,is/* isEvent */.cO)(exception) ? exception.constructor.name : isUnhandledRejection ? 'UnhandledRejection' : 'Error',\n          value: `Non-Error ${\n            isUnhandledRejection ? 'promise rejection' : 'exception'\n          } captured with keys: ${(0,object/* extractExceptionKeysForMessage */.zf)(exception)}`,\n        },\n      ],\n    },\n    extra: {\n      __serialized__: (0,normalize/* normalizeToSize */.Qy)(exception, normalizeDepth),\n    },\n  };\n\n  if (syntheticException) {\n    var frames = parseStackFrames(stackParser, syntheticException);\n    if (frames.length) {\n      // event.exception.values[0] has been set above\n      (event.exception ).values[0].stacktrace = { frames };\n    }\n  }\n\n  return event;\n}\n\n/**\n * @hidden\n */\nfunction eventFromError(stackParser, ex) {\n  return {\n    exception: {\n      values: [exceptionFromError(stackParser, ex)],\n    },\n  };\n}\n\n/** Parses stack frames from an error */\nfunction parseStackFrames(\n  stackParser,\n  ex,\n) {\n  // Access and store the stacktrace property before doing ANYTHING\n  // else to it because Opera is not very good at providing it\n  // reliably in other circumstances.\n  var stacktrace = ex.stacktrace || ex.stack || '';\n\n  var popSize = getPopSize(ex);\n\n  try {\n    return stackParser(stacktrace, popSize);\n  } catch (e) {\n    // no-empty\n  }\n\n  return [];\n}\n\n// Based on our own mapping pattern - https://github.com/getsentry/sentry/blob/9f08305e09866c8bd6d0c24f5b0aabdd7dd6c59c/src/sentry/lang/javascript/errormapping.py#L83-L108\nvar reactMinifiedRegexp = /Minified React error #\\d+;/i;\n\nfunction getPopSize(ex) {\n  if (ex) {\n    if (typeof ex.framesToPop === 'number') {\n      return ex.framesToPop;\n    }\n\n    if (reactMinifiedRegexp.test(ex.message)) {\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * There are cases where stacktrace.message is an Event object\n * https://github.com/getsentry/sentry-javascript/issues/1949\n * In this specific case we try to extract stacktrace.message.error.message\n */\nfunction extractMessage(ex) {\n  var message = ex && ex.message;\n  if (!message) {\n    return 'No error message';\n  }\n  if (message.error && typeof message.error.message === 'string') {\n    return message.error.message;\n  }\n  return message;\n}\n\n/**\n * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.\n * @hidden\n */\nfunction eventFromException(\n  stackParser,\n  exception,\n  hint,\n  attachStacktrace,\n) {\n  var syntheticException = (hint && hint.syntheticException) || undefined;\n  var event = eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace);\n  (0,misc/* addExceptionMechanism */.EG)(event); // defaults to { type: 'generic', handled: true }\n  event.level = 'error';\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return (0,syncpromise/* resolvedSyncPromise */.WD)(event);\n}\n\n/**\n * Builds and Event from a Message\n * @hidden\n */\nfunction eventFromMessage(\n  stackParser,\n  message,\n    level = 'info',\n  hint,\n  attachStacktrace,\n) {\n  var syntheticException = (hint && hint.syntheticException) || undefined;\n  var event = eventFromString(stackParser, message, syntheticException, attachStacktrace);\n  event.level = level;\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return (0,syncpromise/* resolvedSyncPromise */.WD)(event);\n}\n\n/**\n * @hidden\n */\nfunction eventFromUnknownInput(\n  stackParser,\n  exception,\n  syntheticException,\n  attachStacktrace,\n  isUnhandledRejection,\n) {\n  let event;\n\n  if ((0,is/* isErrorEvent */.VW)(exception ) && (exception ).error) {\n    // If it is an ErrorEvent with `error` property, extract it to get actual Error\n    var errorEvent = exception ;\n    return eventFromError(stackParser, errorEvent.error );\n  }\n\n  // If it is a `DOMError` (which is a legacy API, but still supported in some browsers) then we just extract the name\n  // and message, as it doesn't provide anything else. According to the spec, all `DOMExceptions` should also be\n  // `Error`s, but that's not the case in IE11, so in that case we treat it the same as we do a `DOMError`.\n  //\n  // https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n  // https://developer.mozilla.org/en-US/docs/Web/API/DOMException\n  // https://webidl.spec.whatwg.org/#es-DOMException-specialness\n  if ((0,is/* isDOMError */.TX)(exception ) || (0,is/* isDOMException */.fm)(exception )) {\n    var domException = exception ;\n\n    if ('stack' in (exception )) {\n      event = eventFromError(stackParser, exception );\n    } else {\n      var name = domException.name || ((0,is/* isDOMError */.TX)(domException) ? 'DOMError' : 'DOMException');\n      var message = domException.message ? `${name}: ${domException.message}` : name;\n      event = eventFromString(stackParser, message, syntheticException, attachStacktrace);\n      (0,misc/* addExceptionTypeValue */.Db)(event, message);\n    }\n    if ('code' in domException) {\n      event.tags = { ...event.tags, 'DOMException.code': `${domException.code}` };\n    }\n\n    return event;\n  }\n  if ((0,is/* isError */.VZ)(exception)) {\n    // we have a real Error object, do nothing\n    return eventFromError(stackParser, exception);\n  }\n  if ((0,is/* isPlainObject */.PO)(exception) || (0,is/* isEvent */.cO)(exception)) {\n    // If it's a plain object or an instance of `Event` (the built-in JS kind, not this SDK's `Event` type), serialize\n    // it manually. This will allow us to group events based on top-level keys which is much better than creating a new\n    // group on any key/value change.\n    var objectException = exception ;\n    event = eventFromPlainObject(stackParser, objectException, syntheticException, isUnhandledRejection);\n    (0,misc/* addExceptionMechanism */.EG)(event, {\n      synthetic: true,\n    });\n    return event;\n  }\n\n  // If none of previous checks were valid, then it means that it's not:\n  // - an instance of DOMError\n  // - an instance of DOMException\n  // - an instance of Event\n  // - an instance of Error\n  // - a valid ErrorEvent (one with an error property)\n  // - a plain Object\n  //\n  // So bail out and capture it as a simple message:\n  event = eventFromString(stackParser, exception , syntheticException, attachStacktrace);\n  (0,misc/* addExceptionTypeValue */.Db)(event, `${exception}`, undefined);\n  (0,misc/* addExceptionMechanism */.EG)(event, {\n    synthetic: true,\n  });\n\n  return event;\n}\n\n/**\n * @hidden\n */\nfunction eventFromString(\n  stackParser,\n  input,\n  syntheticException,\n  attachStacktrace,\n) {\n  var event = {\n    message: input,\n  };\n\n  if (attachStacktrace && syntheticException) {\n    var frames = parseStackFrames(stackParser, syntheticException);\n    if (frames.length) {\n      event.exception = {\n        values: [{ value: input, stacktrace: { frames } }],\n      };\n    }\n  }\n\n  return event;\n}\n\n\n//# sourceMappingURL=eventbuilder.js.map\n\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/browser.js\nvar browser = __webpack_require__(8464);\n;// CONCATENATED MODULE: ./node_modules/@sentry/utils/esm/severity.js\n// Note: Ideally the `SeverityLevel` type would be derived from `validSeverityLevels`, but that would mean either\n//\n// a) moving `validSeverityLevels` to `@sentry/types`,\n// b) moving the`SeverityLevel` type here, or\n// c) importing `validSeverityLevels` from here into `@sentry/types`.\n//\n// Option A would make `@sentry/types` a runtime dependency of `@sentry/utils` (not good), and options B and C would\n// create a circular dependency between `@sentry/types` and `@sentry/utils` (also not good). So a TODO accompanying the\n// type, reminding anyone who changes it to change this list also, will have to do.\n\nvar validSeverityLevels = ['fatal', 'error', 'warning', 'log', 'info', 'debug'];\n\n/**\n * Converts a string-based level into a member of the deprecated {@link Severity} enum.\n *\n * @deprecated `severityFromString` is deprecated. Please use `severityLevelFromString` instead.\n *\n * @param level String representation of Severity\n * @returns Severity\n */\nfunction severityFromString(level) {\n  return severityLevelFromString(level) ;\n}\n\n/**\n * Converts a string-based level into a `SeverityLevel`, normalizing it along the way.\n *\n * @param level String representation of desired `SeverityLevel`.\n * @returns The `SeverityLevel` corresponding to the given string, or 'log' if the string isn't a valid level.\n */\nfunction severityLevelFromString(level) {\n  return (level === 'warn' ? 'warning' : validSeverityLevels.includes(level) ? level : 'log') ;\n}\n\n\n//# sourceMappingURL=severity.js.map\n\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/url.js\nvar url = __webpack_require__(6956);\n;// CONCATENATED MODULE: ./node_modules/@sentry/browser/esm/integrations/breadcrumbs.js\n\n\n\n/** JSDoc */\n\nvar BREADCRUMB_INTEGRATION_ID = 'Breadcrumbs';\n\n/**\n * Default Breadcrumbs instrumentations\n * TODO: Deprecated - with v6, this will be renamed to `Instrument`\n */\nclass Breadcrumbs  {\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = BREADCRUMB_INTEGRATION_ID;}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = Breadcrumbs.id;}\n\n  /**\n   * Options of the breadcrumbs integration.\n   */\n  // This field is public, because we use it in the browser client to check if the `sentry` option is enabled.\n  \n\n  /**\n   * @inheritDoc\n   */\n   constructor(options) {;Breadcrumbs.prototype.__init.call(this);\n    this.options = {\n      console: true,\n      dom: true,\n      fetch: true,\n      history: true,\n      sentry: true,\n      xhr: true,\n      ...options,\n    };\n  }\n\n  /**\n   * Instrument browser built-ins w/ breadcrumb capturing\n   *  - Console API\n   *  - DOM API (click/typing)\n   *  - XMLHttpRequest API\n   *  - Fetch API\n   *  - History API\n   */\n   setupOnce() {\n    if (this.options.console) {\n      (0,instrument/* addInstrumentationHandler */.o)('console', _consoleBreadcrumb);\n    }\n    if (this.options.dom) {\n      (0,instrument/* addInstrumentationHandler */.o)('dom', _domBreadcrumb(this.options.dom));\n    }\n    if (this.options.xhr) {\n      (0,instrument/* addInstrumentationHandler */.o)('xhr', _xhrBreadcrumb);\n    }\n    if (this.options.fetch) {\n      (0,instrument/* addInstrumentationHandler */.o)('fetch', _fetchBreadcrumb);\n    }\n    if (this.options.history) {\n      (0,instrument/* addInstrumentationHandler */.o)('history', _historyBreadcrumb);\n    }\n  }\n} Breadcrumbs.__initStatic();\n\n/**\n * A HOC that creaes a function that creates breadcrumbs from DOM API calls.\n * This is a HOC so that we get access to dom options in the closure.\n */\nfunction _domBreadcrumb(dom) {\n    function _innerDomBreadcrumb(handlerData) {\n    let target;\n    let keyAttrs = typeof dom === 'object' ? dom.serializeAttribute : undefined;\n\n    if (typeof keyAttrs === 'string') {\n      keyAttrs = [keyAttrs];\n    }\n\n    // Accessing event.target can throw (see getsentry/raven-js#838, #768)\n    try {\n      target = handlerData.event.target\n        ? (0,browser/* htmlTreeAsString */.Rt)(handlerData.event.target , keyAttrs)\n        : (0,browser/* htmlTreeAsString */.Rt)(handlerData.event , keyAttrs);\n    } catch (e) {\n      target = '<unknown>';\n    }\n\n    if (target.length === 0) {\n      return;\n    }\n\n    (0,esm_hub/* getCurrentHub */.Gd)().addBreadcrumb(\n      {\n        category: `ui.${handlerData.name}`,\n        message: target,\n      },\n      {\n        event: handlerData.event,\n        name: handlerData.name,\n        global: handlerData.global,\n      },\n    );\n  }\n\n  return _innerDomBreadcrumb;\n}\n\n/**\n * Creates breadcrumbs from console API calls\n */\nfunction _consoleBreadcrumb(handlerData) {\n  var breadcrumb = {\n    category: 'console',\n    data: {\n      arguments: handlerData.args,\n      logger: 'console',\n    },\n    level: severityLevelFromString(handlerData.level),\n    message: (0,string/* safeJoin */.nK)(handlerData.args, ' '),\n  };\n\n  if (handlerData.level === 'assert') {\n    if (handlerData.args[0] === false) {\n      breadcrumb.message = `Assertion failed: ${(0,string/* safeJoin */.nK)(handlerData.args.slice(1), ' ') || 'console.assert'}`;\n      breadcrumb.data.arguments = handlerData.args.slice(1);\n    } else {\n      // Don't capture a breadcrumb for passed assertions\n      return;\n    }\n  }\n\n  (0,esm_hub/* getCurrentHub */.Gd)().addBreadcrumb(breadcrumb, {\n    input: handlerData.args,\n    level: handlerData.level,\n  });\n}\n\n/**\n * Creates breadcrumbs from XHR API calls\n */\nfunction _xhrBreadcrumb(handlerData) {\n  if (handlerData.endTimestamp) {\n    // We only capture complete, non-sentry requests\n    if (handlerData.xhr.__sentry_own_request__) {\n      return;\n    }\n\n    const { method, url, status_code, body } = handlerData.xhr.__sentry_xhr__ || {};\n\n    (0,esm_hub/* getCurrentHub */.Gd)().addBreadcrumb(\n      {\n        category: 'xhr',\n        data: {\n          method,\n          url,\n          status_code,\n        },\n        type: 'http',\n      },\n      {\n        xhr: handlerData.xhr,\n        input: body,\n      },\n    );\n\n    return;\n  }\n}\n\n/**\n * Creates breadcrumbs from fetch API calls\n */\nfunction _fetchBreadcrumb(handlerData) {\n  // We only capture complete fetch requests\n  if (!handlerData.endTimestamp) {\n    return;\n  }\n\n  if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === 'POST') {\n    // We will not create breadcrumbs for fetch requests that contain `sentry_key` (internal sentry requests)\n    return;\n  }\n\n  if (handlerData.error) {\n    (0,esm_hub/* getCurrentHub */.Gd)().addBreadcrumb(\n      {\n        category: 'fetch',\n        data: handlerData.fetchData,\n        level: 'error',\n        type: 'http',\n      },\n      {\n        data: handlerData.error,\n        input: handlerData.args,\n      },\n    );\n  } else {\n    (0,esm_hub/* getCurrentHub */.Gd)().addBreadcrumb(\n      {\n        category: 'fetch',\n        data: {\n          ...handlerData.fetchData,\n          status_code: handlerData.response.status,\n        },\n        type: 'http',\n      },\n      {\n        input: handlerData.args,\n        response: handlerData.response,\n      },\n    );\n  }\n}\n\n/**\n * Creates breadcrumbs from history API calls\n */\nfunction _historyBreadcrumb(handlerData) {\n  var global = (0,esm_global/* getGlobalObject */.R)();\n  let from = handlerData.from;\n  let to = handlerData.to;\n  var parsedLoc = (0,url/* parseUrl */.en)(global.location.href);\n  let parsedFrom = (0,url/* parseUrl */.en)(from);\n  var parsedTo = (0,url/* parseUrl */.en)(to);\n\n  // Initial pushState doesn't provide `from` information\n  if (!parsedFrom.path) {\n    parsedFrom = parsedLoc;\n  }\n\n  // Use only the path component of the URL if the URL matches the current\n  // document (almost all the time when using pushState)\n  if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {\n    to = parsedTo.relative;\n  }\n  if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {\n    from = parsedFrom.relative;\n  }\n\n  (0,esm_hub/* getCurrentHub */.Gd)().addBreadcrumb({\n    category: 'navigation',\n    data: {\n      from,\n      to,\n    },\n  });\n}\n\n\n//# sourceMappingURL=breadcrumbs.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/browser/esm/transports/utils.js\n\n\nvar global = (0,esm_global/* getGlobalObject */.R)();\nlet cachedFetchImpl;\n\n/**\n * A special usecase for incorrectly wrapped Fetch APIs in conjunction with ad-blockers.\n * Whenever someone wraps the Fetch API and returns the wrong promise chain,\n * this chain becomes orphaned and there is no possible way to capture it's rejections\n * other than allowing it bubble up to this very handler. eg.\n *\n * var f = window.fetch;\n * window.fetch = function () {\n *   var p = f.apply(this, arguments);\n *\n *   p.then(function() {\n *     console.log('hi.');\n *   });\n *\n *   return p;\n * }\n *\n * `p.then(function () { ... })` is producing a completely separate promise chain,\n * however, what's returned is `p` - the result of original `fetch` call.\n *\n * This mean, that whenever we use the Fetch API to send our own requests, _and_\n * some ad-blocker blocks it, this orphaned chain will _always_ reject,\n * effectively causing another event to be captured.\n * This makes a whole process become an infinite loop, which we need to somehow\n * deal with, and break it in one way or another.\n *\n * To deal with this issue, we are making sure that we _always_ use the real\n * browser Fetch API, instead of relying on what `window.fetch` exposes.\n * The only downside to this would be missing our own requests as breadcrumbs,\n * but because we are already not doing this, it should be just fine.\n *\n * Possible failed fetch error messages per-browser:\n *\n * Chrome:  Failed to fetch\n * Edge:    Failed to Fetch\n * Firefox: NetworkError when attempting to fetch resource\n * Safari:  resource blocked by content blocker\n */\nfunction getNativeFetchImplementation() {\n  if (cachedFetchImpl) {\n    return cachedFetchImpl;\n  }\n\n  // Fast path to avoid DOM I/O\n  if ((0,supports/* isNativeFetch */.Du)(global.fetch)) {\n    return (cachedFetchImpl = global.fetch.bind(global));\n  }\n\n  var document = global.document;\n  let fetchImpl = global.fetch;\n    if (document && typeof document.createElement === 'function') {\n    try {\n      var sandbox = document.createElement('iframe');\n      sandbox.hidden = true;\n      document.head.appendChild(sandbox);\n      var contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow.fetch) {\n        fetchImpl = contentWindow.fetch;\n      }\n      document.head.removeChild(sandbox);\n    } catch (e) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        esm_logger/* logger.warn */.kg.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', e);\n    }\n  }\n\n  return (cachedFetchImpl = fetchImpl.bind(global));\n  }\n\n/**\n * Sends sdk client report using sendBeacon or fetch as a fallback if available\n *\n * @param url report endpoint\n * @param body report payload\n */\nfunction sendReport(url, body) {\n  var isRealNavigator = Object.prototype.toString.call(global && global.navigator) === '[object Navigator]';\n  var hasSendBeacon = isRealNavigator && typeof global.navigator.sendBeacon === 'function';\n\n  if (hasSendBeacon) {\n    // Prevent illegal invocations - https://xgwang.me/posts/you-may-not-know-beacon/#it-may-throw-error%2C-be-sure-to-catch\n    var sendBeacon = global.navigator.sendBeacon.bind(global.navigator);\n    sendBeacon(url, body);\n  } else if ((0,supports/* supportsFetch */.Ak)()) {\n    var fetch = getNativeFetchImplementation();\n    fetch(url, {\n      body,\n      method: 'POST',\n      credentials: 'omit',\n      keepalive: true,\n    }).then(null, error => {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.error */.kg.error(error);\n    });\n  }\n}\n\n\n//# sourceMappingURL=utils.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/browser/esm/client.js\n\n\n\n\n\n\nvar globalObject = (0,esm_global/* getGlobalObject */.R)();\n\n/**\n * The Sentry Browser SDK Client.\n *\n * @see BrowserOptions for documentation on configuration options.\n * @see SentryClient for usage documentation.\n */\nclass BrowserClient extends BaseClient {\n  /**\n   * Creates a new Browser SDK instance.\n   *\n   * @param options Configuration options for this SDK.\n   */\n   constructor(options) {\n    options._metadata = options._metadata || {};\n    options._metadata.sdk = options._metadata.sdk || {\n      name: 'sentry.javascript.browser',\n      packages: [\n        {\n          name: 'npm:@sentry/browser',\n          version: SDK_VERSION,\n        },\n      ],\n      version: SDK_VERSION,\n    };\n\n    super(options);\n\n    if (options.sendClientReports && globalObject.document) {\n      globalObject.document.addEventListener('visibilitychange', () => {\n        if (globalObject.document.visibilityState === 'hidden') {\n          this._flushOutcomes();\n        }\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   eventFromException(exception, hint) {\n    return eventFromException(this._options.stackParser, exception, hint, this._options.attachStacktrace);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   eventFromMessage(\n    message,\n        level = 'info',\n    hint,\n  ) {\n    return eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   sendEvent(event, hint) {\n    // We only want to add the sentry event breadcrumb when the user has the breadcrumb integration installed and\n    // activated its `sentry` option.\n    // We also do not want to use the `Breadcrumbs` class here directly, because we do not want it to be included in\n    // bundles, if it is not used by the SDK.\n    // This all sadly is a bit ugly, but we currently don't have a \"pre-send\" hook on the integrations so we do it this\n    // way for now.\n    var breadcrumbIntegration = this.getIntegrationById(BREADCRUMB_INTEGRATION_ID) ;\n    if (\n      breadcrumbIntegration &&\n      // We check for definedness of `options`, even though it is not strictly necessary, because that access to\n      // `.sentry` below does not throw, in case users provided their own integration with id \"Breadcrumbs\" that does\n      // not have an`options` field\n      breadcrumbIntegration.options &&\n      breadcrumbIntegration.options.sentry\n    ) {\n      (0,esm_hub/* getCurrentHub */.Gd)().addBreadcrumb(\n        {\n          category: `sentry.${event.type === 'transaction' ? 'transaction' : 'event'}`,\n          event_id: event.event_id,\n          level: event.level,\n          message: (0,misc/* getEventDescription */.jH)(event),\n        },\n        {\n          event,\n        },\n      );\n    }\n\n    super.sendEvent(event, hint);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   _prepareEvent(event, hint, scope) {\n    event.platform = event.platform || 'javascript';\n    return super._prepareEvent(event, hint, scope);\n  }\n\n  /**\n   * Sends client reports as an envelope.\n   */\n   _flushOutcomes() {\n    var outcomes = this._clearOutcomes();\n\n    if (outcomes.length === 0) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.log */.kg.log('No outcomes to send');\n      return;\n    }\n\n    if (!this._dsn) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.log */.kg.log('No dsn provided, will not send outcomes');\n      return;\n    }\n\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.log */.kg.log('Sending outcomes:', outcomes);\n\n    var url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, this._options);\n    var envelope = createClientReportEnvelope(outcomes, this._options.tunnel && dsn_dsnToString(this._dsn));\n\n    try {\n      sendReport(url, serializeEnvelope(envelope));\n    } catch (e) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.error */.kg.error(e);\n    }\n  }\n}\n\n\n//# sourceMappingURL=client.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/browser/esm/stack-parsers.js\n\n\n// global reference to slice\nvar UNKNOWN_FUNCTION = '?';\n\nvar OPERA10_PRIORITY = 10;\nvar OPERA11_PRIORITY = 20;\nvar CHROME_PRIORITY = 30;\nvar WINJS_PRIORITY = 40;\nvar GECKO_PRIORITY = 50;\n\nfunction createFrame(filename, func, lineno, colno) {\n  var frame = {\n    filename,\n    function: func,\n    // All browser frames are considered in_app\n    in_app: true,\n  };\n\n  if (lineno !== undefined) {\n    frame.lineno = lineno;\n  }\n\n  if (colno !== undefined) {\n    frame.colno = colno;\n  }\n\n  return frame;\n}\n\n// Chromium based browsers: Chrome, Brave, new Opera, new Edge\nvar chromeRegex =\n  /^\\s*at (?:(.*\\).*?|.*?) ?\\((?:address at )?)?((?:file|https?|blob|chrome-extension|address|native|eval|webpack|<anonymous>|[-a-z]+:|.*bundle|\\/)?.*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\nvar chromeEvalRegex = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n\nvar chrome = line => {\n  var parts = chromeRegex.exec(line);\n\n  if (parts) {\n    var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n\n    if (isEval) {\n      var subMatch = chromeEvalRegex.exec(parts[2]);\n\n      if (subMatch) {\n        // throw out eval line/column and use top-most line/column number\n        parts[2] = subMatch[1]; // url\n        parts[3] = subMatch[2]; // line\n        parts[4] = subMatch[3]; // column\n      }\n    }\n\n    // Kamil: One more hack won't hurt us right? Understanding and adding more rules on top of these regexps right now\n    // would be way too time consuming. (TODO: Rewrite whole RegExp to be more readable)\n    const [func, filename] = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]);\n\n    return createFrame(filename, func, parts[3] ? +parts[3] : undefined, parts[4] ? +parts[4] : undefined);\n  }\n\n  return;\n};\n\nvar chromeStackLineParser = [CHROME_PRIORITY, chrome];\n\n// gecko regex: `(?:bundle|\\d+\\.js)`: `bundle` is for react native, `\\d+\\.js` also but specifically for ram bundles because it\n// generates filenames without a prefix like `file://` the filenames in the stacktrace are just 42.js\n// We need this specific case for now because we want no other regex to match.\nvar geckoREgex =\n  /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)?((?:file|https?|blob|chrome|webpack|resource|moz-extension|safari-extension|safari-web-extension|capacitor)?:\\/.*?|\\[native code\\]|[^@]*(?:bundle|\\d+\\.js)|\\/[\\w\\-. /=]+)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nvar geckoEvalRegex = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\n\nvar gecko = line => {\n  var parts = geckoREgex.exec(line);\n\n  if (parts) {\n    var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n    if (isEval) {\n      var subMatch = geckoEvalRegex.exec(parts[3]);\n\n      if (subMatch) {\n        // throw out eval line/column and use top-most line number\n        parts[1] = parts[1] || 'eval';\n        parts[3] = subMatch[1];\n        parts[4] = subMatch[2];\n        parts[5] = ''; // no column when eval\n      }\n    }\n\n    let filename = parts[3];\n    let func = parts[1] || UNKNOWN_FUNCTION;\n    [func, filename] = extractSafariExtensionDetails(func, filename);\n\n    return createFrame(filename, func, parts[4] ? +parts[4] : undefined, parts[5] ? +parts[5] : undefined);\n  }\n\n  return;\n};\n\nvar geckoStackLineParser = [GECKO_PRIORITY, gecko];\n\nvar winjsRegex =\n  /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n\nvar winjs = line => {\n  var parts = winjsRegex.exec(line);\n\n  return parts\n    ? createFrame(parts[2], parts[1] || UNKNOWN_FUNCTION, +parts[3], parts[4] ? +parts[4] : undefined)\n    : undefined;\n};\n\nvar winjsStackLineParser = [WINJS_PRIORITY, winjs];\n\nvar opera10Regex = / line (\\d+).*script (?:in )?(\\S+)(?:: in function (\\S+))?$/i;\n\nvar opera10 = line => {\n  var parts = opera10Regex.exec(line);\n  return parts ? createFrame(parts[2], parts[3] || UNKNOWN_FUNCTION, +parts[1]) : undefined;\n};\n\nvar opera10StackLineParser = [OPERA10_PRIORITY, opera10];\n\nvar opera11Regex =\n  / line (\\d+), column (\\d+)\\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\\(.*\\))? in (.*):\\s*$/i;\n\nvar opera11 = line => {\n  var parts = opera11Regex.exec(line);\n  return parts ? createFrame(parts[5], parts[3] || parts[4] || UNKNOWN_FUNCTION, +parts[1], +parts[2]) : undefined;\n};\n\nvar opera11StackLineParser = [OPERA11_PRIORITY, opera11];\n\nvar defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser, winjsStackLineParser];\n\nvar defaultStackParser = (0,stacktrace/* createStackParser */.pE)(...defaultStackLineParsers);\n\n/**\n * Safari web extensions, starting version unknown, can produce \"frames-only\" stacktraces.\n * What it means, is that instead of format like:\n *\n * Error: wat\n *   at function@url:row:col\n *   at function@url:row:col\n *   at function@url:row:col\n *\n * it produces something like:\n *\n *   function@url:row:col\n *   function@url:row:col\n *   function@url:row:col\n *\n * Because of that, it won't be captured by `chrome` RegExp and will fall into `Gecko` branch.\n * This function is extracted so that we can use it in both places without duplicating the logic.\n * Unfortunately \"just\" changing RegExp is too complicated now and making it pass all tests\n * and fix this case seems like an impossible, or at least way too time-consuming task.\n */\nvar extractSafariExtensionDetails = (func, filename) => {\n  var isSafariExtension = func.indexOf('safari-extension') !== -1;\n  var isSafariWebExtension = func.indexOf('safari-web-extension') !== -1;\n\n  return isSafariExtension || isSafariWebExtension\n    ? [\n        func.indexOf('@') !== -1 ? func.split('@')[0] : UNKNOWN_FUNCTION,\n        isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}`,\n      ]\n    : [func, filename];\n};\n\n\n//# sourceMappingURL=stack-parsers.js.map\n\n// EXTERNAL MODULE: ./node_modules/@sentry/hub/esm/exports.js\nvar esm_exports = __webpack_require__(2876);\n;// CONCATENATED MODULE: ./node_modules/@sentry/browser/esm/helpers.js\n\n\n\nlet ignoreOnError = 0;\n\n/**\n * @hidden\n */\nfunction shouldIgnoreOnError() {\n  return ignoreOnError > 0;\n}\n\n/**\n * @hidden\n */\nfunction ignoreNextOnError() {\n  // onerror should trigger before setTimeout\n  ignoreOnError += 1;\n  setTimeout(() => {\n    ignoreOnError -= 1;\n  });\n}\n\n/**\n * Instruments the given function and sends an event to Sentry every time the\n * function throws an exception.\n *\n * @param fn A function to wrap. It is generally safe to pass an unbound function, because the returned wrapper always\n * has a correct `this` context.\n * @returns The wrapped function.\n * @hidden\n */\nfunction wrap(\n  fn,\n  options\n\n = {},\n  before,\n  ) {\n  // for future readers what this does is wrap a function and then create\n  // a bi-directional wrapping between them.\n  //\n  // example: wrapped = wrap(original);\n  //  original.__sentry_wrapped__ -> wrapped\n  //  wrapped.__sentry_original__ -> original\n\n  if (typeof fn !== 'function') {\n    return fn;\n  }\n\n  try {\n    // if we're dealing with a function that was previously wrapped, return\n    // the original wrapper.\n    var wrapper = fn.__sentry_wrapped__;\n    if (wrapper) {\n      return wrapper;\n    }\n\n    // We don't wanna wrap it twice\n    if ((0,object/* getOriginalFunction */.HK)(fn)) {\n      return fn;\n    }\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    // Bail on wrapping and return the function as-is (defers to window.onerror).\n    return fn;\n  }\n\n    // It is important that `sentryWrapped` is not an arrow function to preserve the context of `this`\n  var sentryWrapped = function () {\n    var args = Array.prototype.slice.call(arguments);\n\n    try {\n      if (before && typeof before === 'function') {\n        before.apply(this, arguments);\n      }\n\n            var wrappedArguments = args.map((arg) => wrap(arg, options));\n\n      // Attempt to invoke user-land function\n      // NOTE: If you are a Sentry user, and you are seeing this stack frame, it\n      //       means the sentry.javascript SDK caught an error invoking your application code. This\n      //       is expected behavior and NOT indicative of a bug with sentry.javascript.\n      return fn.apply(this, wrappedArguments);\n    } catch (ex) {\n      ignoreNextOnError();\n\n      (0,esm_exports/* withScope */.$e)((scope) => {\n        scope.addEventProcessor((event) => {\n          if (options.mechanism) {\n            (0,misc/* addExceptionTypeValue */.Db)(event, undefined, undefined);\n            (0,misc/* addExceptionMechanism */.EG)(event, options.mechanism);\n          }\n\n          event.extra = {\n            ...event.extra,\n            arguments: args,\n          };\n\n          return event;\n        });\n\n        (0,esm_exports/* captureException */.Tb)(ex);\n      });\n\n      throw ex;\n    }\n  };\n  \n  // Accessing some objects may throw\n  // ref: https://github.com/getsentry/sentry-javascript/issues/1168\n  try {\n    for (var property in fn) {\n      if (Object.prototype.hasOwnProperty.call(fn, property)) {\n        sentryWrapped[property] = fn[property];\n      }\n    }\n  } catch (_oO) {} \n  // Signal that this function has been wrapped/filled already\n  // for both debugging and to prevent it to being wrapped/filled twice\n  (0,object/* markFunctionWrapped */.$Q)(sentryWrapped, fn);\n\n  (0,object/* addNonEnumerableProperty */.xp)(fn, '__sentry_wrapped__', sentryWrapped);\n\n  // Restore original function name (not all browsers allow that)\n  try {\n    var descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, 'name') ;\n    if (descriptor.configurable) {\n      Object.defineProperty(sentryWrapped, 'name', {\n        get() {\n          return fn.name;\n        },\n      });\n    }\n      } catch (_oO) {}\n\n  return sentryWrapped;\n}\n\n/**\n * All properties the report dialog supports\n */\n\n\n//# sourceMappingURL=helpers.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/browser/esm/integrations/trycatch.js\n\n\n\nvar DEFAULT_EVENT_TARGET = [\n  'EventTarget',\n  'Window',\n  'Node',\n  'ApplicationCache',\n  'AudioTrackList',\n  'ChannelMergerNode',\n  'CryptoOperation',\n  'EventSource',\n  'FileReader',\n  'HTMLUnknownElement',\n  'IDBDatabase',\n  'IDBRequest',\n  'IDBTransaction',\n  'KeyOperation',\n  'MediaController',\n  'MessagePort',\n  'ModalWindow',\n  'Notification',\n  'SVGElementInstance',\n  'Screen',\n  'TextTrack',\n  'TextTrackCue',\n  'TextTrackList',\n  'WebSocket',\n  'WebSocketWorker',\n  'Worker',\n  'XMLHttpRequest',\n  'XMLHttpRequestEventTarget',\n  'XMLHttpRequestUpload',\n];\n\n/** Wrap timer functions and event targets to catch errors and provide better meta data */\nclass TryCatch  {\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'TryCatch';}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = TryCatch.id;}\n\n  /** JSDoc */\n  \n\n  /**\n   * @inheritDoc\n   */\n   constructor(options) {;TryCatch.prototype.__init.call(this);\n    this._options = {\n      XMLHttpRequest: true,\n      eventTarget: true,\n      requestAnimationFrame: true,\n      setInterval: true,\n      setTimeout: true,\n      ...options,\n    };\n  }\n\n  /**\n   * Wrap timer functions and event targets to catch errors\n   * and provide better metadata.\n   */\n   setupOnce() {\n    var global = (0,esm_global/* getGlobalObject */.R)();\n\n    if (this._options.setTimeout) {\n      (0,object/* fill */.hl)(global, 'setTimeout', _wrapTimeFunction);\n    }\n\n    if (this._options.setInterval) {\n      (0,object/* fill */.hl)(global, 'setInterval', _wrapTimeFunction);\n    }\n\n    if (this._options.requestAnimationFrame) {\n      (0,object/* fill */.hl)(global, 'requestAnimationFrame', _wrapRAF);\n    }\n\n    if (this._options.XMLHttpRequest && 'XMLHttpRequest' in global) {\n      (0,object/* fill */.hl)(XMLHttpRequest.prototype, 'send', _wrapXHR);\n    }\n\n    var eventTargetOption = this._options.eventTarget;\n    if (eventTargetOption) {\n      var eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;\n      eventTarget.forEach(_wrapEventTarget);\n    }\n  }\n} TryCatch.__initStatic();\n\n/** JSDoc */\nfunction _wrapTimeFunction(original) {\n    return function ( ...args) {\n    var originalCallback = args[0];\n    args[0] = wrap(originalCallback, {\n      mechanism: {\n        data: { function: (0,stacktrace/* getFunctionName */.$P)(original) },\n        handled: true,\n        type: 'instrument',\n      },\n    });\n    return original.apply(this, args);\n  };\n}\n\n/** JSDoc */\nfunction _wrapRAF(original) {\n    return function ( callback) {\n        return original.apply(this, [\n      wrap(callback, {\n        mechanism: {\n          data: {\n            function: 'requestAnimationFrame',\n            handler: (0,stacktrace/* getFunctionName */.$P)(original),\n          },\n          handled: true,\n          type: 'instrument',\n        },\n      }),\n    ]);\n  };\n}\n\n/** JSDoc */\nfunction _wrapXHR(originalSend) {\n    return function ( ...args) {\n        var xhr = this;\n    var xmlHttpRequestProps = ['onload', 'onerror', 'onprogress', 'onreadystatechange'];\n\n    xmlHttpRequestProps.forEach(prop => {\n      if (prop in xhr && typeof xhr[prop] === 'function') {\n                (0,object/* fill */.hl)(xhr, prop, function (original) {\n          var wrapOptions = {\n            mechanism: {\n              data: {\n                function: prop,\n                handler: (0,stacktrace/* getFunctionName */.$P)(original),\n              },\n              handled: true,\n              type: 'instrument',\n            },\n          };\n\n          // If Instrument integration has been called before TryCatch, get the name of original function\n          var originalFunction = (0,object/* getOriginalFunction */.HK)(original);\n          if (originalFunction) {\n            wrapOptions.mechanism.data.handler = (0,stacktrace/* getFunctionName */.$P)(originalFunction);\n          }\n\n          // Otherwise wrap directly\n          return wrap(original, wrapOptions);\n        });\n      }\n    });\n\n    return originalSend.apply(this, args);\n  };\n}\n\n/** JSDoc */\nfunction _wrapEventTarget(target) {\n    var global = (0,esm_global/* getGlobalObject */.R)() ;\n    var proto = global[target] && global[target].prototype;\n\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n    return;\n  }\n\n  (0,object/* fill */.hl)(proto, 'addEventListener', function (original)\n\n {\n    return function (\n            \n      eventName,\n      fn,\n      options,\n    ) {\n      try {\n        if (typeof fn.handleEvent === 'function') {\n          // ESlint disable explanation:\n          //  First, it is generally safe to call `wrap` with an unbound function. Furthermore, using `.bind()` would\n          //  introduce a bug here, because bind returns a new function that doesn't have our\n          //  flags(like __sentry_original__) attached. `wrap` checks for those flags to avoid unnecessary wrapping.\n          //  Without those flags, every call to addEventListener wraps the function again, causing a memory leak.\n                    fn.handleEvent = wrap(fn.handleEvent, {\n            mechanism: {\n              data: {\n                function: 'handleEvent',\n                handler: (0,stacktrace/* getFunctionName */.$P)(fn),\n                target,\n              },\n              handled: true,\n              type: 'instrument',\n            },\n          });\n        }\n      } catch (err) {\n        // can sometimes get 'Permission denied to access property \"handle Event'\n      }\n\n      return original.apply(this, [\n        eventName,\n                wrap(fn , {\n          mechanism: {\n            data: {\n              function: 'addEventListener',\n              handler: (0,stacktrace/* getFunctionName */.$P)(fn),\n              target,\n            },\n            handled: true,\n            type: 'instrument',\n          },\n        }),\n        options,\n      ]);\n    };\n  });\n\n  (0,object/* fill */.hl)(\n    proto,\n    'removeEventListener',\n    function (\n      originalRemoveEventListener,\n          ) {\n      return function (\n                \n        eventName,\n        fn,\n        options,\n      ) {\n        /**\n         * There are 2 possible scenarios here:\n         *\n         * 1. Someone passes a callback, which was attached prior to Sentry initialization, or by using unmodified\n         * method, eg. `document.addEventListener.call(el, name, handler). In this case, we treat this function\n         * as a pass-through, and call original `removeEventListener` with it.\n         *\n         * 2. Someone passes a callback, which was attached after Sentry was initialized, which means that it was using\n         * our wrapped version of `addEventListener`, which internally calls `wrap` helper.\n         * This helper \"wraps\" whole callback inside a try/catch statement, and attached appropriate metadata to it,\n         * in order for us to make a distinction between wrapped/non-wrapped functions possible.\n         * If a function was wrapped, it has additional property of `__sentry_wrapped__`, holding the handler.\n         *\n         * When someone adds a handler prior to initialization, and then do it again, but after,\n         * then we have to detach both of them. Otherwise, if we'd detach only wrapped one, it'd be impossible\n         * to get rid of the initial handler and it'd stick there forever.\n         */\n        var wrappedEventHandler = fn ;\n        try {\n          var originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;\n          if (originalEventHandler) {\n            originalRemoveEventListener.call(this, eventName, originalEventHandler, options);\n          }\n        } catch (e) {\n          // ignore, accessing __sentry_wrapped__ will throw in some Selenium environments\n        }\n        return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);\n      };\n    },\n  );\n}\n\n\n//# sourceMappingURL=trycatch.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/browser/esm/integrations/globalhandlers.js\n\n\n\n\n\n/** Global handlers */\nclass GlobalHandlers  {\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'GlobalHandlers';}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = GlobalHandlers.id;}\n\n  /** JSDoc */\n  \n\n  /**\n   * Stores references functions to installing handlers. Will set to undefined\n   * after they have been run so that they are not used twice.\n   */\n   __init2() {this._installFunc = {\n    onerror: _installGlobalOnErrorHandler,\n    onunhandledrejection: _installGlobalOnUnhandledRejectionHandler,\n  };}\n\n  /** JSDoc */\n   constructor(options) {;GlobalHandlers.prototype.__init.call(this);GlobalHandlers.prototype.__init2.call(this);\n    this._options = {\n      onerror: true,\n      onunhandledrejection: true,\n      ...options,\n    };\n  }\n  /**\n   * @inheritDoc\n   */\n   setupOnce() {\n    Error.stackTraceLimit = 50;\n    var options = this._options;\n\n    // We can disable guard-for-in as we construct the options object above + do checks against\n    // `this._installFunc` for the property.\n        for (var key in options) {\n      var installFunc = this._installFunc[key ];\n      if (installFunc && options[key ]) {\n        globalHandlerLog(key);\n        installFunc();\n        this._installFunc[key ] = undefined;\n      }\n    }\n  }\n} GlobalHandlers.__initStatic();\n\n/** JSDoc */\nfunction _installGlobalOnErrorHandler() {\n  (0,instrument/* addInstrumentationHandler */.o)(\n    'error',\n        (data) => {\n      const [hub, stackParser, attachStacktrace] = getHubAndOptions();\n      if (!hub.getIntegration(GlobalHandlers)) {\n        return;\n      }\n      const { msg, url, line, column, error } = data;\n      if (shouldIgnoreOnError() || (error && error.__sentry_own_request__)) {\n        return;\n      }\n\n      var event =\n        error === undefined && (0,is/* isString */.HD)(msg)\n          ? _eventFromIncompleteOnError(msg, url, line, column)\n          : _enhanceEventWithInitialFrame(\n              eventFromUnknownInput(stackParser, error || msg, undefined, attachStacktrace, false),\n              url,\n              line,\n              column,\n            );\n\n      event.level = 'error';\n\n      addMechanismAndCapture(hub, error, event, 'onerror');\n    },\n  );\n}\n\n/** JSDoc */\nfunction _installGlobalOnUnhandledRejectionHandler() {\n  (0,instrument/* addInstrumentationHandler */.o)(\n    'unhandledrejection',\n        (e) => {\n      const [hub, stackParser, attachStacktrace] = getHubAndOptions();\n      if (!hub.getIntegration(GlobalHandlers)) {\n        return;\n      }\n      let error = e;\n\n      // dig the object of the rejection out of known event types\n      try {\n        // PromiseRejectionEvents store the object of the rejection under 'reason'\n        // see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent\n        if ('reason' in e) {\n          error = e.reason;\n        }\n        // something, somewhere, (likely a browser extension) effectively casts PromiseRejectionEvents\n        // to CustomEvents, moving the `promise` and `reason` attributes of the PRE into\n        // the CustomEvent's `detail` attribute, since they're not part of CustomEvent's spec\n        // see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent and\n        // https://github.com/getsentry/sentry-javascript/issues/2380\n        else if ('detail' in e && 'reason' in e.detail) {\n          error = e.detail.reason;\n        }\n      } catch (_oO) {\n        // no-empty\n      }\n\n      if (shouldIgnoreOnError() || (error && error.__sentry_own_request__)) {\n        return true;\n      }\n\n      var event = (0,is/* isPrimitive */.pt)(error)\n        ? _eventFromRejectionWithPrimitive(error)\n        : eventFromUnknownInput(stackParser, error, undefined, attachStacktrace, true);\n\n      event.level = 'error';\n\n      addMechanismAndCapture(hub, error, event, 'onunhandledrejection');\n      return;\n    },\n  );\n}\n\n/**\n * Create an event from a promise rejection where the `reason` is a primitive.\n *\n * @param reason: The `reason` property of the promise rejection\n * @returns An Event object with an appropriate `exception` value\n */\nfunction _eventFromRejectionWithPrimitive(reason) {\n  return {\n    exception: {\n      values: [\n        {\n          type: 'UnhandledRejection',\n          // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)\n          value: `Non-Error promise rejection captured with value: ${String(reason)}`,\n        },\n      ],\n    },\n  };\n}\n\n/**\n * This function creates a stack from an old, error-less onerror handler.\n */\nfunction _eventFromIncompleteOnError(msg, url, line, column) {\n  var ERROR_TYPES_RE =\n    /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;\n\n  // If 'message' is ErrorEvent, get real message from inside\n  let message = (0,is/* isErrorEvent */.VW)(msg) ? msg.message : msg;\n  let name = 'Error';\n\n  var groups = message.match(ERROR_TYPES_RE);\n  if (groups) {\n    name = groups[1];\n    message = groups[2];\n  }\n\n  var event = {\n    exception: {\n      values: [\n        {\n          type: name,\n          value: message,\n        },\n      ],\n    },\n  };\n\n  return _enhanceEventWithInitialFrame(event, url, line, column);\n}\n\n/** JSDoc */\nfunction _enhanceEventWithInitialFrame(event, url, line, column) {\n  // event.exception\n  var e = (event.exception = event.exception || {});\n  // event.exception.values\n  var ev = (e.values = e.values || []);\n  // event.exception.values[0]\n  var ev0 = (ev[0] = ev[0] || {});\n  // event.exception.values[0].stacktrace\n  var ev0s = (ev0.stacktrace = ev0.stacktrace || {});\n  // event.exception.values[0].stacktrace.frames\n  var ev0sf = (ev0s.frames = ev0s.frames || []);\n\n  var colno = isNaN(parseInt(column, 10)) ? undefined : column;\n  var lineno = isNaN(parseInt(line, 10)) ? undefined : line;\n  var filename = (0,is/* isString */.HD)(url) && url.length > 0 ? url : (0,browser/* getLocationHref */.l4)();\n\n  // event.exception.values[0].stacktrace.frames\n  if (ev0sf.length === 0) {\n    ev0sf.push({\n      colno,\n      filename,\n      function: '?',\n      in_app: true,\n      lineno,\n    });\n  }\n\n  return event;\n}\n\nfunction globalHandlerLog(type) {\n  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.log */.kg.log(`Global Handler attached: ${type}`);\n}\n\nfunction addMechanismAndCapture(hub, error, event, type) {\n  (0,misc/* addExceptionMechanism */.EG)(event, {\n    handled: false,\n    type,\n  });\n  hub.captureEvent(event, {\n    originalException: error,\n  });\n}\n\nfunction getHubAndOptions() {\n  var hub = (0,esm_hub/* getCurrentHub */.Gd)();\n  var client = hub.getClient();\n  var options = (client && client.getOptions()) || {\n    stackParser: () => [],\n    attachStacktrace: false,\n  };\n  return [hub, options.stackParser, options.attachStacktrace];\n}\n\n\n//# sourceMappingURL=globalhandlers.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/browser/esm/integrations/linkederrors.js\n\n\n\n\nvar DEFAULT_KEY = 'cause';\nvar DEFAULT_LIMIT = 5;\n\n/** Adds SDK info to an event. */\nclass LinkedErrors  {\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'LinkedErrors';}\n\n  /**\n   * @inheritDoc\n   */\n    __init() {this.name = LinkedErrors.id;}\n\n  /**\n   * @inheritDoc\n   */\n  \n\n  /**\n   * @inheritDoc\n   */\n  \n\n  /**\n   * @inheritDoc\n   */\n   constructor(options = {}) {;LinkedErrors.prototype.__init.call(this);\n    this._key = options.key || DEFAULT_KEY;\n    this._limit = options.limit || DEFAULT_LIMIT;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setupOnce() {\n    var client = (0,esm_hub/* getCurrentHub */.Gd)().getClient();\n    if (!client) {\n      return;\n    }\n    (0,esm_scope/* addGlobalEventProcessor */.c)((event, hint) => {\n      var self = (0,esm_hub/* getCurrentHub */.Gd)().getIntegration(LinkedErrors);\n      return self ? _handler(client.getOptions().stackParser, self._key, self._limit, event, hint) : event;\n    });\n  }\n} LinkedErrors.__initStatic();\n\n/**\n * @inheritDoc\n */\nfunction _handler(\n  parser,\n  key,\n  limit,\n  event,\n  hint,\n) {\n  if (!event.exception || !event.exception.values || !hint || !(0,is/* isInstanceOf */.V9)(hint.originalException, Error)) {\n    return event;\n  }\n  var linkedErrors = _walkErrorTree(parser, limit, hint.originalException , key);\n  event.exception.values = [...linkedErrors, ...event.exception.values];\n  return event;\n}\n\n/**\n * JSDOC\n */\nfunction _walkErrorTree(\n  parser,\n  limit,\n  error,\n  key,\n  stack = [],\n) {\n  if (!(0,is/* isInstanceOf */.V9)(error[key], Error) || stack.length + 1 >= limit) {\n    return stack;\n  }\n  var exception = exceptionFromError(parser, error[key]);\n  return _walkErrorTree(parser, limit, error[key], key, [exception, ...stack]);\n}\n\n\n//# sourceMappingURL=linkederrors.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/browser/esm/integrations/dedupe.js\n\n\n/** Deduplication filter */\nclass Dedupe  {constructor() { Dedupe.prototype.__init.call(this); }\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'Dedupe';}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = Dedupe.id;}\n\n  /**\n   * @inheritDoc\n   */\n  \n\n  /**\n   * @inheritDoc\n   */\n   setupOnce(addGlobalEventProcessor, getCurrentHub) {\n    var eventProcessor = currentEvent => {\n      var self = getCurrentHub().getIntegration(Dedupe);\n      if (self) {\n        // Juuust in case something goes wrong\n        try {\n          if (dedupe_shouldDropEvent(currentEvent, self._previousEvent)) {\n            (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.warn */.kg.warn('Event dropped due to being a duplicate of previously captured event.');\n            return null;\n          }\n        } catch (_oO) {\n          return (self._previousEvent = currentEvent);\n        }\n\n        return (self._previousEvent = currentEvent);\n      }\n      return currentEvent;\n    };\n\n    eventProcessor.id = this.name;\n    addGlobalEventProcessor(eventProcessor);\n  }\n} Dedupe.__initStatic();\n\n/** JSDoc */\nfunction dedupe_shouldDropEvent(currentEvent, previousEvent) {\n  if (!previousEvent) {\n    return false;\n  }\n\n  if (_isSameMessageEvent(currentEvent, previousEvent)) {\n    return true;\n  }\n\n  if (_isSameExceptionEvent(currentEvent, previousEvent)) {\n    return true;\n  }\n\n  return false;\n}\n\n/** JSDoc */\nfunction _isSameMessageEvent(currentEvent, previousEvent) {\n  var currentMessage = currentEvent.message;\n  var previousMessage = previousEvent.message;\n\n  // If neither event has a message property, they were both exceptions, so bail out\n  if (!currentMessage && !previousMessage) {\n    return false;\n  }\n\n  // If only one event has a stacktrace, but not the other one, they are not the same\n  if ((currentMessage && !previousMessage) || (!currentMessage && previousMessage)) {\n    return false;\n  }\n\n  if (currentMessage !== previousMessage) {\n    return false;\n  }\n\n  if (!_isSameFingerprint(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  if (!_isSameStacktrace(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  return true;\n}\n\n/** JSDoc */\nfunction _isSameExceptionEvent(currentEvent, previousEvent) {\n  var previousException = _getExceptionFromEvent(previousEvent);\n  var currentException = _getExceptionFromEvent(currentEvent);\n\n  if (!previousException || !currentException) {\n    return false;\n  }\n\n  if (previousException.type !== currentException.type || previousException.value !== currentException.value) {\n    return false;\n  }\n\n  if (!_isSameFingerprint(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  if (!_isSameStacktrace(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  return true;\n}\n\n/** JSDoc */\nfunction _isSameStacktrace(currentEvent, previousEvent) {\n  let currentFrames = _getFramesFromEvent(currentEvent);\n  let previousFrames = _getFramesFromEvent(previousEvent);\n\n  // If neither event has a stacktrace, they are assumed to be the same\n  if (!currentFrames && !previousFrames) {\n    return true;\n  }\n\n  // If only one event has a stacktrace, but not the other one, they are not the same\n  if ((currentFrames && !previousFrames) || (!currentFrames && previousFrames)) {\n    return false;\n  }\n\n  currentFrames = currentFrames ;\n  previousFrames = previousFrames ;\n\n  // If number of frames differ, they are not the same\n  if (previousFrames.length !== currentFrames.length) {\n    return false;\n  }\n\n  // Otherwise, compare the two\n  for (let i = 0; i < previousFrames.length; i++) {\n    var frameA = previousFrames[i];\n    var frameB = currentFrames[i];\n\n    if (\n      frameA.filename !== frameB.filename ||\n      frameA.lineno !== frameB.lineno ||\n      frameA.colno !== frameB.colno ||\n      frameA.function !== frameB.function\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/** JSDoc */\nfunction _isSameFingerprint(currentEvent, previousEvent) {\n  let currentFingerprint = currentEvent.fingerprint;\n  let previousFingerprint = previousEvent.fingerprint;\n\n  // If neither event has a fingerprint, they are assumed to be the same\n  if (!currentFingerprint && !previousFingerprint) {\n    return true;\n  }\n\n  // If only one event has a fingerprint, but not the other one, they are not the same\n  if ((currentFingerprint && !previousFingerprint) || (!currentFingerprint && previousFingerprint)) {\n    return false;\n  }\n\n  currentFingerprint = currentFingerprint ;\n  previousFingerprint = previousFingerprint ;\n\n  // Otherwise, compare the two\n  try {\n    return !!(currentFingerprint.join('') === previousFingerprint.join(''));\n  } catch (_oO) {\n    return false;\n  }\n}\n\n/** JSDoc */\nfunction _getExceptionFromEvent(event) {\n  return event.exception && event.exception.values && event.exception.values[0];\n}\n\n/** JSDoc */\nfunction _getFramesFromEvent(event) {\n  var exception = event.exception;\n\n  if (exception) {\n    try {\n      // @ts-ignore Object could be undefined\n      return exception.values[0].stacktrace.frames;\n    } catch (_oO) {\n      return undefined;\n    }\n  }\n  return undefined;\n}\n\n\n//# sourceMappingURL=dedupe.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/browser/esm/integrations/httpcontext.js\n\n\n\nvar httpcontext_global = (0,esm_global/* getGlobalObject */.R)();\n\n/** HttpContext integration collects information about HTTP request headers */\nclass HttpContext  {constructor() { HttpContext.prototype.__init.call(this); }\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'HttpContext';}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = HttpContext.id;}\n\n  /**\n   * @inheritDoc\n   */\n   setupOnce() {\n    (0,esm_scope/* addGlobalEventProcessor */.c)((event) => {\n      if ((0,esm_hub/* getCurrentHub */.Gd)().getIntegration(HttpContext)) {\n        // if none of the information we want exists, don't bother\n        if (!httpcontext_global.navigator && !httpcontext_global.location && !httpcontext_global.document) {\n          return event;\n        }\n\n        // grab as much info as exists and add it to the event\n        var url = (event.request && event.request.url) || (httpcontext_global.location && httpcontext_global.location.href);\n        const { referrer } = httpcontext_global.document || {};\n        const { userAgent } = httpcontext_global.navigator || {};\n\n        var headers = {\n          ...(event.request && event.request.headers),\n          ...(referrer && { Referer: referrer }),\n          ...(userAgent && { 'User-Agent': userAgent }),\n        };\n        var request = { ...(url && { url }), headers };\n\n        return { ...event, request };\n      }\n      return event;\n    });\n  }\n} HttpContext.__initStatic();\n\n\n//# sourceMappingURL=httpcontext.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/utils/esm/promisebuffer.js\n\n\n\n/**\n * Creates an new PromiseBuffer object with the specified limit\n * @param limit max number of promises that can be stored in the buffer\n */\nfunction makePromiseBuffer(limit) {\n  var buffer = [];\n\n  function isReady() {\n    return limit === undefined || buffer.length < limit;\n  }\n\n  /**\n   * Remove a promise from the queue.\n   *\n   * @param task Can be any PromiseLike<T>\n   * @returns Removed promise.\n   */\n  function remove(task) {\n    return buffer.splice(buffer.indexOf(task), 1)[0];\n  }\n\n  /**\n   * Add a promise (representing an in-flight action) to the queue, and set it to remove itself on fulfillment.\n   *\n   * @param taskProducer A function producing any PromiseLike<T>; In previous versions this used to be `task:\n   *        PromiseLike<T>`, but under that model, Promises were instantly created on the call-site and their executor\n   *        functions therefore ran immediately. Thus, even if the buffer was full, the action still happened. By\n   *        requiring the promise to be wrapped in a function, we can defer promise creation until after the buffer\n   *        limit check.\n   * @returns The original promise.\n   */\n  function add(taskProducer) {\n    if (!isReady()) {\n      return (0,syncpromise/* rejectedSyncPromise */.$2)(new SentryError('Not adding Promise because buffer limit was reached.'));\n    }\n\n    // start the task and add its promise to the queue\n    var task = taskProducer();\n    if (buffer.indexOf(task) === -1) {\n      buffer.push(task);\n    }\n    void task\n      .then(() => remove(task))\n      // Use `then(null, rejectionHandler)` rather than `catch(rejectionHandler)` so that we can use `PromiseLike`\n      // rather than `Promise`. `PromiseLike` doesn't have a `.catch` method, making its polyfill smaller. (ES5 didn't\n      // have promises, so TS has to polyfill when down-compiling.)\n      .then(null, () =>\n        remove(task).then(null, () => {\n          // We have to add another catch here because `remove()` starts a new promise chain.\n        }),\n      );\n    return task;\n  }\n\n  /**\n   * Wait for all promises in the queue to resolve or for timeout to expire, whichever comes first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the queue is still non-empty. Passing `0` (or\n   * not passing anything) will make the promise wait as long as it takes for the queue to drain before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if the queue is already empty or drains before the timeout, and\n   * `false` otherwise\n   */\n  function drain(timeout) {\n    return new syncpromise/* SyncPromise */.cW((resolve, reject) => {\n      let counter = buffer.length;\n\n      if (!counter) {\n        return resolve(true);\n      }\n\n      // wait for `timeout` ms and then resolve to `false` (if not cancelled first)\n      var capturedSetTimeout = setTimeout(() => {\n        if (timeout && timeout > 0) {\n          resolve(false);\n        }\n      }, timeout);\n\n      // if all promises resolve in time, cancel the timer and resolve to `true`\n      buffer.forEach(item => {\n        void (0,syncpromise/* resolvedSyncPromise */.WD)(item).then(() => {\n                    if (!--counter) {\n            clearTimeout(capturedSetTimeout);\n            resolve(true);\n          }\n        }, reject);\n      });\n    });\n  }\n\n  return {\n    $: buffer,\n    add,\n    drain,\n  };\n}\n\n\n//# sourceMappingURL=promisebuffer.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/utils/esm/ratelimit.js\n// Intentionally keeping the key broad, as we don't know for sure what rate limit headers get returned from backend\n\nvar DEFAULT_RETRY_AFTER = 60 * 1000; // 60 seconds\n\n/**\n * Extracts Retry-After value from the request header or returns default value\n * @param header string representation of 'Retry-After' header\n * @param now current unix timestamp\n *\n */\nfunction parseRetryAfterHeader(header, now = Date.now()) {\n  var headerDelay = parseInt(`${header}`, 10);\n  if (!isNaN(headerDelay)) {\n    return headerDelay * 1000;\n  }\n\n  var headerDate = Date.parse(`${header}`);\n  if (!isNaN(headerDate)) {\n    return headerDate - now;\n  }\n\n  return DEFAULT_RETRY_AFTER;\n}\n\n/**\n * Gets the time that given category is disabled until for rate limiting\n */\nfunction disabledUntil(limits, category) {\n  return limits[category] || limits.all || 0;\n}\n\n/**\n * Checks if a category is rate limited\n */\nfunction isRateLimited(limits, category, now = Date.now()) {\n  return disabledUntil(limits, category) > now;\n}\n\n/**\n * Update ratelimits from incoming headers.\n * Returns true if headers contains a non-empty rate limiting header.\n */\nfunction updateRateLimits(\n  limits,\n  { statusCode, headers },\n  now = Date.now(),\n) {\n  var updatedRateLimits = {\n    ...limits,\n  };\n\n  // \"The name is case-insensitive.\"\n  // https://developer.mozilla.org/en-US/docs/Web/API/Headers/get\n  var rateLimitHeader = headers && headers['x-sentry-rate-limits'];\n  var retryAfterHeader = headers && headers['retry-after'];\n\n  if (rateLimitHeader) {\n    /**\n     * rate limit headers are of the form\n     *     <header>,<header>,..\n     * where each <header> is of the form\n     *     <retry_after>: <categories>: <scope>: <reason_code>\n     * where\n     *     <retry_after> is a delay in seconds\n     *     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form\n     *         <category>;<category>;...\n     *     <scope> is what's being limited (org, project, or key) - ignored by SDK\n     *     <reason_code> is an arbitrary string like \"org_quota\" - ignored by SDK\n     */\n    for (var limit of rateLimitHeader.trim().split(',')) {\n      const [retryAfter, categories] = limit.split(':', 2);\n      var headerDelay = parseInt(retryAfter, 10);\n      var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default\n      if (!categories) {\n        updatedRateLimits.all = now + delay;\n      } else {\n        for (var category of categories.split(';')) {\n          updatedRateLimits[category] = now + delay;\n        }\n      }\n    }\n  } else if (retryAfterHeader) {\n    updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);\n  } else if (statusCode === 429) {\n    updatedRateLimits.all = now + 60 * 1000;\n  }\n\n  return updatedRateLimits;\n}\n\n\n//# sourceMappingURL=ratelimit.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/core/esm/transports/base.js\n\n\nvar DEFAULT_TRANSPORT_BUFFER_SIZE = 30;\n\n/**\n * Creates an instance of a Sentry `Transport`\n *\n * @param options\n * @param makeRequest\n */\nfunction createTransport(\n  options,\n  makeRequest,\n  buffer = makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE),\n) {\n  let rateLimits = {};\n\n  var flush = (timeout) => buffer.drain(timeout);\n\n  function send(envelope) {\n    var filteredEnvelopeItems = [];\n\n    // Drop rate limited items from envelope\n    forEachEnvelopeItem(envelope, (item, type) => {\n      var envelopeItemDataCategory = envelopeItemTypeToDataCategory(type);\n      if (isRateLimited(rateLimits, envelopeItemDataCategory)) {\n        options.recordDroppedEvent('ratelimit_backoff', envelopeItemDataCategory);\n      } else {\n        filteredEnvelopeItems.push(item);\n      }\n    });\n\n    // Skip sending if envelope is empty after filtering out rate limited events\n    if (filteredEnvelopeItems.length === 0) {\n      return (0,syncpromise/* resolvedSyncPromise */.WD)();\n    }\n\n        var filteredEnvelope = createEnvelope(envelope[0], filteredEnvelopeItems );\n\n    // Creates client report for each item in an envelope\n    var recordEnvelopeLoss = (reason) => {\n      forEachEnvelopeItem(filteredEnvelope, (_, type) => {\n        options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type));\n      });\n    };\n\n    var requestTask = () =>\n      makeRequest({ body: serializeEnvelope(filteredEnvelope, options.textEncoder) }).then(\n        response => {\n          // We don't want to throw on NOK responses, but we want to at least log them\n          if (response.statusCode !== undefined && (response.statusCode < 200 || response.statusCode >= 300)) {\n            (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.warn */.kg.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);\n          }\n\n          rateLimits = updateRateLimits(rateLimits, response);\n        },\n        error => {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.error */.kg.error('Failed while sending event:', error);\n          recordEnvelopeLoss('network_error');\n        },\n      );\n\n    return buffer.add(requestTask).then(\n      result => result,\n      error => {\n        if (error instanceof SentryError) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.error */.kg.error('Skipped sending event because buffer is full.');\n          recordEnvelopeLoss('queue_overflow');\n          return (0,syncpromise/* resolvedSyncPromise */.WD)();\n        } else {\n          throw error;\n        }\n      },\n    );\n  }\n\n  return {\n    send,\n    flush,\n  };\n}\n\n\n//# sourceMappingURL=base.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/browser/esm/transports/fetch.js\n\n\n\n/**\n * Creates a Transport that uses the Fetch API to send events to Sentry.\n */\nfunction makeFetchTransport(\n  options,\n  nativeFetch = getNativeFetchImplementation(),\n) {\n  function makeRequest(request) {\n    var requestOptions = {\n      body: request.body,\n      method: 'POST',\n      referrerPolicy: 'origin',\n      headers: options.headers,\n      // Outgoing requests are usually cancelled when navigating to a different page, causing a \"TypeError: Failed to\n      // fetch\" error and sending a \"network_error\" client-outcome - in Chrome, the request status shows \"(cancelled)\".\n      // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're\n      // frequently sending events right before the user is switching pages (eg. whenfinishing navigation transactions).\n      // Gotchas:\n      // - `keepalive` isn't supported by Firefox\n      // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch), a request with `keepalive: true`\n      //   and a content length of > 64 kibibytes returns a network error. We will therefore only activate the flag when\n      //   we're below that limit.\n      keepalive: request.body.length <= 65536,\n      ...options.fetchOptions,\n    };\n\n    return nativeFetch(options.url, requestOptions).then(response => ({\n      statusCode: response.status,\n      headers: {\n        'x-sentry-rate-limits': response.headers.get('X-Sentry-Rate-Limits'),\n        'retry-after': response.headers.get('Retry-After'),\n      },\n    }));\n  }\n\n  return createTransport(options, makeRequest);\n}\n\n\n//# sourceMappingURL=fetch.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/browser/esm/transports/xhr.js\n\n\n\n/**\n * The DONE ready state for XmlHttpRequest\n *\n * Defining it here as a constant b/c XMLHttpRequest.DONE is not always defined\n * (e.g. during testing, it is `undefined`)\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState}\n */\nvar XHR_READYSTATE_DONE = 4;\n\n/**\n * Creates a Transport that uses the XMLHttpRequest API to send events to Sentry.\n */\nfunction makeXHRTransport(options) {\n  function makeRequest(request) {\n    return new syncpromise/* SyncPromise */.cW((resolve, reject) => {\n      var xhr = new XMLHttpRequest();\n\n      xhr.onerror = reject;\n\n      xhr.onreadystatechange = () => {\n        if (xhr.readyState === XHR_READYSTATE_DONE) {\n          resolve({\n            statusCode: xhr.status,\n            headers: {\n              'x-sentry-rate-limits': xhr.getResponseHeader('X-Sentry-Rate-Limits'),\n              'retry-after': xhr.getResponseHeader('Retry-After'),\n            },\n          });\n        }\n      };\n\n      xhr.open('POST', options.url);\n\n      for (var header in options.headers) {\n        if (Object.prototype.hasOwnProperty.call(options.headers, header)) {\n          xhr.setRequestHeader(header, options.headers[header]);\n        }\n      }\n\n      xhr.send(request.body);\n    });\n  }\n\n  return createTransport(options, makeRequest);\n}\n\n\n//# sourceMappingURL=xhr.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/browser/esm/sdk.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar defaultIntegrations = [\n  new InboundFilters(),\n  new FunctionToString(),\n  new TryCatch(),\n  new Breadcrumbs(),\n  new GlobalHandlers(),\n  new LinkedErrors(),\n  new Dedupe(),\n  new HttpContext(),\n];\n\n/**\n * The Sentry Browser SDK Client.\n *\n * To use this SDK, call the {@link init} function as early as possible when\n * loading the web page. To set context information or send manual events, use\n * the provided methods.\n *\n * @example\n *\n * ```\n *\n * import { init } from '@sentry/browser';\n *\n * init({\n *   dsn: '__DSN__',\n *   // ...\n * });\n * ```\n *\n * @example\n * ```\n *\n * import { configureScope } from '@sentry/browser';\n * configureScope((scope: Scope) => {\n *   scope.setExtra({ battery: 0.7 });\n *   scope.setTag({ user_mode: 'admin' });\n *   scope.setUser({ id: '4711' });\n * });\n * ```\n *\n * @example\n * ```\n *\n * import { addBreadcrumb } from '@sentry/browser';\n * addBreadcrumb({\n *   message: 'My Breadcrumb',\n *   // ...\n * });\n * ```\n *\n * @example\n *\n * ```\n *\n * import * as Sentry from '@sentry/browser';\n * Sentry.captureMessage('Hello, world!');\n * Sentry.captureException(new Error('Good bye'));\n * Sentry.captureEvent({\n *   message: 'Manual',\n *   stacktrace: [\n *     // ...\n *   ],\n * });\n * ```\n *\n * @see {@link BrowserOptions} for documentation on configuration options.\n */\nfunction init(options = {}) {\n  if (options.defaultIntegrations === undefined) {\n    options.defaultIntegrations = defaultIntegrations;\n  }\n  if (options.release === undefined) {\n    var window = (0,esm_global/* getGlobalObject */.R)();\n    // This supports the variable that sentry-webpack-plugin injects\n    if (window.SENTRY_RELEASE && window.SENTRY_RELEASE.id) {\n      options.release = window.SENTRY_RELEASE.id;\n    }\n  }\n  if (options.autoSessionTracking === undefined) {\n    options.autoSessionTracking = true;\n  }\n  if (options.sendClientReports === undefined) {\n    options.sendClientReports = true;\n  }\n\n  var clientOptions = {\n    ...options,\n    stackParser: (0,stacktrace/* stackParserFromStackParserOptions */.Sq)(options.stackParser || defaultStackParser),\n    integrations: getIntegrationsToSetup(options),\n    transport: options.transport || ((0,supports/* supportsFetch */.Ak)() ? makeFetchTransport : makeXHRTransport),\n  };\n\n  initAndBind(BrowserClient, clientOptions);\n\n  if (options.autoSessionTracking) {\n    startSessionTracking();\n  }\n}\n\n/**\n * Present the user with a report dialog.\n *\n * @param options Everything is optional, we try to fetch all info need from the global scope.\n */\nfunction showReportDialog(options = {}, hub = getCurrentHub()) {\n  // doesn't work without a document (React Native)\n  var global = getGlobalObject();\n  if (!global.document) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Global document not defined in showReportDialog call');\n    return;\n  }\n\n  const { client, scope } = hub.getStackTop();\n  var dsn = options.dsn || (client && client.getDsn());\n  if (!dsn) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('DSN not configured for showReportDialog call');\n    return;\n  }\n\n  if (scope) {\n    options.user = {\n      ...scope.getUser(),\n      ...options.user,\n    };\n  }\n\n  if (!options.eventId) {\n    options.eventId = hub.lastEventId();\n  }\n\n  var script = global.document.createElement('script');\n  script.async = true;\n  script.src = getReportDialogEndpoint(dsn, options);\n\n  if (options.onLoad) {\n        script.onload = options.onLoad;\n  }\n\n  var injectionPoint = global.document.head || global.document.body;\n  if (injectionPoint) {\n    injectionPoint.appendChild(script);\n  } else {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Not injecting report dialog. No injection point found in HTML');\n  }\n}\n\n/**\n * This is the getter for lastEventId.\n *\n * @returns The last event id of a captured event.\n */\nfunction lastEventId() {\n  return getCurrentHub().lastEventId();\n}\n\n/**\n * This function is here to be API compatible with the loader.\n * @hidden\n */\nfunction forceLoad() {\n  // Noop\n}\n\n/**\n * This function is here to be API compatible with the loader.\n * @hidden\n */\nfunction onLoad(callback) {\n  callback();\n}\n\n/**\n * Call `flush()` on the current client, if there is one. See {@link Client.flush}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause\n * the client to wait until all events are sent before resolving the promise.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nfunction flush(timeout) {\n  var client = getCurrentHub().getClient();\n  if (client) {\n    return client.flush(timeout);\n  }\n  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Cannot flush events. No client defined.');\n  return resolvedSyncPromise(false);\n}\n\n/**\n * Call `close()` on the current client, if there is one. See {@link Client.close}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this\n * parameter will cause the client to wait until all events are sent before disabling itself.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nfunction sdk_close(timeout) {\n  var client = getCurrentHub().getClient();\n  if (client) {\n    return client.close(timeout);\n  }\n  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Cannot flush events and disable SDK. No client defined.');\n  return resolvedSyncPromise(false);\n}\n\n/**\n * Wrap code within a try/catch block so the SDK is able to capture errors.\n *\n * @param fn A function to wrap.\n *\n * @returns The result of wrapped function call.\n */\nfunction sdk_wrap(fn) {\n  return wrap$1(fn)();\n}\n\nfunction startSessionOnHub(hub) {\n  hub.startSession({ ignoreDuration: true });\n  hub.captureSession();\n}\n\n/**\n * Enable automatic Session Tracking for the initial page load.\n */\nfunction startSessionTracking() {\n  var window = (0,esm_global/* getGlobalObject */.R)();\n  var document = window.document;\n\n  if (typeof document === 'undefined') {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      esm_logger/* logger.warn */.kg.warn('Session tracking in non-browser environment with @sentry/browser is not supported.');\n    return;\n  }\n\n  var hub = (0,esm_hub/* getCurrentHub */.Gd)();\n\n  // The only way for this to be false is for there to be a version mismatch between @sentry/browser (>= 6.0.0) and\n  // @sentry/hub (< 5.27.0). In the simple case, there won't ever be such a mismatch, because the two packages are\n  // pinned at the same version in package.json, but there are edge cases where it's possible. See\n  // https://github.com/getsentry/sentry-javascript/issues/3207 and\n  // https://github.com/getsentry/sentry-javascript/issues/3234 and\n  // https://github.com/getsentry/sentry-javascript/issues/3278.\n  if (!hub.captureSession) {\n    return;\n  }\n\n  // The session duration for browser sessions does not track a meaningful\n  // concept that can be used as a metric.\n  // Automatically captured sessions are akin to page views, and thus we\n  // discard their duration.\n  startSessionOnHub(hub);\n\n  // We want to create a session for every navigation as well\n  (0,instrument/* addInstrumentationHandler */.o)('history', ({ from, to }) => {\n    // Don't create an additional session for the initial route or if the location did not change\n    if (!(from === undefined || from === to)) {\n      startSessionOnHub((0,esm_hub/* getCurrentHub */.Gd)());\n    }\n  });\n}\n\n\n//# sourceMappingURL=sdk.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/react/esm/sdk.js\n\n\n/**\n * Inits the React SDK\n */\nfunction sdk_init(options) {\n  options._metadata = options._metadata || {};\n  options._metadata.sdk = options._metadata.sdk || {\n    name: 'sentry.javascript.react',\n    packages: [\n      {\n        name: 'npm:@sentry/react',\n        version: SDK_VERSION,\n      },\n    ],\n    version: SDK_VERSION,\n  };\n  init(options);\n}\n\n\n//# sourceMappingURL=sdk.js.map\n\n// EXTERNAL MODULE: ./node_modules/@sentry/tracing/esm/hubextensions.js + 1 modules\nvar hubextensions = __webpack_require__(2758);\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.js\nvar _optionalChain = __webpack_require__(4307);\n;// CONCATENATED MODULE: ./node_modules/@sentry/utils/esm/tracing.js\nvar TRACEPARENT_REGEXP = new RegExp(\n  '^[ \\\\t]*' + // whitespace\n    '([0-9a-f]{32})?' + // trace_id\n    '-?([0-9a-f]{16})?' + // span_id\n    '-?([01])?' + // sampled\n    '[ \\\\t]*$', // whitespace\n);\n\n/**\n * Extract transaction context data from a `sentry-trace` header.\n *\n * @param traceparent Traceparent string\n *\n * @returns Object containing data from the header, or undefined if traceparent string is malformed\n */\nfunction extractTraceparentData(traceparent) {\n  var matches = traceparent.match(TRACEPARENT_REGEXP);\n\n  if (!traceparent || !matches) {\n    // empty string or no matches is invalid traceparent data\n    return undefined;\n  }\n\n  let parentSampled;\n  if (matches[3] === '1') {\n    parentSampled = true;\n  } else if (matches[3] === '0') {\n    parentSampled = false;\n  }\n\n  return {\n    traceId: matches[1],\n    parentSampled,\n    parentSpanId: matches[2],\n  };\n}\n\n\n//# sourceMappingURL=tracing.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/utils/esm/baggage.js\n\n\n\nvar BAGGAGE_HEADER_NAME = 'baggage';\n\nvar SENTRY_BAGGAGE_KEY_PREFIX = 'sentry-';\n\nvar SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;\n\n/**\n * Max length of a serialized baggage string\n *\n * https://www.w3.org/TR/baggage/#limits\n */\nvar MAX_BAGGAGE_STRING_LENGTH = 8192;\n\n/**\n * Takes a baggage header and turns it into Dynamic Sampling Context, by extracting all the \"sentry-\" prefixed values\n * from it.\n *\n * @param baggageHeader A very bread definition of a baggage header as it might appear in various frameworks.\n * @returns The Dynamic Sampling Context that was found on `baggageHeader`, if there was any, `undefined` otherwise.\n */\nfunction baggageHeaderToDynamicSamplingContext(\n  // Very liberal definition of what any incoming header might look like\n  baggageHeader,\n) {\n  if (!(0,is/* isString */.HD)(baggageHeader) && !Array.isArray(baggageHeader)) {\n    return undefined;\n  }\n\n  // Intermediary object to store baggage key value pairs of incoming baggage headers on.\n  // It is later used to read Sentry-DSC-values from.\n  let baggageObject = {};\n\n  if (Array.isArray(baggageHeader)) {\n    // Combine all baggage headers into one object containing the baggage values so we can later read the Sentry-DSC-values from it\n    baggageObject = baggageHeader.reduce((acc, curr) => {\n      var currBaggageObject = baggageHeaderToObject(curr);\n      return {\n        ...acc,\n        ...currBaggageObject,\n      };\n    }, {});\n  } else {\n    // Return undefined if baggage header is an empty string (technically an empty baggage header is not spec conform but\n    // this is how we choose to handle it)\n    if (!baggageHeader) {\n      return undefined;\n    }\n\n    baggageObject = baggageHeaderToObject(baggageHeader);\n  }\n\n  // Read all \"sentry-\" prefixed values out of the baggage object and put it onto a dynamic sampling context object.\n  var dynamicSamplingContext = Object.entries(baggageObject).reduce((acc, [key, value]) => {\n    if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {\n      var nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);\n      acc[nonPrefixedKey] = value;\n    }\n    return acc;\n  }, {});\n\n  // Only return a dynamic sampling context object if there are keys in it.\n  // A keyless object means there were no sentry values on the header, which means that there is no DSC.\n  if (Object.keys(dynamicSamplingContext).length > 0) {\n    return dynamicSamplingContext ;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Turns a Dynamic Sampling Object into a baggage header by prefixing all the keys on the object with \"sentry-\".\n *\n * @param dynamicSamplingContext The Dynamic Sampling Context to turn into a header. For convenience and compatibility\n * with the `getDynamicSamplingContext` method on the Transaction class ,this argument can also be `undefined`. If it is\n * `undefined` the function will return `undefined`.\n * @returns a baggage header, created from `dynamicSamplingContext`, or `undefined` either if `dynamicSamplingContext`\n * was `undefined`, or if `dynamicSamplingContext` didn't contain any values.\n */\nfunction dynamicSamplingContextToSentryBaggageHeader(\n  // this also takes undefined for convenience and bundle size in other places\n  dynamicSamplingContext,\n) {\n  // Prefix all DSC keys with \"sentry-\" and put them into a new object\n  var sentryPrefixedDSC = Object.entries(dynamicSamplingContext).reduce(\n    (acc, [dscKey, dscValue]) => {\n      if (dscValue) {\n        acc[`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`] = dscValue;\n      }\n      return acc;\n    },\n    {},\n  );\n\n  return objectToBaggageHeader(sentryPrefixedDSC);\n}\n\n/**\n * Will parse a baggage header, which is a simple key-value map, into a flat object.\n *\n * @param baggageHeader The baggage header to parse.\n * @returns a flat object containing all the key-value pairs from `baggageHeader`.\n */\nfunction baggageHeaderToObject(baggageHeader) {\n  return baggageHeader\n    .split(',')\n    .map(baggageEntry => baggageEntry.split('=').map(keyOrValue => decodeURIComponent(keyOrValue.trim())))\n    .reduce((acc, [key, value]) => {\n      acc[key] = value;\n      return acc;\n    }, {});\n}\n\n/**\n * Turns a flat object (key-value pairs) into a baggage header, which is also just key-value pairs.\n *\n * @param object The object to turn into a baggage header.\n * @returns a baggage header string, or `undefined` if the object didn't have any values, since an empty baggage header\n * is not spec compliant.\n */\nfunction objectToBaggageHeader(object) {\n  if (Object.keys(object).length === 0) {\n    // An empty baggage header is not spec compliant: We return undefined.\n    return undefined;\n  }\n\n  return Object.entries(object).reduce((baggageHeader, [objectKey, objectValue], currentIndex) => {\n    var baggageEntry = `${encodeURIComponent(objectKey)}=${encodeURIComponent(objectValue)}`;\n    var newBaggageHeader = currentIndex === 0 ? baggageEntry : `${baggageHeader},${baggageEntry}`;\n    if (newBaggageHeader.length > MAX_BAGGAGE_STRING_LENGTH) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        esm_logger/* logger.warn */.kg.warn(\n          `Not adding key: ${objectKey} with val: ${objectValue} to baggage header due to exceeding baggage size limits.`,\n        );\n      return baggageHeader;\n    } else {\n      return newBaggageHeader;\n    }\n  }, '');\n}\n\n\n//# sourceMappingURL=baggage.js.map\n\n// EXTERNAL MODULE: ./node_modules/@sentry/tracing/esm/idletransaction.js\nvar idletransaction = __webpack_require__(6458);\n// EXTERNAL MODULE: ./node_modules/@sentry/tracing/esm/utils.js\nvar utils = __webpack_require__(3233);\n;// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/backgroundtab.js\n\n\n\nvar backgroundtab_global = (0,esm_global/* getGlobalObject */.R)();\n\n/**\n * Add a listener that cancels and finishes a transaction when the global\n * document is hidden.\n */\nfunction registerBackgroundTabDetection() {\n  if (backgroundtab_global && backgroundtab_global.document) {\n    backgroundtab_global.document.addEventListener('visibilitychange', () => {\n      var activeTransaction = (0,utils/* getActiveTransaction */.x1)() ;\n      if (backgroundtab_global.document.hidden && activeTransaction) {\n        var statusType = 'cancelled';\n\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n          esm_logger/* logger.log */.kg.log(\n            `[Tracing] Transaction: ${statusType} -> since tab moved to the background, op: ${activeTransaction.op}`,\n          );\n        // We should not set status if it is already set, this prevent important statuses like\n        // error or data loss from being overwritten on transaction.\n        if (!activeTransaction.status) {\n          activeTransaction.setStatus(statusType);\n        }\n        activeTransaction.setTag('visibilitychange', 'document.hidden');\n        activeTransaction.finish();\n      }\n    });\n  } else {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      esm_logger/* logger.warn */.kg.warn('[Tracing] Could not set up background tab detection due to lack of global document');\n  }\n}\n\n\n//# sourceMappingURL=backgroundtab.js.map\n\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/buildPolyfills/_nullishCoalesce.js\nvar _nullishCoalesce = __webpack_require__(5375);\n;// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/bindReporter.js\nvar bindReporter = (\n  callback,\n  metric,\n  reportAllChanges,\n) => {\n  let prevValue;\n  return (forceReport) => {\n    if (metric.value >= 0) {\n      if (forceReport || reportAllChanges) {\n        metric.delta = metric.value - (prevValue || 0);\n\n        // Report the metric if there's a non-zero delta or if no previous\n        // value exists (which can happen in the case of the document becoming\n        // hidden when the metric value is 0).\n        // See: https://github.com/GoogleChrome/web-vitals/issues/14\n        if (metric.delta || prevValue === undefined) {\n          prevValue = metric.value;\n          callback(metric);\n        }\n      }\n    }\n  };\n};\n\n\n//# sourceMappingURL=bindReporter.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/generateUniqueID.js\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Performantly generate a unique, 30-char string by combining a version\n * number, the current timestamp with a 13-digit number integer.\n * @return {string}\n */\nvar generateUniqueID = () => {\n  return `v2-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`;\n};\n\n\n//# sourceMappingURL=generateUniqueID.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/initMetric.js\n\n\n\nvar initMetric = (name, value) => {\n  return {\n    name,\n    value: (0,_nullishCoalesce/* _nullishCoalesce */.h)(value, () => ( -1)),\n    delta: 0,\n    entries: [],\n    id: generateUniqueID(),\n  };\n};\n\n\n//# sourceMappingURL=initMetric.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/observe.js\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Takes a performance entry type and a callback function, and creates a\n * `PerformanceObserver` instance that will observe the specified entry type\n * with buffering enabled and call the callback _for each entry_.\n *\n * This function also feature-detects entry support and wraps the logic in a\n * try/catch to avoid errors in unsupporting browsers.\n */\nvar observe = (type, callback) => {\n  try {\n    if (PerformanceObserver.supportedEntryTypes.includes(type)) {\n      // More extensive feature detect needed for Firefox due to:\n      // https://github.com/GoogleChrome/web-vitals/issues/142\n      if (type === 'first-input' && !('PerformanceEventTiming' in self)) {\n        return;\n      }\n\n      var po = new PerformanceObserver(l => l.getEntries().map(callback));\n\n      po.observe({ type, buffered: true });\n      return po;\n    }\n  } catch (e) {\n    // Do nothing.\n  }\n  return;\n};\n\n\n//# sourceMappingURL=observe.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/onHidden.js\n\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar onHidden = (cb, once) => {\n  var onHiddenOrPageHide = (event) => {\n    if (event.type === 'pagehide' || (0,esm_global/* getGlobalObject */.R)().document.visibilityState === 'hidden') {\n      cb(event);\n      if (once) {\n        removeEventListener('visibilitychange', onHiddenOrPageHide, true);\n        removeEventListener('pagehide', onHiddenOrPageHide, true);\n      }\n    }\n  };\n  addEventListener('visibilitychange', onHiddenOrPageHide, true);\n  // Some browsers have buggy implementations of visibilitychange,\n  // so we use pagehide in addition, just to be safe.\n  addEventListener('pagehide', onHiddenOrPageHide, true);\n};\n\n\n//# sourceMappingURL=onHidden.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/web-vitals/getCLS.js\n\n\n\n\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// https://wicg.github.io/layout-instability/#sec-layout-shift\n\nvar getCLS = (onReport, reportAllChanges) => {\n  var metric = initMetric('CLS', 0);\n  let report;\n\n  let sessionValue = 0;\n  let sessionEntries = [];\n\n  var entryHandler = (entry) => {\n    // Only count layout shifts without recent user input.\n    // TODO: Figure out why entry can be undefined\n    if (entry && !entry.hadRecentInput) {\n      var firstSessionEntry = sessionEntries[0];\n      var lastSessionEntry = sessionEntries[sessionEntries.length - 1];\n\n      // If the entry occurred less than 1 second after the previous entry and\n      // less than 5 seconds after the first entry in the session, include the\n      // entry in the current session. Otherwise, start a new session.\n      if (\n        sessionValue &&\n        sessionEntries.length !== 0 &&\n        entry.startTime - lastSessionEntry.startTime < 1000 &&\n        entry.startTime - firstSessionEntry.startTime < 5000\n      ) {\n        sessionValue += entry.value;\n        sessionEntries.push(entry);\n      } else {\n        sessionValue = entry.value;\n        sessionEntries = [entry];\n      }\n\n      // If the current session value is larger than the current CLS value,\n      // update CLS and the entries contributing to it.\n      if (sessionValue > metric.value) {\n        metric.value = sessionValue;\n        metric.entries = sessionEntries;\n        if (report) {\n          report();\n        }\n      }\n    }\n  };\n\n  var po = observe('layout-shift', entryHandler );\n  if (po) {\n    report = bindReporter(onReport, metric, reportAllChanges);\n\n    onHidden(() => {\n      po.takeRecords().map(entryHandler );\n      report(true);\n    });\n  }\n};\n\n\n//# sourceMappingURL=getCLS.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/getVisibilityWatcher.js\n\n\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nlet firstHiddenTime = -1;\n\nvar initHiddenTime = () => {\n  return (0,esm_global/* getGlobalObject */.R)().document.visibilityState === 'hidden' ? 0 : Infinity;\n};\n\nvar trackChanges = () => {\n  // Update the time if/when the document becomes hidden.\n  onHidden(({ timeStamp }) => {\n    firstHiddenTime = timeStamp;\n  }, true);\n};\n\nvar getVisibilityWatcher = (\n\n) => {\n  if (firstHiddenTime < 0) {\n    // If the document is hidden when this code runs, assume it was hidden\n    // since navigation start. This isn't a perfect heuristic, but it's the\n    // best we can do until an API is available to support querying past\n    // visibilityState.\n    firstHiddenTime = initHiddenTime();\n    trackChanges();\n  }\n  return {\n    get firstHiddenTime() {\n      return firstHiddenTime;\n    },\n  };\n};\n\n\n//# sourceMappingURL=getVisibilityWatcher.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/web-vitals/getFID.js\n\n\n\n\n\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar getFID = (onReport, reportAllChanges) => {\n  var visibilityWatcher = getVisibilityWatcher();\n  var metric = initMetric('FID');\n  let report;\n\n  var entryHandler = (entry) => {\n    // Only report if the page wasn't hidden prior to the first input.\n    if (report && entry.startTime < visibilityWatcher.firstHiddenTime) {\n      metric.value = entry.processingStart - entry.startTime;\n      metric.entries.push(entry);\n      report(true);\n    }\n  };\n\n  var po = observe('first-input', entryHandler );\n  if (po) {\n    report = bindReporter(onReport, metric, reportAllChanges);\n    onHidden(() => {\n      po.takeRecords().map(entryHandler );\n      po.disconnect();\n    }, true);\n  }\n};\n\n\n//# sourceMappingURL=getFID.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/web-vitals/getLCP.js\n\n\n\n\n\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// https://wicg.github.io/largest-contentful-paint/#sec-largest-contentful-paint-interface\n\nvar reportedMetricIDs = {};\n\nvar getLCP = (onReport, reportAllChanges) => {\n  var visibilityWatcher = getVisibilityWatcher();\n  var metric = initMetric('LCP');\n  let report;\n\n  var entryHandler = (entry) => {\n    // The startTime attribute returns the value of the renderTime if it is not 0,\n    // and the value of the loadTime otherwise.\n    var value = entry.startTime;\n\n    // If the page was hidden prior to paint time of the entry,\n    // ignore it and mark the metric as final, otherwise add the entry.\n    if (value < visibilityWatcher.firstHiddenTime) {\n      metric.value = value;\n      metric.entries.push(entry);\n    }\n\n    if (report) {\n      report();\n    }\n  };\n\n  var po = observe('largest-contentful-paint', entryHandler);\n\n  if (po) {\n    report = bindReporter(onReport, metric, reportAllChanges);\n\n    var stopListening = () => {\n      if (!reportedMetricIDs[metric.id]) {\n        po.takeRecords().map(entryHandler );\n        po.disconnect();\n        reportedMetricIDs[metric.id] = true;\n        report(true);\n      }\n    };\n\n    // Stop listening after input. Note: while scrolling is an input that\n    // stop LCP observation, it's unreliable since it can be programmatically\n    // generated. See: https://github.com/GoogleChrome/web-vitals/issues/75\n    ['keydown', 'click'].forEach(type => {\n      addEventListener(type, stopListening, { once: true, capture: true });\n    });\n\n    onHidden(stopListening, true);\n  }\n};\n\n\n//# sourceMappingURL=getLCP.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/metrics/utils.js\n/**\n * Checks if a given value is a valid measurement value.\n */\nfunction isMeasurementValue(value) {\n  return typeof value === 'number' && isFinite(value);\n}\n\n/**\n * Helper function to start child on transactions. This function will make sure that the transaction will\n * use the start timestamp of the created child span if it is earlier than the transactions actual\n * start timestamp.\n */\nfunction _startChild(transaction, { startTimestamp, ...ctx }) {\n  if (startTimestamp && transaction.startTimestamp > startTimestamp) {\n    transaction.startTimestamp = startTimestamp;\n  }\n\n  return transaction.startChild({\n    startTimestamp,\n    ...ctx,\n  });\n}\n\n\n//# sourceMappingURL=utils.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/metrics/index.js\n\n\n\n\n\n\n\n\n\n\nvar metrics_global = (0,esm_global/* getGlobalObject */.R)();\n\nfunction getBrowserPerformanceAPI() {\n  return metrics_global && metrics_global.addEventListener && metrics_global.performance;\n}\n\nlet _performanceCursor = 0;\n\nlet _measurements = {};\nlet _lcpEntry;\nlet _clsEntry;\n\n/**\n * Start tracking web vitals\n */\nfunction startTrackingWebVitals(reportAllChanges = false) {\n  var performance = getBrowserPerformanceAPI();\n  if (performance && time/* browserPerformanceTimeOrigin */.Z1) {\n    if (performance.mark) {\n      metrics_global.performance.mark('sentry-tracing-init');\n    }\n    _trackCLS();\n    _trackLCP(reportAllChanges);\n    _trackFID();\n  }\n}\n\n/**\n * Start tracking long tasks.\n */\nfunction startTrackingLongTasks() {\n  var entryHandler = (entry) => {\n    var transaction = (0,utils/* getActiveTransaction */.x1)() ;\n    if (!transaction) {\n      return;\n    }\n    var startTime = (0,utils/* msToSec */.XL)((time/* browserPerformanceTimeOrigin */.Z1 ) + entry.startTime);\n    var duration = (0,utils/* msToSec */.XL)(entry.duration);\n    transaction.startChild({\n      description: 'Main UI thread blocked',\n      op: 'ui.long-task',\n      startTimestamp: startTime,\n      endTimestamp: startTime + duration,\n    });\n  };\n\n  observe('longtask', entryHandler);\n}\n\n/** Starts tracking the Cumulative Layout Shift on the current page. */\nfunction _trackCLS() {\n  // See:\n  // https://web.dev/evolving-cls/\n  // https://web.dev/cls-web-tooling/\n  getCLS(metric => {\n    var entry = metric.entries.pop();\n    if (!entry) {\n      return;\n    }\n\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.log */.kg.log('[Measurements] Adding CLS');\n    _measurements['cls'] = { value: metric.value, unit: '' };\n    _clsEntry = entry ;\n  });\n}\n\n/** Starts tracking the Largest Contentful Paint on the current page. */\nfunction _trackLCP(reportAllChanges) {\n  getLCP(metric => {\n    var entry = metric.entries.pop();\n    if (!entry) {\n      return;\n    }\n\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.log */.kg.log('[Measurements] Adding LCP');\n    _measurements['lcp'] = { value: metric.value, unit: 'millisecond' };\n    _lcpEntry = entry ;\n  }, reportAllChanges);\n}\n\n/** Starts tracking the First Input Delay on the current page. */\nfunction _trackFID() {\n  getFID(metric => {\n    var entry = metric.entries.pop();\n    if (!entry) {\n      return;\n    }\n\n    var timeOrigin = (0,utils/* msToSec */.XL)(time/* browserPerformanceTimeOrigin */.Z1 );\n    var startTime = (0,utils/* msToSec */.XL)(entry.startTime);\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.log */.kg.log('[Measurements] Adding FID');\n    _measurements['fid'] = { value: metric.value, unit: 'millisecond' };\n    _measurements['mark.fid'] = { value: timeOrigin + startTime, unit: 'second' };\n  });\n}\n\n/** Add performance related spans to a transaction */\nfunction addPerformanceEntries(transaction) {\n  var performance = getBrowserPerformanceAPI();\n  if (!performance || !metrics_global.performance.getEntries || !time/* browserPerformanceTimeOrigin */.Z1) {\n    // Gatekeeper if performance API not available\n    return;\n  }\n\n  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.log */.kg.log('[Tracing] Adding & adjusting spans using Performance API');\n  var timeOrigin = (0,utils/* msToSec */.XL)(time/* browserPerformanceTimeOrigin */.Z1);\n\n  var performanceEntries = performance.getEntries();\n\n  let responseStartTimestamp;\n  let requestStartTimestamp;\n\n    performanceEntries.slice(_performanceCursor).forEach((entry) => {\n    var startTime = (0,utils/* msToSec */.XL)(entry.startTime);\n    var duration = (0,utils/* msToSec */.XL)(entry.duration);\n\n    if (transaction.op === 'navigation' && timeOrigin + startTime < transaction.startTimestamp) {\n      return;\n    }\n\n    switch (entry.entryType) {\n      case 'navigation': {\n        _addNavigationSpans(transaction, entry, timeOrigin);\n        responseStartTimestamp = timeOrigin + (0,utils/* msToSec */.XL)(entry.responseStart);\n        requestStartTimestamp = timeOrigin + (0,utils/* msToSec */.XL)(entry.requestStart);\n        break;\n      }\n      case 'mark':\n      case 'paint':\n      case 'measure': {\n        _addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);\n\n        // capture web vitals\n        var firstHidden = getVisibilityWatcher();\n        // Only report if the page wasn't hidden prior to the web vital.\n        var shouldRecord = entry.startTime < firstHidden.firstHiddenTime;\n\n        if (entry.name === 'first-paint' && shouldRecord) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.log */.kg.log('[Measurements] Adding FP');\n          _measurements['fp'] = { value: entry.startTime, unit: 'millisecond' };\n        }\n        if (entry.name === 'first-contentful-paint' && shouldRecord) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.log */.kg.log('[Measurements] Adding FCP');\n          _measurements['fcp'] = { value: entry.startTime, unit: 'millisecond' };\n        }\n        break;\n      }\n      case 'resource': {\n        var resourceName = (entry.name ).replace(metrics_global.location.origin, '');\n        _addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);\n        break;\n      }\n      default:\n      // Ignore other entry types.\n    }\n  });\n\n  _performanceCursor = Math.max(performanceEntries.length - 1, 0);\n\n  _trackNavigator(transaction);\n\n  // Measurements are only available for pageload transactions\n  if (transaction.op === 'pageload') {\n    // Generate TTFB (Time to First Byte), which measured as the time between the beginning of the transaction and the\n    // start of the response in milliseconds\n    if (typeof responseStartTimestamp === 'number') {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.log */.kg.log('[Measurements] Adding TTFB');\n      _measurements['ttfb'] = {\n        value: (responseStartTimestamp - transaction.startTimestamp) * 1000,\n        unit: 'millisecond',\n      };\n\n      if (typeof requestStartTimestamp === 'number' && requestStartTimestamp <= responseStartTimestamp) {\n        // Capture the time spent making the request and receiving the first byte of the response.\n        // This is the time between the start of the request and the start of the response in milliseconds.\n        _measurements['ttfb.requestTime'] = {\n          value: (responseStartTimestamp - requestStartTimestamp) * 1000,\n          unit: 'millisecond',\n        };\n      }\n    }\n\n    ['fcp', 'fp', 'lcp'].forEach(name => {\n      if (!_measurements[name] || timeOrigin >= transaction.startTimestamp) {\n        return;\n      }\n      // The web vitals, fcp, fp, lcp, and ttfb, all measure relative to timeOrigin.\n      // Unfortunately, timeOrigin is not captured within the transaction span data, so these web vitals will need\n      // to be adjusted to be relative to transaction.startTimestamp.\n      var oldValue = _measurements[name].value;\n      var measurementTimestamp = timeOrigin + (0,utils/* msToSec */.XL)(oldValue);\n\n      // normalizedValue should be in milliseconds\n      var normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1000);\n      var delta = normalizedValue - oldValue;\n\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        esm_logger/* logger.log */.kg.log(`[Measurements] Normalized ${name} from ${oldValue} to ${normalizedValue} (${delta})`);\n      _measurements[name].value = normalizedValue;\n    });\n\n    var fidMark = _measurements['mark.fid'];\n    if (fidMark && _measurements['fid']) {\n      // create span for FID\n      _startChild(transaction, {\n        description: 'first input delay',\n        endTimestamp: fidMark.value + (0,utils/* msToSec */.XL)(_measurements['fid'].value),\n        op: 'web.vitals',\n        startTimestamp: fidMark.value,\n      });\n\n      // Delete mark.fid as we don't want it to be part of final payload\n      delete _measurements['mark.fid'];\n    }\n\n    // If FCP is not recorded we should not record the cls value\n    // according to the new definition of CLS.\n    if (!('fcp' in _measurements)) {\n      delete _measurements.cls;\n    }\n\n    Object.keys(_measurements).forEach(measurementName => {\n      transaction.setMeasurement(\n        measurementName,\n        _measurements[measurementName].value,\n        _measurements[measurementName].unit,\n      );\n    });\n\n    _tagMetricInfo(transaction);\n  }\n\n  _lcpEntry = undefined;\n  _clsEntry = undefined;\n  _measurements = {};\n}\n\n/** Create measure related spans */\nfunction _addMeasureSpans(\n  transaction,\n    entry,\n  startTime,\n  duration,\n  timeOrigin,\n) {\n  var measureStartTimestamp = timeOrigin + startTime;\n  var measureEndTimestamp = measureStartTimestamp + duration;\n\n  _startChild(transaction, {\n    description: entry.name ,\n    endTimestamp: measureEndTimestamp,\n    op: entry.entryType ,\n    startTimestamp: measureStartTimestamp,\n  });\n\n  return measureStartTimestamp;\n}\n\n/** Instrument navigation entries */\nfunction _addNavigationSpans(transaction, entry, timeOrigin) {\n  ['unloadEvent', 'redirect', 'domContentLoadedEvent', 'loadEvent', 'connect'].forEach(event => {\n    _addPerformanceNavigationTiming(transaction, entry, event, timeOrigin);\n  });\n  _addPerformanceNavigationTiming(transaction, entry, 'secureConnection', timeOrigin, 'TLS/SSL', 'connectEnd');\n  _addPerformanceNavigationTiming(transaction, entry, 'fetch', timeOrigin, 'cache', 'domainLookupStart');\n  _addPerformanceNavigationTiming(transaction, entry, 'domainLookup', timeOrigin, 'DNS');\n  _addRequest(transaction, entry, timeOrigin);\n}\n\n/** Create performance navigation related spans */\nfunction _addPerformanceNavigationTiming(\n  transaction,\n    entry,\n  event,\n  timeOrigin,\n  description,\n  eventEnd,\n) {\n  var end = eventEnd ? (entry[eventEnd] ) : (entry[`${event}End`] );\n  var start = entry[`${event}Start`] ;\n  if (!start || !end) {\n    return;\n  }\n  _startChild(transaction, {\n    op: 'browser',\n    description: (0,_nullishCoalesce/* _nullishCoalesce */.h)(description, () => ( event)),\n    startTimestamp: timeOrigin + (0,utils/* msToSec */.XL)(start),\n    endTimestamp: timeOrigin + (0,utils/* msToSec */.XL)(end),\n  });\n}\n\n/** Create request and response related spans */\nfunction _addRequest(transaction, entry, timeOrigin) {\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'request',\n    startTimestamp: timeOrigin + (0,utils/* msToSec */.XL)(entry.requestStart ),\n    endTimestamp: timeOrigin + (0,utils/* msToSec */.XL)(entry.responseEnd ),\n  });\n\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'response',\n    startTimestamp: timeOrigin + (0,utils/* msToSec */.XL)(entry.responseStart ),\n    endTimestamp: timeOrigin + (0,utils/* msToSec */.XL)(entry.responseEnd ),\n  });\n}\n\n/** Create resource-related spans */\nfunction _addResourceSpans(\n  transaction,\n  entry,\n  resourceName,\n  startTime,\n  duration,\n  timeOrigin,\n) {\n  // we already instrument based on fetch and xhr, so we don't need to\n  // duplicate spans here.\n  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {\n    return;\n  }\n\n    var data = {};\n  if ('transferSize' in entry) {\n    data['Transfer Size'] = entry.transferSize;\n  }\n  if ('encodedBodySize' in entry) {\n    data['Encoded Body Size'] = entry.encodedBodySize;\n  }\n  if ('decodedBodySize' in entry) {\n    data['Decoded Body Size'] = entry.decodedBodySize;\n  }\n\n  var startTimestamp = timeOrigin + startTime;\n  var endTimestamp = startTimestamp + duration;\n\n  _startChild(transaction, {\n    description: resourceName,\n    endTimestamp,\n    op: entry.initiatorType ? `resource.${entry.initiatorType}` : 'resource',\n    startTimestamp,\n    data,\n  });\n}\n\n/**\n * Capture the information of the user agent.\n */\nfunction _trackNavigator(transaction) {\n  var navigator = metrics_global.navigator ;\n  if (!navigator) {\n    return;\n  }\n\n  // track network connectivity\n  var connection = navigator.connection;\n  if (connection) {\n    if (connection.effectiveType) {\n      transaction.setTag('effectiveConnectionType', connection.effectiveType);\n    }\n\n    if (connection.type) {\n      transaction.setTag('connectionType', connection.type);\n    }\n\n    if (isMeasurementValue(connection.rtt)) {\n      _measurements['connection.rtt'] = { value: connection.rtt, unit: 'millisecond' };\n    }\n\n    if (isMeasurementValue(connection.downlink)) {\n      _measurements['connection.downlink'] = { value: connection.downlink, unit: '' }; // unit is empty string for now, while relay doesn't support download speed units\n    }\n  }\n\n  if (isMeasurementValue(navigator.deviceMemory)) {\n    transaction.setTag('deviceMemory', `${navigator.deviceMemory} GB`);\n  }\n\n  if (isMeasurementValue(navigator.hardwareConcurrency)) {\n    transaction.setTag('hardwareConcurrency', String(navigator.hardwareConcurrency));\n  }\n}\n\n/** Add LCP / CLS data to transaction to allow debugging */\nfunction _tagMetricInfo(transaction) {\n  if (_lcpEntry) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.log */.kg.log('[Measurements] Adding LCP Data');\n\n    // Capture Properties of the LCP element that contributes to the LCP.\n\n    if (_lcpEntry.element) {\n      transaction.setTag('lcp.element', (0,browser/* htmlTreeAsString */.Rt)(_lcpEntry.element));\n    }\n\n    if (_lcpEntry.id) {\n      transaction.setTag('lcp.id', _lcpEntry.id);\n    }\n\n    if (_lcpEntry.url) {\n      // Trim URL to the first 200 characters.\n      transaction.setTag('lcp.url', _lcpEntry.url.trim().slice(0, 200));\n    }\n\n    transaction.setTag('lcp.size', _lcpEntry.size);\n  }\n\n  // See: https://developer.mozilla.org/en-US/docs/Web/API/LayoutShift\n  if (_clsEntry && _clsEntry.sources) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.log */.kg.log('[Measurements] Adding CLS Data');\n    _clsEntry.sources.forEach((source, index) =>\n      transaction.setTag(`cls.source.${index + 1}`, (0,browser/* htmlTreeAsString */.Rt)(source.node)),\n    );\n  }\n}\n\n\n//# sourceMappingURL=index.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/request.js\n\n\n\nvar DEFAULT_TRACING_ORIGINS = ['localhost', /^\\//];\n\n/** Options for Request Instrumentation */\n\nvar defaultRequestInstrumentationOptions = {\n  traceFetch: true,\n  traceXHR: true,\n  tracingOrigins: DEFAULT_TRACING_ORIGINS,\n};\n\n/** Registers span creators for xhr and fetch requests  */\nfunction instrumentOutgoingRequests(_options) {\n    const { traceFetch, traceXHR, tracingOrigins, shouldCreateSpanForRequest } = {\n    ...defaultRequestInstrumentationOptions,\n    ..._options,\n  };\n\n  // We should cache url -> decision so that we don't have to compute\n  // regexp everytime we create a request.\n  var urlMap = {};\n\n  var defaultShouldCreateSpan = (url) => {\n    if (urlMap[url]) {\n      return urlMap[url];\n    }\n    var origins = tracingOrigins;\n    urlMap[url] =\n      origins.some((origin) => (0,string/* isMatchingPattern */.zC)(url, origin)) &&\n      !(0,string/* isMatchingPattern */.zC)(url, 'sentry_key');\n    return urlMap[url];\n  };\n\n  // We want that our users don't have to re-implement shouldCreateSpanForRequest themselves\n  // That's why we filter out already unwanted Spans from tracingOrigins\n  let shouldCreateSpan = defaultShouldCreateSpan;\n  if (typeof shouldCreateSpanForRequest === 'function') {\n    shouldCreateSpan = (url) => {\n      return defaultShouldCreateSpan(url) && shouldCreateSpanForRequest(url);\n    };\n  }\n\n  var spans = {};\n\n  if (traceFetch) {\n    (0,instrument/* addInstrumentationHandler */.o)('fetch', (handlerData) => {\n      fetchCallback(handlerData, shouldCreateSpan, spans);\n    });\n  }\n\n  if (traceXHR) {\n    (0,instrument/* addInstrumentationHandler */.o)('xhr', (handlerData) => {\n      xhrCallback(handlerData, shouldCreateSpan, spans);\n    });\n  }\n}\n\n/**\n * Create and track fetch request spans\n */\nfunction fetchCallback(\n  handlerData,\n  shouldCreateSpan,\n  spans,\n) {\n  if (!(0,utils/* hasTracingEnabled */.zu)() || !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) {\n    return;\n  }\n\n  if (handlerData.endTimestamp) {\n    var spanId = handlerData.fetchData.__span;\n    if (!spanId) return;\n\n    var span = spans[spanId];\n    if (span) {\n      if (handlerData.response) {\n        // TODO (kmclb) remove this once types PR goes through\n                span.setHttpStatus(handlerData.response.status);\n      } else if (handlerData.error) {\n        span.setStatus('internal_error');\n      }\n      span.finish();\n\n            delete spans[spanId];\n    }\n    return;\n  }\n\n  var activeTransaction = (0,utils/* getActiveTransaction */.x1)();\n  if (activeTransaction) {\n    var span = activeTransaction.startChild({\n      data: {\n        ...handlerData.fetchData,\n        type: 'fetch',\n      },\n      description: `${handlerData.fetchData.method} ${handlerData.fetchData.url}`,\n      op: 'http.client',\n    });\n\n    handlerData.fetchData.__span = span.spanId;\n    spans[span.spanId] = span;\n\n    var request = handlerData.args[0];\n\n    // In case the user hasn't set the second argument of a fetch call we default it to `{}`.\n    handlerData.args[1] = handlerData.args[1] || {};\n\n        var options = handlerData.args[1];\n\n    options.headers = addTracingHeadersToFetchRequest(\n      request,\n      activeTransaction.getDynamicSamplingContext(),\n      span,\n      options,\n    );\n\n    activeTransaction.metadata.propagations += 1;\n  }\n}\n\nfunction addTracingHeadersToFetchRequest(\n  request,\n  dynamicSamplingContext,\n  span,\n  options\n\n,\n) {\n  var sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);\n  var sentryTraceHeader = span.toTraceparent();\n\n  var headers =\n    typeof Request !== 'undefined' && (0,is/* isInstanceOf */.V9)(request, Request) ? (request ).headers : options.headers;\n\n  if (!headers) {\n    return { 'sentry-trace': sentryTraceHeader, baggage: sentryBaggageHeader };\n  } else if (typeof Headers !== 'undefined' && (0,is/* isInstanceOf */.V9)(headers, Headers)) {\n    var newHeaders = new Headers(headers );\n\n    newHeaders.append('sentry-trace', sentryTraceHeader);\n\n    if (sentryBaggageHeader) {\n      // If the same header is appended miultiple times the browser will merge the values into a single request header.\n      // Its therefore safe to simply push a \"baggage\" entry, even though there might already be another baggage header.\n      newHeaders.append(BAGGAGE_HEADER_NAME, sentryBaggageHeader);\n    }\n\n    return newHeaders ;\n  } else if (Array.isArray(headers)) {\n    var newHeaders = [...headers, ['sentry-trace', sentryTraceHeader]];\n\n    if (sentryBaggageHeader) {\n      // If there are multiple entries with the same key, the browser will merge the values into a single request header.\n      // Its therefore safe to simply push a \"baggage\" entry, even though there might already be another baggage header.\n      newHeaders.push([BAGGAGE_HEADER_NAME, sentryBaggageHeader]);\n    }\n\n    return newHeaders;\n  } else {\n    var existingBaggageHeader = 'baggage' in headers ? headers.baggage : undefined;\n    var newBaggageHeaders = [];\n\n    if (Array.isArray(existingBaggageHeader)) {\n      newBaggageHeaders.push(...existingBaggageHeader);\n    } else if (existingBaggageHeader) {\n      newBaggageHeaders.push(existingBaggageHeader);\n    }\n\n    if (sentryBaggageHeader) {\n      newBaggageHeaders.push(sentryBaggageHeader);\n    }\n\n    return {\n      ...(headers ),\n      'sentry-trace': sentryTraceHeader,\n      baggage: newBaggageHeaders.length > 0 ? newBaggageHeaders.join(',') : undefined,\n    };\n  }\n}\n\n/**\n * Create and track xhr request spans\n */\nfunction xhrCallback(\n  handlerData,\n  shouldCreateSpan,\n  spans,\n) {\n  if (\n    !(0,utils/* hasTracingEnabled */.zu)() ||\n    (handlerData.xhr && handlerData.xhr.__sentry_own_request__) ||\n    !(handlerData.xhr && handlerData.xhr.__sentry_xhr__ && shouldCreateSpan(handlerData.xhr.__sentry_xhr__.url))\n  ) {\n    return;\n  }\n\n  var xhr = handlerData.xhr.__sentry_xhr__;\n\n  // check first if the request has finished and is tracked by an existing span which should now end\n  if (handlerData.endTimestamp) {\n    var spanId = handlerData.xhr.__sentry_xhr_span_id__;\n    if (!spanId) return;\n\n    var span = spans[spanId];\n    if (span) {\n      span.setHttpStatus(xhr.status_code);\n      span.finish();\n\n            delete spans[spanId];\n    }\n    return;\n  }\n\n  // if not, create a new span to track it\n  var activeTransaction = (0,utils/* getActiveTransaction */.x1)();\n  if (activeTransaction) {\n    var span = activeTransaction.startChild({\n      data: {\n        ...xhr.data,\n        type: 'xhr',\n        method: xhr.method,\n        url: xhr.url,\n      },\n      description: `${xhr.method} ${xhr.url}`,\n      op: 'http.client',\n    });\n\n    handlerData.xhr.__sentry_xhr_span_id__ = span.spanId;\n    spans[handlerData.xhr.__sentry_xhr_span_id__] = span;\n\n    if (handlerData.xhr.setRequestHeader) {\n      try {\n        handlerData.xhr.setRequestHeader('sentry-trace', span.toTraceparent());\n\n        var dynamicSamplingContext = activeTransaction.getDynamicSamplingContext();\n        var sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);\n\n        if (sentryBaggageHeader) {\n          // From MDN: \"If this method is called several times with the same header, the values are merged into one single request header.\"\n          // We can therefore simply set a baggage header without checking what was there before\n          // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader\n          handlerData.xhr.setRequestHeader(BAGGAGE_HEADER_NAME, sentryBaggageHeader);\n        }\n\n        activeTransaction.metadata.propagations += 1;\n      } catch (_) {\n        // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n      }\n    }\n  }\n}\n\n\n//# sourceMappingURL=request.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/router.js\n\n\nvar router_global = (0,esm_global/* getGlobalObject */.R)();\n\n/**\n * Default function implementing pageload and navigation transactions\n */\nfunction instrumentRoutingWithDefaults(\n  customStartTransaction,\n  startTransactionOnPageLoad = true,\n  startTransactionOnLocationChange = true,\n) {\n  if (!router_global || !router_global.location) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.warn */.kg.warn('Could not initialize routing instrumentation due to invalid location');\n    return;\n  }\n\n  let startingUrl = router_global.location.href;\n\n  let activeTransaction;\n  if (startTransactionOnPageLoad) {\n    activeTransaction = customStartTransaction({\n      name: router_global.location.pathname,\n      op: 'pageload',\n      metadata: { source: 'url' },\n    });\n  }\n\n  if (startTransactionOnLocationChange) {\n    (0,instrument/* addInstrumentationHandler */.o)('history', ({ to, from }) => {\n      /**\n       * This early return is there to account for some cases where a navigation transaction starts right after\n       * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't\n       * create an uneccessary navigation transaction.\n       *\n       * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also\n       * only be caused in certain development environments where the usage of a hot module reloader is causing\n       * errors.\n       */\n      if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {\n        startingUrl = undefined;\n        return;\n      }\n\n      if (from !== to) {\n        startingUrl = undefined;\n        if (activeTransaction) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.log */.kg.log(`[Tracing] Finishing current transaction with op: ${activeTransaction.op}`);\n          // If there's an open transaction on the scope, we need to finish it before creating an new one.\n          activeTransaction.finish();\n        }\n        activeTransaction = customStartTransaction({\n          name: router_global.location.pathname,\n          op: 'navigation',\n          metadata: { source: 'url' },\n        });\n      }\n    });\n  }\n}\n\n\n//# sourceMappingURL=router.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/browsertracing.js\n\n\n\n\n\n\n\n\n\n\nvar BROWSER_TRACING_INTEGRATION_ID = 'BrowserTracing';\n\n/** Options for Browser Tracing integration */\n\nvar DEFAULT_BROWSER_TRACING_OPTIONS = {\n  idleTimeout: idletransaction/* DEFAULT_IDLE_TIMEOUT */.nT,\n  finalTimeout: idletransaction/* DEFAULT_FINAL_TIMEOUT */.mg,\n  markBackgroundTransactions: true,\n  routingInstrumentation: instrumentRoutingWithDefaults,\n  startTransactionOnLocationChange: true,\n  startTransactionOnPageLoad: true,\n  _experiments: { enableLongTask: true },\n  ...defaultRequestInstrumentationOptions,\n};\n\n/**\n * The Browser Tracing integration automatically instruments browser pageload/navigation\n * actions as transactions, and captures requests, metrics and errors as spans.\n *\n * The integration can be configured with a variety of options, and can be extended to use\n * any routing library. This integration uses {@see IdleTransaction} to create transactions.\n */\nclass BrowserTracing  {\n  // This class currently doesn't have a static `id` field like the other integration classes, because it prevented\n  // @sentry/tracing from being treeshaken. Tree shakers do not like static fields, because they behave like side effects.\n  // TODO: Come up with a better plan, than using static fields on integration classes, and use that plan on all\n  // integrations.\n\n  /** Browser Tracing integration options */\n  \n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = BROWSER_TRACING_INTEGRATION_ID;}\n\n   constructor(_options) {;BrowserTracing.prototype.__init.call(this);\n    let tracingOrigins = defaultRequestInstrumentationOptions.tracingOrigins;\n    // NOTE: Logger doesn't work in constructors, as it's initialized after integrations instances\n    if (_options) {\n      if (_options.tracingOrigins && Array.isArray(_options.tracingOrigins)) {\n        tracingOrigins = _options.tracingOrigins;\n      } else {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && (this._emitOptionsWarning = true);\n      }\n    }\n\n    this.options = {\n      ...DEFAULT_BROWSER_TRACING_OPTIONS,\n      ..._options,\n      tracingOrigins,\n    };\n\n    const { _metricOptions } = this.options;\n    startTrackingWebVitals(_metricOptions && _metricOptions._reportAllChanges);\n    if ((0,_optionalChain/* _optionalChain */.x)([this, 'access', _2 => _2.options, 'access', _3 => _3._experiments, 'optionalAccess', _4 => _4.enableLongTask])) {\n      startTrackingLongTasks();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setupOnce(_, getCurrentHub) {\n    this._getCurrentHub = getCurrentHub;\n\n    if (this._emitOptionsWarning) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        esm_logger/* logger.warn */.kg.warn(\n          '[Tracing] You need to define `tracingOrigins` in the options. Set an array of urls or patterns to trace.',\n        );\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        esm_logger/* logger.warn */.kg.warn(\n          `[Tracing] We added a reasonable default for you: ${defaultRequestInstrumentationOptions.tracingOrigins}`,\n        );\n    }\n\n        const {\n      routingInstrumentation: instrumentRouting,\n      startTransactionOnLocationChange,\n      startTransactionOnPageLoad,\n      markBackgroundTransactions,\n      traceFetch,\n      traceXHR,\n      tracingOrigins,\n      shouldCreateSpanForRequest,\n    } = this.options;\n\n    instrumentRouting(\n      (context) => this._createRouteTransaction(context),\n      startTransactionOnPageLoad,\n      startTransactionOnLocationChange,\n    );\n\n    if (markBackgroundTransactions) {\n      registerBackgroundTabDetection();\n    }\n\n    instrumentOutgoingRequests({ traceFetch, traceXHR, tracingOrigins, shouldCreateSpanForRequest });\n  }\n\n  /** Create routing idle transaction. */\n   _createRouteTransaction(context) {\n    if (!this._getCurrentHub) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        esm_logger/* logger.warn */.kg.warn(`[Tracing] Did not create ${context.op} transaction because _getCurrentHub is invalid.`);\n      return undefined;\n    }\n\n        const { beforeNavigate, idleTimeout, finalTimeout } = this.options;\n\n    var isPageloadTransaction = context.op === 'pageload';\n\n    var sentryTraceMetaTagValue = isPageloadTransaction ? getMetaContent('sentry-trace') : null;\n    var baggageMetaTagValue = isPageloadTransaction ? getMetaContent('baggage') : null;\n\n    var traceParentData = sentryTraceMetaTagValue ? extractTraceparentData(sentryTraceMetaTagValue) : undefined;\n    var dynamicSamplingContext = baggageMetaTagValue\n      ? baggageHeaderToDynamicSamplingContext(baggageMetaTagValue)\n      : undefined;\n\n    var expandedContext = {\n      ...context,\n      ...traceParentData,\n      metadata: {\n        ...context.metadata,\n        dynamicSamplingContext: traceParentData && !dynamicSamplingContext ? {} : dynamicSamplingContext,\n      },\n      trimEnd: true,\n    };\n\n    var modifiedContext = typeof beforeNavigate === 'function' ? beforeNavigate(expandedContext) : expandedContext;\n\n    // For backwards compatibility reasons, beforeNavigate can return undefined to \"drop\" the transaction (prevent it\n    // from being sent to Sentry).\n    var finalContext = modifiedContext === undefined ? { ...expandedContext, sampled: false } : modifiedContext;\n\n    // If `beforeNavigate` set a custom name, record that fact\n    finalContext.metadata =\n      finalContext.name !== expandedContext.name\n        ? { ...finalContext.metadata, source: 'custom' }\n        : finalContext.metadata;\n\n    if (finalContext.sampled === false) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        esm_logger/* logger.log */.kg.log(`[Tracing] Will not send ${finalContext.op} transaction because of beforeNavigate.`);\n    }\n\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.log */.kg.log(`[Tracing] Starting ${finalContext.op} transaction on scope`);\n\n    var hub = this._getCurrentHub();\n    const { location } = (0,esm_global/* getGlobalObject */.R)() ;\n\n    var idleTransaction = (0,hubextensions/* startIdleTransaction */.lb)(\n      hub,\n      finalContext,\n      idleTimeout,\n      finalTimeout,\n      true,\n      { location }, // for use in the tracesSampler\n    );\n    idleTransaction.registerBeforeFinishCallback(transaction => {\n      addPerformanceEntries(transaction);\n      transaction.setTag(\n        'sentry_reportAllChanges',\n        Boolean(this.options._metricOptions && this.options._metricOptions._reportAllChanges),\n      );\n    });\n\n    return idleTransaction ;\n  }\n}\n\n/** Returns the value of a meta tag */\nfunction getMetaContent(metaName) {\n  // Can't specify generic to `getDomElement` because tracing can be used\n  // in a variety of environments, have to disable `no-unsafe-member-access`\n  // as a result.\n  var metaTag = (0,browser/* getDomElement */.qT)(`meta[name=${metaName}]`);\n    return metaTag ? metaTag.getAttribute('content') : null;\n}\n\n\n//# sourceMappingURL=browsertracing.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n;\n;\n\n// Treeshakable guard to remove all code related to tracing\n\n// Guard for tree\nif (typeof __SENTRY_TRACING__ === 'undefined' || __SENTRY_TRACING__) {\n  // We are patching the global object with our hub extension methods\n  (0,hubextensions/* addExtensionMethods */.ro)();\n}\n//# sourceMappingURL=index.js.map\n\n// EXTERNAL MODULE: ./node_modules/next/router.js\nvar router = __webpack_require__(1163);\nvar router_default = /*#__PURE__*/__webpack_require__.n(router);\n;// CONCATENATED MODULE: ./node_modules/@sentry/nextjs/esm/performance/client.js\n\n\n\n\nvar client_global = (0,esm_global/* getGlobalObject */.R)\n\n();\n\n/**\n * Every Next.js page (static and dynamic ones) comes with a script tag with the id \"__NEXT_DATA__\". This script tag\n * contains a JSON object with data that was either generated at build time for static pages (`getStaticProps`), or at\n * runtime with data fetchers like `getServerSideProps.`.\n *\n * We can use this information to:\n * - Always get the parameterized route we're in when loading a page.\n * - Send trace information (trace-id, baggage) from the server to the client.\n *\n * This function extracts this information.\n */\nfunction extractNextDataTagInformation() {\n  let nextData;\n  // Let's be on the safe side and actually check first if there is really a __NEXT_DATA__ script tag on the page.\n  // Theoretically this should always be the case though.\n  var nextDataTag = client_global.document.getElementById('__NEXT_DATA__');\n  if (nextDataTag && nextDataTag.innerHTML) {\n    try {\n      nextData = JSON.parse(nextDataTag.innerHTML);\n    } catch (e) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && esm_logger/* logger.warn */.kg.warn('Could not extract __NEXT_DATA__');\n    }\n  }\n\n  if (!nextData) {\n    return {};\n  }\n\n  var nextDataTagInfo = {};\n\n  const { page, query, props } = nextData;\n\n  // `nextData.page` always contains the parameterized route - except for when an error occurs in a data fetching\n  // function, then it is \"/_error\", but that isn't a problem since users know which route threw by looking at the\n  // parent transaction\n  // TODO: Actually this is a problem (even though it is not that big), because the DSC and the transaction payload will contain\n  // a different transaction name. Maybe we can fix this. Idea: Also send transaction name via pageProps when available.\n  nextDataTagInfo.route = page;\n  nextDataTagInfo.params = query;\n\n  if (props && props.pageProps) {\n    if (props.pageProps._sentryBaggage) {\n      nextDataTagInfo.baggage = props.pageProps._sentryBaggage;\n    }\n\n    if (props.pageProps._sentryTraceData) {\n      nextDataTagInfo.traceParentData = extractTraceparentData(props.pageProps._sentryTraceData);\n    }\n  }\n\n  return nextDataTagInfo;\n}\n\nvar DEFAULT_TAGS = {\n  'routing.instrumentation': 'next-router',\n} ;\n\n// We keep track of the active transaction so we can finish it when we start a navigation transaction.\nlet activeTransaction = undefined;\n\n// We keep track of the previous location name so we can set the `from` field on navigation transactions.\n// This is either a route or a pathname.\nlet prevLocationName = undefined;\n\nvar client = (0,esm_hub/* getCurrentHub */.Gd)().getClient();\n\n/**\n * Creates routing instrumention for Next Router. Only supported for\n * client side routing. Works for Next >= 10.\n *\n * Leverages the SingletonRouter from the `next/router` to\n * generate pageload/navigation transactions and parameterize\n * transaction names.\n */\nfunction nextRouterInstrumentation(\n  startTransactionCb,\n  startTransactionOnPageLoad = true,\n  startTransactionOnLocationChange = true,\n) {\n  const { route, traceParentData, baggage, params } = extractNextDataTagInformation();\n  prevLocationName = route || client_global.location.pathname;\n\n  if (startTransactionOnPageLoad) {\n    var source = route ? 'route' : 'url';\n    var dynamicSamplingContext = baggageHeaderToDynamicSamplingContext(baggage);\n\n    activeTransaction = startTransactionCb({\n      name: prevLocationName,\n      op: 'pageload',\n      tags: DEFAULT_TAGS,\n      ...(params && client && client.getOptions().sendDefaultPii && { data: params }),\n      ...traceParentData,\n      metadata: {\n        source,\n        dynamicSamplingContext: traceParentData && !dynamicSamplingContext ? {} : dynamicSamplingContext,\n      },\n    });\n  }\n\n  if (startTransactionOnLocationChange) {\n    router_default().events.on('routeChangeStart', (navigationTarget) => {\n      var matchedRoute = getNextRouteFromPathname((0,url/* stripUrlQueryAndFragment */.rt)(navigationTarget));\n\n      let transactionName;\n      let transactionSource;\n\n      if (matchedRoute) {\n        transactionName = matchedRoute;\n        transactionSource = 'route';\n      } else {\n        transactionName = navigationTarget;\n        transactionSource = 'url';\n      }\n\n      var tags = {\n        ...DEFAULT_TAGS,\n        from: prevLocationName,\n      };\n\n      prevLocationName = transactionName;\n\n      if (activeTransaction) {\n        activeTransaction.finish();\n      }\n\n      var navigationTransaction = startTransactionCb({\n        name: transactionName,\n        op: 'navigation',\n        tags,\n        metadata: { source: transactionSource },\n      });\n\n      if (navigationTransaction) {\n        // In addition to the navigation transaction we're also starting a span to mark Next.js's `routeChangeStart`\n        // and `routeChangeComplete` events.\n        // We don't want to finish the navigation transaction on `routeChangeComplete`, since users might want to attach\n        // spans to that transaction even after `routeChangeComplete` is fired (eg. HTTP requests in some useEffect\n        // hooks). Instead, we'll simply let the navigation transaction finish itself (it's an `IdleTransaction`).\n        var nextRouteChangeSpan = navigationTransaction.startChild({\n          op: 'ui.nextjs.route-change',\n          description: 'Next.js Route Change',\n        });\n\n        var finishRouteChangeSpan = () => {\n          nextRouteChangeSpan.finish();\n          router_default().events.off('routeChangeComplete', finishRouteChangeSpan);\n        };\n\n        router_default().events.on('routeChangeComplete', finishRouteChangeSpan);\n      }\n    });\n  }\n}\n\nfunction getNextRouteFromPathname(pathname) {\n  var pageRoutes = (client_global.__BUILD_MANIFEST || {}).sortedPages;\n\n  // Page route should in 99.999% of the cases be defined by now but just to be sure we make a check here\n  if (!pageRoutes) {\n    return;\n  }\n\n  return pageRoutes.find(route => {\n    var routeRegExp = convertNextRouteToRegExp(route);\n    return pathname.match(routeRegExp);\n  });\n}\n\n/**\n * Converts a Next.js style route to a regular expression that matches on pathnames (no query params or URL fragments).\n *\n * In general this involves replacing any instances of square brackets in a route with a wildcard:\n * e.g. \"/users/[id]/info\" becomes /\\/users\\/([^/]+?)\\/info/\n *\n * Some additional edgecases need to be considered:\n * - All routes have an optional slash at the end, meaning users can navigate to \"/users/[id]/info\" or\n *   \"/users/[id]/info/\" - both will be resolved to \"/users/[id]/info\".\n * - Non-optional \"catchall\"s at the end of a route must be considered when matching (e.g. \"/users/[...params]\").\n * - Optional \"catchall\"s at the end of a route must be considered when matching (e.g. \"/users/[[...params]]\").\n *\n * @param route A Next.js style route as it is found in `global.__BUILD_MANIFEST.sortedPages`\n */\nfunction convertNextRouteToRegExp(route) {\n  // We can assume a route is at least \"/\".\n  var routeParts = route.split('/');\n\n  let optionalCatchallWildcardRegex = '';\n  if (routeParts[routeParts.length - 1].match(/^\\[\\[\\.\\.\\..+\\]\\]$/)) {\n    // If last route part has pattern \"[[...xyz]]\" we pop the latest route part to get rid of the required trailing\n    // slash that would come before it if we didn't pop it.\n    routeParts.pop();\n    optionalCatchallWildcardRegex = '(?:/(.+?))?';\n  }\n\n  var rejoinedRouteParts = routeParts\n    .map(\n      routePart =>\n        routePart\n          .replace(/^\\[\\.\\.\\..+\\]$/, '(.+?)') // Replace catch all wildcard with regex wildcard\n          .replace(/^\\[.*\\]$/, '([^/]+?)'), // Replace route wildcards with lazy regex wildcards\n    )\n    .join('/');\n\n  return new RegExp(\n    `^${rejoinedRouteParts}${optionalCatchallWildcardRegex}(?:/)?$`, // optional slash at the end\n  );\n}\n\n\n//# sourceMappingURL=client.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/nextjs/esm/utils/metadata.js\n\n\nvar PACKAGE_NAME_PREFIX = 'npm:@sentry/';\n\n/**\n * A builder for the SDK metadata in the options for the SDK initialization.\n * @param options sdk options object that gets mutated\n * @param names list of package names\n */\nfunction buildMetadata(options, names) {\n  options._metadata = options._metadata || {};\n  options._metadata.sdk =\n    options._metadata.sdk ||\n    ({\n      name: 'sentry.javascript.nextjs',\n      packages: names.map(name => ({\n        name: `${PACKAGE_NAME_PREFIX}${name}`,\n        version: SDK_VERSION,\n      })),\n      version: SDK_VERSION,\n    } );\n}\n\n\n//# sourceMappingURL=metadata.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/nextjs/esm/utils/userIntegrations.js\n/**\n * Recursively traverses an object to update an existing nested key.\n * Note: The provided key path must include existing properties,\n * the function will not create objects while traversing.\n *\n * @param obj An object to update\n * @param value The value to update the nested key with\n * @param keyPath The path to the key to update ex. fizz.buzz.foo\n */\nfunction setNestedKey(obj, keyPath, value) {\n  // Ex. foo.bar.zoop will extract foo and bar.zoop\n  var match = keyPath.match(/([a-z_]+)\\.(.*)/i);\n  // The match will be null when there's no more recursing to do, i.e., when we've reached the right level of the object\n  if (match === null) {\n    obj[keyPath] = value;\n  } else {\n    // `match[1]` is the initial segment of the path, and `match[2]` is the remainder of the path\n    var innerObj = obj[match[1]];\n    setNestedKey(innerObj, match[2], value);\n  }\n}\n\n/**\n * Enforces inclusion of a given integration with specified options in an integration array originally determined by the\n * user, by either including the given default instance or by patching an existing user instance with the given options.\n *\n * Ideally this would happen when integrations are set up, but there isn't currently a mechanism there for merging\n * options from a default integration instance with those from a user-provided instance of the same integration, only\n * for allowing the user to override a default instance entirely. (TODO: Fix that.)\n *\n * @param defaultIntegrationInstance An instance of the integration with the correct options already set\n * @param userIntegrations Integrations defined by the user.\n * @param forcedOptions Options with which to patch an existing user-derived instance on the integration.\n * @returns A final integrations array.\n */\nfunction addOrUpdateIntegration(\n  defaultIntegrationInstance,\n  userIntegrations,\n  forcedOptions = {},\n) {\n  return Array.isArray(userIntegrations)\n    ? addOrUpdateIntegrationInArray(defaultIntegrationInstance, userIntegrations, forcedOptions)\n    : addOrUpdateIntegrationInFunction(defaultIntegrationInstance, userIntegrations, forcedOptions);\n}\n\nfunction addOrUpdateIntegrationInArray(\n  defaultIntegrationInstance,\n  userIntegrations,\n  forcedOptions,\n) {\n  var userInstance = userIntegrations.find(integration => integration.name === defaultIntegrationInstance.name);\n\n  if (userInstance) {\n    for (const [keyPath, value] of Object.entries(forcedOptions)) {\n      setNestedKey(userInstance, keyPath, value);\n    }\n\n    return userIntegrations;\n  }\n\n  return [...userIntegrations, defaultIntegrationInstance];\n}\n\nfunction addOrUpdateIntegrationInFunction(\n  defaultIntegrationInstance,\n  userIntegrationsFunc,\n  forcedOptions,\n) {\n  var wrapper = defaultIntegrations => {\n    var userFinalIntegrations = userIntegrationsFunc(defaultIntegrations);\n    return addOrUpdateIntegrationInArray(defaultIntegrationInstance, userFinalIntegrations, forcedOptions);\n  };\n  return wrapper;\n}\n\n\n//# sourceMappingURL=userIntegrations.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@sentry/nextjs/esm/index.client.js\n\n\n\n\n\n\n\n\n\n\n\n// Treeshakable guard to remove all code related to tracing\n\n/** Inits the Sentry NextJS SDK on the browser with the React SDK. */\nfunction index_client_init(options) {\n  buildMetadata(options, ['nextjs', 'react']);\n  options.environment = options.environment || \"production\";\n\n  let integrations = options.integrations;\n\n  // Guard below evaluates to true unless __SENTRY_TRACING__ is text-replaced with \"false\"\n  if (typeof __SENTRY_TRACING__ === 'undefined' || __SENTRY_TRACING__) {\n    // Only add BrowserTracing if a tracesSampleRate or tracesSampler is set\n    if (options.tracesSampleRate !== undefined || options.tracesSampler !== undefined) {\n      integrations = createClientIntegrations(options.integrations);\n    }\n  }\n\n  sdk_init({\n    ...options,\n    integrations,\n  });\n\n  (0,esm_exports/* configureScope */.e)(scope => {\n    scope.setTag('runtime', 'browser');\n    var filterTransactions = event =>\n      event.type === 'transaction' && event.transaction === '/404' ? null : event;\n    filterTransactions.id = 'NextClient404Filter';\n    scope.addEventProcessor(filterTransactions);\n  });\n}\n\nfunction createClientIntegrations(userIntegrations = []) {\n  var defaultBrowserTracingIntegration = new BrowserTracing({\n    tracingOrigins: [...defaultRequestInstrumentationOptions.tracingOrigins, /^(api\\/)/],\n    routingInstrumentation: nextRouterInstrumentation,\n  });\n\n  return addOrUpdateIntegration(defaultBrowserTracingIntegration, userIntegrations, {\n    'options.routingInstrumentation': nextRouterInstrumentation,\n  });\n}\n\n\n//# sourceMappingURL=index.client.js.map\n\n;// CONCATENATED MODULE: ./sentry.client.config.js\n/* provided dependency */ var process = __webpack_require__(3454);\n// This file configures the initialization of Sentry on the browser.\n// The config you add here will be used whenever a page is visited.\n// https://docs.sentry.io/platforms/javascript/guides/nextjs/\n\nvar SENTRY_DSN = process.env.SENTRY_DSN || process.env.NEXT_PUBLIC_SENTRY_DSN;\nindex_client_init({\n    dsn: SENTRY_DSN || \"https://2becbe2880ce41ed8198fd63c2cd490f@o1381755.ingest.sentry.io/6695436\",\n    // Adjust this value in production, or use tracesSampler for greater control\n    tracesSampleRate: 1.0,\n    attachStacktrace: true\n});\n\n\n/***/ }),\n\n/***/ 7663:\n/***/ (function(module) {\n\nvar __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();\n\n/***/ }),\n\n/***/ 1163:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(387)\n\n\n/***/ })\n\n},\n/******/ function(__webpack_require__) { // webpackRuntimeModules\n/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }\n/******/ __webpack_require__.O(0, [774,179], function() { return __webpack_exec__(9484), __webpack_exec__(5627), __webpack_exec__(1597), __webpack_exec__(387); });\n/******/ var __webpack_exports__ = __webpack_require__.O();\n/******/ _N_E = __webpack_exports__;\n/******/ }\n]);"],"names":["self","push","__unused_webpack_module","__webpack_exports__","__webpack_require__","d","withScope","captureException","configureScope","_hub_js__WEBPACK_IMPORTED_MODULE_0__","exception","captureContext","Gd","callback","getCurrentHub","getMainCarrier","_sentry_utils__WEBPACK_IMPORTED_MODULE_1__","_sentry_utils__WEBPACK_IMPORTED_MODULE_2__","_sentry_utils__WEBPACK_IMPORTED_MODULE_3__","_sentry_utils__WEBPACK_IMPORTED_MODULE_5__","_sentry_utils__WEBPACK_IMPORTED_MODULE_6__","_scope_js__WEBPACK_IMPORTED_MODULE_0__","_session_js__WEBPACK_IMPORTED_MODULE_4__","Hub","__init","_stack","constructor","client","scope","s","_version","prototype","call","getStackTop","bindClient","isOlderThan","version","top","setupIntegrations","pushScope","clone","getScope","getStack","getClient","popScope","length","pop","hint","eventId","_lastEventId","event_id","DM","syntheticException","_withClient","originalException","captureMessage","message","level","captureEvent","event","type","lastEventId","addBreadcrumb","breadcrumb","beforeBreadcrumb","maxBreadcrumbs","getOptions","timestamp","yW","mergedBreadcrumb","finalBreadcrumb","Cf","setUser","user","setTags","tags","setExtras","extras","setTag","key","value","setExtra","extra","setContext","name","context","run","oldHub","makeMain","getIntegration","integration","_oO","__SENTRY_DEBUG__","kg","warn","id","startTransaction","customSamplingContext","_callExtensionMethod","traceHeaders","captureSession","endSession","_sendSessionUpdate","layer","session","getSession","RJ","setSession","startSession","release","environment","global","R","userAgent","navigator","Hv","getUser","currentSession","status","CT","shouldSendDefaultPii","options","Boolean","sendDefaultPii","method","args","sentry","carrier","__SENTRY__","extensions","apply","hub","undefined","registry","getHubFromCarrier","setHubOnCarrier","hasHubOnCarrier","KV","getHubFromActiveDomain","activeDomain","domain","active","registryHubTopStack","_Oo","Y","addGlobalEventProcessor","Scope","_sentry_utils__WEBPACK_IMPORTED_MODULE_4__","_session_js__WEBPACK_IMPORTED_MODULE_0__","_notifyingListeners","_scopeListeners","_eventProcessors","_breadcrumbs","_attachments","_user","_tags","_extra","_contexts","_sdkProcessingMetadata","newScope","_level","_span","_session","_transactionName","_fingerprint","_requestSession","addScopeListener","addEventProcessor","_notifyScopeListeners","getRequestSession","setRequestSession","requestSession","setFingerprint","fingerprint","setLevel","setTransactionName","setSpan","span","getSpan","getTransaction","transaction","update","updatedScope","Object","keys","PO","contexts","clear","maxCrumbs","Math","min","slice","clearBreadcrumbs","addAttachment","attachment","getAttachments","clearAttachments","applyToEvent","trace","getTraceContext","transactionName","_applyFingerprint","breadcrumbs","sdkProcessingMetadata","_notifyEventProcessors","getGlobalEventProcessors","setSDKProcessingMetadata","newData","processors","index","cW","resolve","reject","processor","result","log","J8","then","final","forEach","lE","concat","updateSession","makeSession","closeSession","_sentry_utils__WEBPACK_IMPORTED_MODULE_0__","startingTime","ph","sid","init","started","duration","errors","ignoreDuration","Jr","Date","toISOString","did","attrs","ip_address","ipAddress","user_agent","email","username","module","addExtensionMethods","startIdleTransaction","logger","is","node","instrument","utils","errorCallback","activeTransaction","x1","setStatus","idletransaction","esm_transaction","toTraceparent","sample","samplingContext","rate","zu","sampled","setMetadata","transactionSampling","Number","sampleRate","tracesSampler","parentSampled","tracesSampleRate","i2","JSON","stringify","random","op","_startTransaction","transactionContext","initSpanRecorder","_experiments","maxSpans","idleTimeout","finalTimeout","onScope","io","cu","_autoloadDatabaseIntegrations","packageToIntegrationMapping","mongodb","l$","Mongo","mongoose","mysql","Mysql","pg","Postgres","mappedPackages","filter","moduleName","$y","map","pkg","e","p","integrations","o","hmd","IdleTransaction","DEFAULT_FINAL_TIMEOUT","DEFAULT_IDLE_TIMEOUT","_span_js__WEBPACK_IMPORTED_MODULE_0__","_transaction_js__WEBPACK_IMPORTED_MODULE_2__","IdleTransactionSpanRecorder","gB","_pushActivity","_popActivity","transactionSpanId","maxlen","add","spanId","finish","endTimestamp","_I","activities","__init2","_heartbeatCounter","__init3","_finished","__init4","_beforeFinishCallbacks","_idleHub","_idleTimeout","_finalTimeout","_onScope","clearActiveTransaction","_startIdleTimeout","setTimeout","spanRecorder","spans","keepSpan","startTimestamp","registerBeforeFinishCallback","pushActivity","popActivity","_pingHeartbeat","_cancelIdleTimeout","_idleTimeoutID","clearTimeout","_beat","heartbeatString","join","_prevHeartbeatString","Span","SpanRecorder","_sentry_utils_esm_buildPolyfills__WEBPACK_IMPORTED_MODULE_4__","_maxlen","traceId","substring","__init5","__init6","data","spanContext","parentSpanId","description","startChild","childSpan","nameStr","opStr","logMessage","metadata","spanMetadata","setData","setHttpStatus","httpStatus","String","spanStatus","spanStatusfromHttpCode","isSuccess","replace","sampledString","toContext","updateWithContext","h","parent_span_id","span_id","trace_id","toJSON","start_timestamp","Transaction","_sentry_utils_esm_buildPolyfills__WEBPACK_IMPORTED_MODULE_5__","_sentry_hub__WEBPACK_IMPORTED_MODULE_1__","Dr","_measurements","_frozenDynamicSamplingContext","_hub","_name","source","changes","propagations","_trimEnd","trimEnd","incomingDynamicSamplingContext","dynamicSamplingContext","newName","setName","setMeasurement","unit","newMetadata","recordDroppedEvent","finishedSpans","reduce","prev","current","getDynamicSamplingContext","transaction_info","measurements","publicKey","public_key","getDsn","maybeSampleRate","sample_rate","toString","segment","user_segment","msToSec","getActiveTransaction","hasTracingEnabled","_sentry_hub__WEBPACK_IMPORTED_MODULE_0__","maybeOptions","maybeHub","time","htmlTreeAsString","getLocationHref","getDomElement","_global_js__WEBPACK_IMPORTED_MODULE_1__","_is_js__WEBPACK_IMPORTED_MODULE_0__","elem","keyAttrs","currentElem","out","height","len","nextStr","_htmlElementAsString","parentNode","reverse","el","className","classes","attr","i","tagName","toLowerCase","keyAttrPairs","keyAttr","getAttribute","keyAttrPair","HD","split","allowedAttrs","document","location","href","oO","selector","querySelector","_nullishCoalesce","lhs","rhsFn","_optionalChain","ops","lastAccessLHS","fn","getGlobalObject","getGlobalSingleton","_node_js__WEBPACK_IMPORTED_MODULE_0__","fallbackGlobalObject","g","window","creator","obj","addInstrumentationHandler","_global_js__WEBPACK_IMPORTED_MODULE_0__","_is_js__WEBPACK_IMPORTED_MODULE_5__","_logger_js__WEBPACK_IMPORTED_MODULE_1__","_object_js__WEBPACK_IMPORTED_MODULE_3__","_stacktrace_js__WEBPACK_IMPORTED_MODULE_2__","_supports_js__WEBPACK_IMPORTED_MODULE_4__","handlers","instrumented","RU","console","hl","originalConsoleMethod","triggerHandlers","instrumentDOM","triggerDOMHandler","bind","globalDOMEventHandler","makeDOMEventHandler","addEventListener","proto","target","hasOwnProperty","originalAddEventListener","listener","__sentry_instrumentation_handlers__","handlerForType","refCount","handler","originalRemoveEventListener","instrumentXHR","xhrproto","XMLHttpRequest","originalOpen","xhr","url","xhrInfo","__sentry_xhr__","toUpperCase","match","__sentry_own_request__","onreadystatechangeHandler","readyState","status_code","now","onreadystatechange","original","readyStateArgs","originalSend","body","t$","originalFetch","handlerData","fetchData","getFetchMethod","fetchArgs","V9","Request","getFetchUrl","response","error","instrumentHistory","Bf","oldOnPopState","onpopstate","to","from","lastHref","history","historyReplacementFunction","originalHistoryFunction","_oldOnErrorHandler","onerror","msg","line","column","arguments","_oldOnUnhandledRejectionHandler","onunhandledrejection","$P","debounceTimerID","lastCapturedEvent","globalListener","shouldSkipDOMEvent","isContentEditable","shouldShortcircuitPreviousDebounce","previous","isSyntheticEvent","isString","isThenable","isRegExp","isPlainObject","isDOMError","isInstanceOf","isErrorEvent","isError","isEvent","isDOMException","isNaN","isElement","isPrimitive","objectToString","wat","Error","isBuiltin","Event","Element","base","_e","consoleSandbox","CONSOLE_LEVELS","originalConsole","wrappedLevels","originalWrappedFunc","__sentry_original__","makeLogger","enabled","uuid4","addExceptionTypeValue","addExceptionMechanism","checkOrSetAlreadyCaught","getEventDescription","arrayify","_object_js__WEBPACK_IMPORTED_MODULE_1__","crypto","msCrypto","randomUUID","getRandomByte","getRandomValues","Uint8Array","c","getFirstException","values","firstException","newMechanism","currentMechanism","mechanism","handled","mergedData","__sentry_captured__","xp","err","maybeArray","Array","isArray","dynamicRequire","isNodeEnv","loadModule","process","__SENTRY_BROWSER_BUNDLE__","mod","request","require","cwd","normalize","normalizeToSize","object","depth","maxSize","normalized","jsonSize","encodeURI","hasWeakSet","inner","stacktrace","input","maxProperties","visit","memo","WeakSet","has","delete","splice","memoize","unmemoize","includes","stringified","stringifyValue","_events","Cy","getPrototypeOf","startsWith","valueWithToJSON","jsonValue","numAdded","visitable","Sh","visitKey","visitValue","ERROR","markFunctionWrapped","getOriginalFunction","dropUndefinedKeys","convertToPlainObject","urlEncode","fill","addNonEnumerableProperty","extractExceptionKeysForMessage","_browser_js__WEBPACK_IMPORTED_MODULE_1__","_string_js__WEBPACK_IMPORTED_MODULE_2__","replacementFactory","wrapped","defineProperty","writable","configurable","func","encodeURIComponent","VZ","stack","getOwnProperties","cO","newObj","serializeEventTarget","currentTarget","CustomEvent","detail","kK","Rt","extractedProps","property","maxLength","sort","$G","includedKeys","serialized","inputValue","_dropUndefinedKeys","memoizationMap","memoVal","get","returnValue","set","item","Map","createStackParser","parsers","sortedParsers","a","b","skipFirst","frames","cleanedLine","parser","frame","stripSentryFramesAndReverse","localStack","firstFrameFunction","function","lastFrameFunction","indexOf","filename","stackParserFromStackParserOptions","stackParser","getFunctionName","defaultFunctionName","truncate","safeJoin","isMatchingPattern","str","max","substr","delimiter","output","pattern","Kj","test","supportsFetch","supportsHistory","isNativeFetch","supportsNativeFetch","Headers","Response","fetch","doc","createElement","sandbox","hidden","head","appendChild","contentWindow","removeChild","chrome","isChromePackagedApp","app","runtime","hasHistoryApi","pushState","replaceState","rejectedSyncPromise","resolvedSyncPromise","SyncPromise","States","reason","_","_state","PENDING","_handlers","executor","_resolve","_reject","onfulfilled","onrejected","_executeHandlers","catch","val","finally","onfinally","isRejected","_setResult","RESOLVED","REJECTED","state","_value","cachedHandlers","browserPerformanceTimeOrigin","timestampWithMs","timestampInSeconds","dateTimestampInSeconds","_node_js__WEBPACK_IMPORTED_MODULE_1__","dateTimestampSource","nowSeconds","platformPerformance","getNodePerformance","perfHooks","performance","getBrowserPerformance","timeOrigin","timestampSource","performanceNow","dateNow","timeOriginDelta","abs","navigationStart","timing","navigationStartDelta","hasNavigationStart","parseUrl","query","fragment","host","path","protocol","relative","stripUrlQueryAndFragment","urlPath","__unused_webpack_exports","_global","SENTRY_RELEASE","ref","ref1","exports","env","__NEXT_P","__unused_webpack___webpack_exports__","SDK_VERSION","esm_logger","misc","string","DEFAULT_IGNORE_ERRORS","InboundFilters","__initStatic","_options","setupOnce","eventProcess","ignoreErrors","clientOptions","_mergeOptions","internalOptions","allowUrls","denyUrls","ignoreInternal","_shouldDropEvent","_isSentryError","jH","_getPossibleEventMessages","some","zC","_isDeniedUrl","_getEventFilterUrl","_isAllowedUrl","_getLastValidUrl","originalFunctionToString","FunctionToString","Function","HK","esm_scope","esm_hub","installedIntegrations","esm_global","supports","esm_session","SentryError","logLevel","setPrototypeOf","DSN_REGEX","dsn_dsnToString","dsn","withPassword","pass","port","projectId","dsnFromComponents","components","syncpromise","createEnvelope","headers","items","addItemToEnvelope","envelope","newItem","forEachEnvelopeItem","envelopeItems","envelopeItemType","envelopeItem","encodeUTF8","textEncoder","utf8","TextEncoder","encode","serializeEnvelope","envHeaders","parts","append","next","itemHeaders","payload","concatBuffers","buffers","totalLength","acc","buf","merged","offset","buffer","createAttachmentEnvelopeItem","content_type","contentType","attachment_type","attachmentType","ITEM_TYPE_TO_DATA_CATEGORY_MAP","sessions","client_report","user_report","getEnvelopeEndpointWithUrlEncodedAuth","tunnelOrOptions","sdkInfo","tunnel","_metadata","sdk","_j","sentry_key","sentry_version","sentry_client","getSdkMetadataForEnvelopeHeader","ALREADY_SEEN_ERROR","BaseClient","_integrations","_integrationsInitialized","_numProcessing","_outcomes","_dsn","validateDsn","requiredComponents","component","parseInt","dsnFromString","exec","lastPath","projectMatch","_transport","transport","transportOptions","YO","_process","eventFromException","_captureEvent","promisedEvent","pt","eventFromMessage","_isEnabled","sendSession","getTransport","flush","timeout","_isClientDoneProcessing","clientFinished","transportFlushed","WD","close","integrationIndex","getIntegrationById","integrationId","sendEvent","createEventEnvelope","eventType","samplingMethod","packages","envelopeHeaders","sent_at","sample_rates","attachments","_sendEnvelope","category","sendClientReports","_updateSessionFromEvent","crashed","errored","exceptions","ex","sessionNonTerminal","ticked","interval","setInterval","clearInterval","_prepareEvent","normalizeDepth","normalizeMaxBreadth","prepared","_applyClientOptions","_applyIntegrationsMetadata","finalScope","evt","_normalizeEvent","maxBreadth","Fv","dist","maxValueLength","integrationsArray","_processEvent","finalEvent","sentryError","beforeSend","$2","isTransaction","__sentry__","_ensureBeforeSendRv","rv","nullErr","processedEvent","transactionInfo","promise","send","_clearOutcomes","outcomes","quantity","exceptionFromError","parseStackFrames","eventFromError","popSize","getPopSize","framesToPop","reactMinifiedRegexp","eventFromUnknownInput","attachStacktrace","isUnhandledRejection","VW","errorEvent","TX","fm","domException","eventFromString","Db","code","eventFromPlainObject","zf","__serialized__","Qy","EG","synthetic","browser","validSeverityLevels","BREADCRUMB_INTEGRATION_ID","Breadcrumbs","dom","_consoleBreadcrumb","serializeAttribute","_xhrBreadcrumb","_fetchBreadcrumb","_historyBreadcrumb","nK","parsedLoc","en","parsedFrom","parsedTo","cachedFetchImpl","getNativeFetchImplementation","Du","fetchImpl","globalObject","BrowserClient","visibilityState","_flushOutcomes","breadcrumbIntegration","platform","discarded_events","isRealNavigator","sendBeacon","Ak","credentials","keepalive","UNKNOWN_FUNCTION","createFrame","lineno","colno","in_app","chromeRegex","chromeEvalRegex","subMatch","extractSafariExtensionDetails","geckoREgex","geckoEvalRegex","gecko","winjsRegex","winjs","defaultStackParser","pE","isSafariExtension","isSafariWebExtension","esm_exports","ignoreOnError","shouldIgnoreOnError","wrap","before","wrapper","__sentry_wrapped__","sentryWrapped","wrappedArguments","arg","$e","Tb","$Q","descriptor","getOwnPropertyDescriptor","DEFAULT_EVENT_TARGET","TryCatch","eventTarget","requestAnimationFrame","_wrapTimeFunction","_wrapRAF","_wrapXHR","eventTargetOption","_wrapEventTarget","originalCallback","xmlHttpRequestProps","prop","wrapOptions","originalFunction","eventName","handleEvent","wrappedEventHandler","originalEventHandler","GlobalHandlers","_installFunc","_installGlobalOnErrorHandler","_installGlobalOnUnhandledRejectionHandler","stackTraceLimit","installFunc","globalHandlerLog","getHubAndOptions","groups","_enhanceEventWithInitialFrame","addMechanismAndCapture","ev","ev0","ev0s","ev0sf","l4","LinkedErrors","_key","_limit","limit","_handler","linkedErrors","_walkErrorTree","Dedupe","eventProcessor","currentEvent","previousEvent","currentMessage","previousMessage","previousException","currentException","_previousEvent","_isSameFingerprint","_isSameStacktrace","_getExceptionFromEvent","currentFrames","_getFramesFromEvent","previousFrames","frameA","frameB","currentFingerprint","previousFingerprint","httpcontext_global","HttpContext","referrer","Referer","createTransport","makeRequest","makePromiseBuffer","remove","task","$","taskProducer","drain","counter","capturedSetTimeout","bufferSize","rateLimits","filteredEnvelopeItems","envelopeItemDataCategory","limits","disabledUntil","all","filteredEnvelope","recordEnvelopeLoss","requestTask","statusCode","updateRateLimits","updatedRateLimits","rateLimitHeader","retryAfterHeader","trim","retryAfter","categories","headerDelay","delay","parseRetryAfterHeader","header","headerDate","parse","makeFetchTransport","nativeFetch","requestOptions","referrerPolicy","fetchOptions","makeXHRTransport","getResponseHeader","open","setRequestHeader","defaultIntegrations","startSessionOnHub","hubextensions","TRACEPARENT_REGEXP","extractTraceparentData","traceparent","matches","BAGGAGE_HEADER_NAME","SENTRY_BAGGAGE_KEY_PREFIX","SENTRY_BAGGAGE_KEY_PREFIX_REGEX","baggageHeaderToDynamicSamplingContext","baggageHeader","baggageObject","curr","currBaggageObject","baggageHeaderToObject","entries","dynamicSamplingContextToSentryBaggageHeader","objectToBaggageHeader","objectKey","objectValue","currentIndex","baggageEntry","newBaggageHeader","dscKey","dscValue","keyOrValue","decodeURIComponent","backgroundtab_global","bindReporter","metric","reportAllChanges","prevValue","forceReport","delta","generateUniqueID","floor","initMetric","observe","PerformanceObserver","supportedEntryTypes","po","l","getEntries","buffered","onHidden","cb","once","onHiddenOrPageHide","removeEventListener","getCLS","onReport","report","sessionValue","sessionEntries","entryHandler","entry","hadRecentInput","firstSessionEntry","lastSessionEntry","startTime","takeRecords","firstHiddenTime","initHiddenTime","Infinity","trackChanges","timeStamp","getVisibilityWatcher","getFID","visibilityWatcher","processingStart","disconnect","reportedMetricIDs","getLCP","stopListening","capture","isMeasurementValue","isFinite","_startChild","ctx","metrics_global","getBrowserPerformanceAPI","_performanceCursor","_lcpEntry","_clsEntry","_addPerformanceNavigationTiming","eventEnd","end","start","XL","defaultRequestInstrumentationOptions","traceFetch","traceXHR","tracingOrigins","router_global","DEFAULT_BROWSER_TRACING_OPTIONS","nT","mg","markBackgroundTransactions","routingInstrumentation","customStartTransaction","startTransactionOnPageLoad","startTransactionOnLocationChange","startingUrl","pathname","enableLongTask","BrowserTracing","_emitOptionsWarning","_metricOptions","startTrackingWebVitals","Z1","mark","_reportAllChanges","x","_2","_3","_4","_getCurrentHub","instrumentRouting","shouldCreateSpanForRequest","_createRouteTransaction","statusType","instrumentOutgoingRequests","urlMap","defaultShouldCreateSpan","origins","origin","shouldCreateSpan","fetchCallback","__span","addTracingHeadersToFetchRequest","sentryBaggageHeader","sentryTraceHeader","baggage","newHeaders","existingBaggageHeader","newBaggageHeaders","xhrCallback","__sentry_xhr_span_id__","beforeNavigate","isPageloadTransaction","sentryTraceMetaTagValue","getMetaContent","baggageMetaTagValue","traceParentData","expandedContext","modifiedContext","finalContext","idleTransaction","lb","addPerformanceEntries","performanceEntries","responseStartTimestamp","requestStartTimestamp","entryType","requestStart","responseEnd","responseStart","measureStartTimestamp","firstHidden","shouldRecord","resourceName","initiatorType","transferSize","encodedBodySize","decodedBodySize","_trackNavigator","connection","effectiveType","rtt","downlink","deviceMemory","hardwareConcurrency","oldValue","normalizedValue","measurementTimestamp","fidMark","cls","measurementName","element","size","sources","metaName","metaTag","qT","__SENTRY_TRACING__","ro","router","router_default","n","client_global","DEFAULT_TAGS","prevLocationName","nextRouterInstrumentation","startTransactionCb","route","params","extractNextDataTagInformation","nextData","nextDataTag","getElementById","innerHTML","nextDataTagInfo","page","props","pageProps","_sentryBaggage","_sentryTraceData","events","on","matchedRoute","getNextRouteFromPathname","pageRoutes","__BUILD_MANIFEST","sortedPages","find","optionalCatchallWildcardRegex","routeParts","routeRegExp","routePart","rt","navigationTarget","transactionSource","navigationTransaction","nextRouteChangeSpan","finishRouteChangeSpan","off","setNestedKey","keyPath","addOrUpdateIntegrationInArray","defaultIntegrationInstance","userIntegrations","forcedOptions","userInstance","names","SENTRY_DSN","NEXT_PUBLIC_SENTRY_DSN","createClientIntegrations","addOrUpdateIntegration","userIntegrationsFunc","userFinalIntegrations","autoSessionTracking","clientClass","Sq","getIntegrationsToSetup","isDefaultInstance","integrationsByName","finalIntegrations","currentInstance","existingInstance","debugIndex","findIndex","debugInstance","debug","enable","initialScope","startSessionTracking","filterTransactions","r","u","t","defaultSetTimout","defaultClearTimeout","runTimeout","cleanUpNextTick","drainQueue","runClearTimeout","Item","fun","array","noop","nextTick","title","argv","versions","addListener","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","chdir","umask","__nccwpck_require__","ab","__dirname","__webpack_exec__","moduleId","O","_N_E"],"sourceRoot":""}